# 『関数型言語を実装する：チュートリアル』を読む

[Simon L. Payton Jones, David R. Lester *Implementing Functional Languages: a tutorial*, 1991](https://www.microsoft.com/en-us/research/publication/implementing-functional-languages-a-tutorial/)

> 本書は、遅延グラフ簡約を用いた非正格な関数型言語の実装を理解するための実践的なアプローチを提供します。
この本は、読者が自明ではないコンパイラを開発、修正、実験することで、関数型言語の実装を「生き生きと」させるための実践的な実験材料を提供することを目的としています。

この本にある実装は、元々 Miranda[^1]で書かれていましたが、現在、公開されているものは、Haskellで示されています[^2]。
30年も前に出版されたものなので、説明されている実装は、最新の言語実装技術によるものではなく、現在では素朴にみえるものです。
しかし、基本的なアイデアは興味深く、実装としてもまとまっているので、入門をおえたプログラマ向けのHaskellプログラミングの教材として楽しいものになっています。
おまけに遅延評価を行う関数型言語系の実装が学べます。
他にも、現在では当たり前になり、標準的なライブラリとして提供されている（それゆえに、利用はするが、どのようなアイデアでデザインされているのかあまり知らない）プリティプリンタやパーザコンビネータのアイデアを楽しめます。

[^1]: Miranda は Research Software Ltd. の登録商標です。

[^2]: 地の文の説明は、Miranda を前提としています。

## この本の構成

- [x] 1. Core言語の抽象構文木、プリティプリンタ、パーザ
- [x] 2. テンプレート具体化を利用した（仮想）マシン
    - [x] 2.3 Mark1 最小のテンプレート具体化グラフ簡約器
    - [x] 2.4 Mark2 let(rec)式
    - [x] 2.5 Mark3 更新の追加
    - [x] 2.6 Mark4 算術演算の追加
    - [x] 2.7 Mark5 構造を持つデータ
         - [x] 2.7.2 条件式
         - [x] 2.7.3 対
         - [x] 2.7.4 リスト
         - [x] 2.7.5 リストの印字
    - [x] 2.8 別実装
         - [x] 2.8.1 プリミティブの別実装（Mark5a）
         - [x] 2.8.2 ダンプの別実装（Mark5b）ステップ実行機能も追加済み
         - [x] 2.8.4 データ値の別実装（Mark5c）
    - [x] 2.9 GC
         - [x] 2.9.1 マーク・スキャン GC（Mark5mgc）
         - [x] 2.9.2 間接参照の除去
         - [x] 2.9.3 反転ポインタ
         - [x] 2.9.4 2-スペースGC（コピーGC）
- [ ] 3. G-machine（グラフ簡約マシン）
    - [x] 3.1 G-machine 入門
        - [x] 3.1.1 例
        - [x] 3.1.2 さらに最適化
    - [x] 3.2 雛形を構築するためのコード列
        - [x] 3.2.1 算術式の後置評価
        - [x] 3.2.2 後置コードでグラフを構成する
        - [x] 3.2.3 具体化の後に何が起きるか
    - [x] 3.3 Mark 1: 最小限の G-machine
        - [x] 3.3.1 全体構造
        - [x] 3.3.2 データ構造
        - [x] 3.3.3 評価器
        - [x] 3.3.4 プログラムのコンパイル
        - [x] 3.3.5 結果の印字
        - [x] 3.3.6 Mark 1 G-machine の改良
    - [x] 3.4 Mark 2: Lazy化
        - [x] 3.4.1 データ構造
        - [x] 3.4.2 評価器
        - [x] 3.4.3 コンパイラ
    - [x] 3.5 Mark 3: `let(rec)` 式
        - [x] 3.5.1 局所的に束縛される変数
        - [x] 3.5.2 データ構造
        - [x] 3.5.3 評価器
        - [x] 3.5.4 コンパイラ
    - [x] 3.6 Mark 4: プリミティブの追加
        - [x] 3.6.1 データ構造
        - [x] 3.6.2 状態の印字
        - [x] 3.6.3 新しい命令の状態遷移
        - [x] 3.6.4 コンパイラ
    - [x] 3.7 Mark 5: 算術演算処理をよりよくするために
        - [x] 3.7.1 課題
        - [x] 3.7.2 解決
    - [x] 3.8 Mark 6: データ構造の追加
        - [x] 3.8.1 概観
        - [x] 3.8.2 データ構造
        - [x] 3.8.3 結果の表示
        - [x] 3.8.4 命令セット
        - [x] 3.8.5 コンパイラ
        - [x] 3.8.6 比較演算で新しい論理値表現を使う
        - [x] 3.8.7 受け入れ言語の拡張
    - [x] 3.9 Mark 7: さらなる改良
        - [x] 3.9.1 V-スタックを使った階乗計算の実行
        - [x] 3.9.2 データ構造
        - [x] 3.9.3 インストラクションセット
        - [x] 3.9.4 コンパイラ
    - [x] 3.10 結論
- [ ] 4. TIM（Three Instruction Machine）
    - [x] 4.1 背景： TIMの動作
        - [x] 4.1.1 平坦化
        - [x] 4.1.2 タプリング
        - [x] 4.1.3 無脊椎
        - [x] 4.1.4 例
        - [x] 4.1.5 状態遷移規則による機械の定義
        - [x] 4.1.6 コンパイル
        - [x] 4.1.7 更新
    - [ ] 4.2 Mark 1: 最小TIM
        - [x] 4.2.1 全体構成
        - [x] 4.2.2 データ型定義
        - [x] 4.2.3 プログラムのコンパイル
        - [x] 4.2.4 評価器
        - [x] 4.2.5 結果の印字
        - [ ] 4.2.6 ガベージコレクション
    - [x] 4.3 Mark 2: 算術演算の追加
        - [x] 4.3.1 概要: 算術演算の動作
        - [x] 4.3.2 単純な算術演算の実装追加
        - [x] 4.3.3 算術演算用コンパイル図式
    - [x] 4.4 Mark 3: `let(rec)` 式
        - [x] 4.4.1 `let` 式
        - [x] 4.4.2 `letrec` 式
        - [x] 4.4.3 フレームスロットの再利用
        - [ ] 4.4.4 ガベージコレクション
    - [x] 4.5 Mark 4: 更新
        - [x] 4.5.1 基本的な技法
        - [x] 4.5.2 `PushMarker`命令のコンパイル
        - [x] 4.5.3 更新機構の実装
        - [x] 4.5.4 間接参照の更新に伴う問題
        - [x] 4.5.5 共有`let(rec)`-束縛変数の更新
        - [x] 4.5.6 間接参照鎖の除去
        - [x] 4.5.7 部分適用の更新
    - [ ] 4.6 Mark 5: 構造を持つデータ
        - [x] 4.6.1 汎用的アプローチ
        - [x] 4.6.2 構造を持つデータに対する遷移規則とコンパイル図式
        - [x] 4.6.3 トライアウト
        - [x] 4.6.4 リストの印字
        - [ ] 4.6.5 構造をもつデータ構造の直接使用
    - [ ] 4.7 Mark 6: CAFとコードストア
        - [ ] 4.7.1 CAFの実装
        - [ ] 4.7.2 より正確なコードストアのモデル
    - [ ] 4.8 まとめ        
- [ ] 5. 並列G-machine
    - [x] 5.1 導入
        - [ ] 5.1.1 並列関数プログラミング
        - [ ] 5.1.2 並列グラフ簡約
    - [ ] 5.2 Mark 1: 最小並列G-Machine
        - [ ] 5.2.1 データ型定義
        - [ ] 5.2.2 評価器
        - [ ] 5.2.3 プログラムのコンパイル
        - [ ] 5.2.4 結果の印字
    - [ ] 5.3 Mark 2: 評価-停止モデル
        - [ ] 5.3.1 ノードのデータ型
        - [ ] 5.3.2 命令セット
    - [ ] 5.4 Mark 3: 現実的な並列G-Machine
        - [ ] 5.4.1 スケジューリング方針
        - [ ] 5.4.2 保守的並列と投機的並列
    - [ ] 5.5 Mark 4: よりよいブロッキング処理
        - [ ] 5.5.1 データ構造
        - [ ] 5.5.2 ロックとアンロック
    - [ ] 5.6 まとめ
- [ ] 6. λ 持ち上げ
    - [ ] 6.1 導入
    - [ ] 6.2 `Expr`データ型の改良
    - [ ] 6.3 Mark 1: 単純な λ 持ち上げ器
        - [ ] 6.3.1 単純な λ 持ち上げ器の実装
        - [ ] 6.3.2 自由変数
        - [ ] 6.3.3 スーパーコンビネータの生成
        - [ ] 6.3.4 変数を非重複にする
        - [ ] 6.3.5 スーパーコンビネータの収集
    - [ ] 6.4 Mark 2: 単純な λ 持ち上げ器の改良
        - [ ] 6.4.1 単純な拡張
        - [ ] 6.4.2 冗長なスーパーコンビネータの除去
        - [ ] 6.4.3 冗長な局所定義の除去
    - [ ] 6.5 Mark 3: Johnsson流 λ 持ち上げ
        - [ ] 6.5.1 実装
        - [ ] 6.5.2 関数中の自由変数の抽象化
        - [ ] 6.5.3 難しい点
    - [ ] 6.6 Mark 4: 独立した完全怠惰パス
        - [ ] 6.6.1 完全怠惰の復習
        - [ ] 6.6.2 `let(rec)`存在下の完全怠惰 λ 持ち上げ
        - [ ] 6.6.3 λ 持ち上げのない完全怠惰
        - [ ] 6.6.4 完全怠惰 λ 持ち上げ器
        - [ ] 6.6.5 λ の分離
        - [ ] 6.6.6 レベル番号の追加
        - [ ] 6.6.7 極大自由式(MFE: Maximal Free Expression)
        - [ ] 6.6.8 変数名の付け替え
        - [ ] 6.6.9 浮動`let(rec)`式
    - [ ] 6.7 Mark 5: 完全怠惰の改善
        - [ ] 6.7.1 `case`式の追加
        - [ ] 6.7.2 冗長なスーパーコンビネータ除去
        - [ ] 6.7.3 冗長な完全怠惰の回避
    - [ ] 6.8 Mark 6: 依存性解析
        - [ ] 6.8.1 強連結成分
        - [ ] 6.8.2 強連結成分アルゴリズムの実装
        - [ ] 6.8.3 依存性解析
    - [ ] 6.9 まとめ

## コードについて

この main ブランチのコードは ghc-9.2.0 で導入された言語拡張 'OverloadedRecordDot' を使用しています。

## 起動

プロジェクトルートにおいて、コマンド `stack exec -- ti5b prog/prog17.ifl` で雛形具体化機械 `ti5b` にサンプルプログラム `prog17.ifl` ロードして起動すると、

```
% stack exec -- ti5b prog/prog17.ifl
   0) Heap [  40: NAP #21 #1
              39: NPrim print
              ...
              途中略
              ...
      Stack [  40: NAp   21    1 (NSupercomb main) ]
      Depth 1
      Dump []
      Output []
      no description


|
```
のように初期状態（の一部）が表示された状態で停止する。

- Enterキー（空文字列の入力）で、次の状態に遷移
- Cキー、Enterキーの順で押下（文字列`C`の入力）で、最後の状態まで遷移
- 数字入力で、指定したかずぶんだけ状態が遷移

