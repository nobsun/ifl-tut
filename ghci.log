Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.1 (lib) (file src/Template/Mark5/Machine.hs changed)
Preprocessing library for ifl-tut-0.2.8.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 23] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 23] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 23] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 23] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 23] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 23] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 23] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 23] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 23] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 23] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 23] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[12 of 23] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[13 of 23] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[14 of 23] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[15 of 23] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[16 of 23] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[17 of 23] Compiling Template.Mark5   ( src/Template/Mark5.hs, interpreted )
[18 of 23] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[19 of 23] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[20 of 23] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[21 of 23] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[22 of 23] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 23] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
Ok, 23 modules loaded.
>>> import Template.Mark5.Machine
>>> test "main = Cons (negate (2 + 3)) Nil"
   0) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   21    1 (NSupercomb main) ]
      Depth 1
      Output []
      Rule (2,0)
      
   1) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  21: NSupercomb printList
               40: NAp   21    1 (NSupercomb main) ]
      Depth 2
      Output []
      Rule (2,1)
      
   2) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,3)
      
   3) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
   4) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
   5) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
   6) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [   1: NSupercomb main ]
      Depth 1
      Output []
      Rule (2,1)
      
   7) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NAp   48   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,3)
      
   8) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
   9) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NSupercomb Cons
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  10) Heap [  18: NPrim Constr
               1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NPrim Constr
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,3)
      
  11) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NData 1 #47 #17 ]
      Depth 1
      Output []
      Rule (2,10)
      
  12) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,10)
      
  13) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
  14) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
  15) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
  16) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   49   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,1)
      
  17) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
  18) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  22: NSupercomb printCons
               49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  19) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,3)
      
  20) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  21) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  22) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NAp #44 #45) ]
      Depth 1
      Output []
      Rule (2,13)
      
  23) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NAp #44 #45) ]
      Depth 2
      Output []
      Rule (2,1)
      
  24) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NAp   44   45 (NNum 3) ]
      Depth 1
      Output []
      Rule (2,9)
      
  25) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 2
      Output []
      Rule (2,1)
      
  26) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  24: NPrim +
               44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 3
      Output []
      Rule (2,1)
      
  27) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NNum 5 ]
      Depth 1
      Output []
      Rule (2,17)
      
  28) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NNum 5) ]
      Depth 1
      Output []
      Rule (2,7)
      
  29) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NNum 5) ]
      Depth 2
      Output []
      Rule (2,1)
      
  30) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NNum -5 ]
      Depth 1
      Output []
      Rule (2,5)
      
  31) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,7)
      
  32) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  33) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  34) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   21   17 (NSupercomb Nil) ]
      Depth 1
      Output [-5]
      Rule (2,12)
      
  35) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  21: NSupercomb printList
               51: NAp   21   17 (NSupercomb Nil) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  36) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  37) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  38) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  39) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  40) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NSupercomb Nil ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  41) Heap [  17: NPrim Constr
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NPrim Constr ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  42) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NData 0  ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  43) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  44) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  45) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  46) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  47) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NInd #38 ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  48) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  38: NPrim stop ]
      Depth 1
      Output [-5]
      Rule (2,4)
      
  49) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [ ]
      Depth 0
      Output [-5]
      Rule (2,11)
      

Total number of steps = 49
             Sc steps = 6
           Prim steps = 4
     Allocation count = 53
   Max depth of stack = 4>>> 
>>> test "main = Cons (negate (2 + 3)) Nil"
   0) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   21    1 (NSupercomb main) ]
      Depth 1
      Output []
      Rule (2,0)
      
   1) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  21: NSupercomb printList
               40: NAp   21    1 (NSupercomb main) ]
      Depth 2
      Output []
      Rule (2,1)
      
   2) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,3)
      
   3) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
   4) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
   5) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
   6) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [   1: NSupercomb main ]
      Depth 1
      Output []
      Rule (2,1)
      
   7) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NAp   48   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,3)
      
   8) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
   9) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NSupercomb Cons
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  10) Heap [  18: NPrim Constr
               1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NPrim Constr
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,3)
      
  11) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NData 1 #47 #17 ]
      Depth 1
      Output []
      Rule (2,10)
      
  12) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,10)
      
  13) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
  14) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
  15) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
  16) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   49   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,1)
      
  17) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
  18) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  22: NSupercomb printCons
               49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  19) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,3)
      
  20) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  21) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  22) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NAp #44 #45) ]
      Depth 1
      Output []
      Rule (2,13)
      
  23) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NAp #44 #45) ]
      Depth 2
      Output []
      Rule (2,1)
      
  24) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NAp   44   45 (NNum 3) ]
      Depth 1
      Output []
      Rule (2,9)
      
  25) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 2
      Output []
      Rule (2,1)
      
  26) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  24: NPrim +
               44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 3
      Output []
      Rule (2,1)
      
  27) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NNum 5 ]
      Depth 1
      Output []
      Rule (2,17)
      
  28) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NNum 5) ]
      Depth 1
      Output []
      Rule (2,7)
      
  29) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NNum 5) ]
      Depth 2
      Output []
      Rule (2,1)
      
  30) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NNum -5 ]
      Depth 1
      Output []
      Rule (2,5)
      
  31) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,7)
      
  32) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  33) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  34) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   21   17 (NSupercomb Nil) ]
      Depth 1
      Output [-5]
      Rule (2,12)
      
  35) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  21: NSupercomb printList
               51: NAp   21   17 (NSupercomb Nil) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  36) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  37) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  38) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  39) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  40) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NSupercomb Nil ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  41) Heap [  17: NPrim Constr
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NPrim Constr ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  42) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NData 0  ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  43) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  44) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  45) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  46) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  47) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NInd #38 ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  48) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  38: NPrim stop ]
      Depth 1
      Output [-5]
      Rule (2,4)
      
  49) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [ ]
      Depth 0
      Output [-5]
      Rule (2,11)
      

Total number of steps = 49
             Sc steps = 6
           Prim steps = 4
     Allocation count = 53
   Max depth of stack = 4>>> 
>>> :e Template.Mark5.Machine
:l Template.Mark5.Machine
catn: Template.Mark5.Machine: openFile: does not exist (No such file or directory)
>>> 
<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap
        Iseq
        Language
        Parser
        Stack
        Template.Mark5.Node
        Template.Mark5.PPrint
        Template.Mark5.Primitive
        Template.Mark5.State
        Utils
[ 1 of 11] Compiling Parser           ( src/Parser.hs, interpreted )
[ 2 of 11] Compiling Stack            ( src/Stack.hs, interpreted )
[ 3 of 11] Compiling Utils            ( src/Utils.hs, interpreted )
[ 4 of 11] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 5 of 11] Compiling Language         ( src/Language.hs, interpreted )
[ 6 of 11] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 7 of 11] Compiling Heap             ( src/Heap.hs, interpreted )
[ 8 of 11] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[ 9 of 11] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[10 of 11] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[11 of 11] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
Ok, 11 modules loaded.
>>> test "main = Cons (negate (2 + 3)) Nil"
   0) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   21    1 (NSupercomb main) ]
      Depth 1
      Output []
      Rule (2,0)
      
   1) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  21: NSupercomb printList
               40: NAp   21    1 (NSupercomb main) ]
      Depth 2
      Output []
      Rule (2,1)
      
   2) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,3)
      
   3) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
   4) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
   5) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
   6) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [   1: NSupercomb main ]
      Depth 1
      Output []
      Rule (2,1)
      
   7) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NAp   48   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,3)
      
   8) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
   9) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NSupercomb Cons
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  10) Heap [  18: NPrim Constr
               1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NPrim Constr
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,3)
      
  11) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NData 1 #47 #17 ]
      Depth 1
      Output []
      Rule (2,10)
      
  12) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,10)
      
  13) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
  14) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
  15) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
  16) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   49   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,1)
      
  17) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
  18) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  22: NSupercomb printCons
               49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  19) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,3)
      
  20) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  21) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  22) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NAp #44 #45) ]
      Depth 1
      Output []
      Rule (2,13)
      
  23) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NAp #44 #45) ]
      Depth 2
      Output []
      Rule (2,1)
      
  24) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NAp   44   45 (NNum 3) ]
      Depth 1
      Output []
      Rule (2,9)
      
  25) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 2
      Output []
      Rule (2,1)
      
  26) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  24: NPrim +
               44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 3
      Output []
      Rule (2,1)
      
  27) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NNum 5 ]
      Depth 1
      Output []
      Rule (2,17)
      
  28) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NNum 5) ]
      Depth 1
      Output []
      Rule (2,7)
      
  29) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NNum 5) ]
      Depth 2
      Output []
      Rule (2,1)
      
  30) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NNum -5 ]
      Depth 1
      Output []
      Rule (2,5)
      
  31) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,7)
      
  32) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  33) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  34) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   21   17 (NSupercomb Nil) ]
      Depth 1
      Output [-5]
      Rule (2,12)
      
  35) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  21: NSupercomb printList
               51: NAp   21   17 (NSupercomb Nil) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  36) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  37) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  38) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  39) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  40) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NSupercomb Nil ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  41) Heap [  17: NPrim Constr
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NPrim Constr ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  42) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NData 0  ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  43) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  44) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  45) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  46) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  47) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NInd #38 ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  48) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  38: NPrim stop ]
      Depth 1
      Output [-5]
      Rule (2,4)
      
  49) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [ ]
      Depth 0
      Output [-5]
      Rule (2,11)
      

Total number of steps = 49
             Sc steps = 6
           Prim steps = 4
     Allocation count = 53
   Max depth of stack = 4
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.1 (lib) (file src/Template/Mark5a/PPrint.hs changed)
Preprocessing library for ifl-tut-0.2.8.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 23] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 23] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 23] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 23] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 23] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 23] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 23] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 23] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 23] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 23] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 23] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[12 of 23] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[13 of 23] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[14 of 23] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[15 of 23] Compiling Template.Mark5   ( src/Template/Mark5.hs, interpreted )
[16 of 23] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[17 of 23] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[18 of 23] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[19 of 23] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[20 of 23] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[21 of 23] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[22 of 23] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 23] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
Ok, 23 modules loaded.
>>> import Template.Mark5a.Machine
>>> :i Double
type Double :: *
data Double
  = ghc-prim-0.8.0:GHC.Types.D# ghc-prim-0.8.0:GHC.Prim.Double#
  	-- Defined in ghc-prim-0.8.0:GHC.Types
instance Eq Double -- Defined in ghc-prim-0.8.0:GHC.Classes
instance Ord Double -- Defined in ghc-prim-0.8.0:GHC.Classes
instance Enum Double -- Defined in GHC.Float
instance Floating Double -- Defined in GHC.Float
instance Fractional Double -- Defined in GHC.Float
instance Num Double -- Defined in GHC.Float
instance Real Double -- Defined in GHC.Float
instance RealFloat Double -- Defined in GHC.Float
instance RealFrac Double -- Defined in GHC.Float
instance Show Double -- Defined in GHC.Float
instance Read Double -- Defined in GHC.Read
>>> x = [1.797693e308 ..]
>>> x
[1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693Interrupted.
>>> length it

<interactive>:5:8: error:
     Variable not in scope: it :: t0 a0
     Perhaps you meant id (imported from Prelude)
>>> x = [1.797693e308 ..]
>>> length x
Interrupted.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.1 (lib) (file src/Template/Mark5a/PPrint.hs changed)
Preprocessing library for ifl-tut-0.2.8.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 23] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 23] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 23] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 23] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 23] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 23] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 23] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 23] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 23] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 23] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 23] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[12 of 23] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[13 of 23] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[14 of 23] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[15 of 23] Compiling Template.Mark5   ( src/Template/Mark5.hs, interpreted )
[16 of 23] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[17 of 23] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[18 of 23] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[19 of 23] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[20 of 23] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[21 of 23] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[22 of 23] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 23] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
Ok, 23 modules loaded.
>>> x = [1.797693e307, 1.0e307 ..]
>>> x
[1.797693e307,1.0e307,2.0230699999999987e306,-5.953860000000001e306,-1.3930790000000004e307,-2.1907720000000006e307,-2.9884650000000006e307,-3.786158000000001e307,-4.583851000000001e307,-5.381544000000001e307,-6.179237000000002e307,-6.976930000000002e307,-7.774623000000001e307,-8.572316000000002e307,-9.370009e307,-1.0167702000000002e308,-1.0965395e308,-1.1763088e308,-1.2560781000000001e308,-1.3358474e308,-1.4156167000000002e308,-1.4953860000000001e308,-1.5751553000000002e308,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-InfInterrupted.
>>> succ (1/0)
Infinity
>>> length $ show $ succ (10^99)
100
>>> length $ show $ succ (10^49)
50
>>> length $ show $ (maxBound :: Word)
20
>>> succ (10^30)
1000000000000000000000000000001
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.1 (lib) (ephemeral targets)
Preprocessing library for ifl-tut-0.2.8.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 23] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 23] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 23] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 23] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 23] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 23] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 23] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 23] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 23] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 23] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 23] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[12 of 23] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[13 of 23] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[14 of 23] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[15 of 23] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[16 of 23] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[17 of 23] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[18 of 23] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[19 of 23] Compiling Template.Mark5   ( src/Template/Mark5.hs, interpreted )
[20 of 23] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[21 of 23] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[22 of 23] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[23 of 23] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 23 modules loaded.
>>> import Template.Mark5b.State
>>> import Template.Mark5b.Machine
>>> :t testt

<interactive>:1:1: error:
     Variable not in scope: testt
     Perhaps you meant test (imported from Template.Mark5b.Machine)
>>> :t test
test :: String -> IO ()
>>> test "main = Cons e Nil ; e = (1 + 2) * (3 + 5)"
   0) Heap [  41: NAp #22 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  41: NAp   22    1 (NSupercomb main) ]
      Depth 1
      Output []
      Rule (2,0)
      
   1) Heap [  41: NAp #22 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  22: NSupercomb printList
               41: NAp   22    1 (NSupercomb main) ]
      Depth 2
      Output []
      Rule (2,1)
      
   2) Heap [  41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  41: NAp   43   23 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,3)
      
   3) Heap [  41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
   4) Heap [  41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  42: NAp   37    1 (NSupercomb main)
               43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
   5) Heap [  41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  37: NPrim caseList
               42: NAp   37    1 (NSupercomb main)
               43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
   6) Heap [  41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [   1: NSupercomb main
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
   7) Heap [   1: NAp #44 #18
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [   1: NAp   44   18 (NSupercomb Nil)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,3)
      
   8) Heap [   1: NAp #44 #18
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  44: NAp   19    2 (NSupercomb e)
                1: NAp   44   18 (NSupercomb Nil)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
   9) Heap [   1: NAp #44 #18
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  19: NSupercomb Cons
               44: NAp   19    2 (NSupercomb e)
                1: NAp   44   18 (NSupercomb Nil)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
  10) Heap [  19: NPrim Constr
               1: NAp #44 #18
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  19: NPrim Constr
               44: NAp   19    2 (NSupercomb e)
                1: NAp   44   18 (NSupercomb Nil)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,3)
      
  11) Heap [   1: NData 1 #2 #18 #23
              19: NPrim Constr
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [   1: NData 1 #2 #18 #23
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,10)
      
  12) Heap [   1: NData 1 #2 #18 #23
              19: NPrim Constr
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  41: NAp   43   23 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,10)
      
  13) Heap [   1: NData 1 #2 #18 #23
              19: NPrim Constr
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
  14) Heap [   1: NData 1 #2 #18 #23
              19: NPrim Constr
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  42: NAp   37    1 (NData 1 #2 #18 #23)
               43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
  15) Heap [   1: NData 1 #2 #18 #23
              19: NPrim Constr
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  37: NPrim caseList
               42: NAp   37    1 (NData 1 #2 #18 #23)
               43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
*** Exception: src/Template/Mark5b/State.hs:(188,32)-(191,79): Non-exhaustive patterns in case

>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.2.2 (lib) (first run)
Configuring library for ifl-tut-0.2.8.2.2..
Preprocessing library for ifl-tut-0.2.8.2.2..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 22] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 22] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 22] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 22] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 22] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 22] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 22] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 22] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 22] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 22] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 22] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )

src/Template/Mark5b/Machine.hs:134:5: error:
    parse error on input |
    |
134 |     | otherwise
    |     ^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 125  buildInitialHeap = let ?sz = defaultHeapSize in
 126      mapAccumL allocateSc hInitial
 127  
 128  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 129  allocateSc heap scDefn = case scDefn of
 130      (name, args, body) -> (heap', (name, addr))
 131          where
 132              (heap', addr) = hAlloc heap (NSupercomb name args body)
 133  
 134  {- | Evaluator -}
 135  
 136  eval :: TiState -> [TiState]
 137  eval state = state : rests
 138      where
 139          rests | tiFinal state = []
 140                | otherwise      = eval $ doAdminTotalSteps $ step state
 141  
 142  tiFinal :: TiState -> Bool
 143  tiFinal state
 144      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 145      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 146      | otherwise                    = False
 147      where
 148          (soleAddr, _) = pop state.stack
 149  
 150  isDataNode :: Node -> Bool
 151  isDataNode node = case node of
 152      NNum _ -> True
 153      _      -> False
 154  
 155  doAdminTotalSteps :: TiState -> TiState
 156  doAdminTotalSteps = applyToStats incTotalSteps
 157  
 158  doAdminScSteps :: TiState -> TiState
 159  doAdminScSteps = applyToStats incScSteps
 160  
 161  doAdminPrimSteps :: TiState -> TiState
 162  doAdminPrimSteps = applyToStats incPrimSteps
 163  
 164  step :: TiState -> TiState
 165  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 166             $ state
 167  
 168  numStep :: Int -> TiState -> TiState
 169  numStep n = error "numStep: Number applied as a function"
 170  
 171  apStep :: Addr -> Addr -> TiState -> TiState
 172  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 173  
 174  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 175  scStep name args body state
 176      | state.stack.curDepth < n' 
 177          = error "scStep: too few arguments given"
 178      | otherwise
 179          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 180      where
 181          stack' = push resultAddr (discard n' state.stack)
 182          (heap', resultAddr) = instantiate body state.heap env
 183          env = argBindings ++ state.globals
 184          argBindings = zip args (getargs state.heap state.stack)
 185          n' = succ (length args)
 186  
 187  getargs :: TiHeap -> TiStack -> [Addr]
 188  getargs heap stack = case pop stack of
 189      (sc, stack') -> map getarg stack'.stkItems
 190          where
 191              getarg addr = arg
 192                  where
 193                      NAp fun arg = hLookup heap addr
 194  
 195  {- | Instantiation -}
 196  
 197  instantiate :: CoreExpr
 198              -> TiHeap
 199              -> Assoc Name Addr
 200              -> (TiHeap, Addr)
 201  instantiate expr heap env = dispatchCoreExpr
 202      (instantiateVar heap env)
 203      (instantiateNum heap env)
 204      (instantiateConstr heap env)
 205      (instantiateAp heap env)
 206      (instantiateLet heap env)
 207      (instantiateCase heap env)
 208      (instantiateLam heap env)
 209      expr
 210  
 211  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 212  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 213  
 214  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 215  instantiateNum heap env num = hAlloc heap (NNum num)
 216  
 217  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 218  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 219  
 220  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 221  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 222      where
 223          (heap1, a1) = instantiate a heap  env
 224          (heap2, a2) = instantiate b heap1 env
 225  
 226  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 227  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 228  
 229  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 230  instantiateCase heap env expr alters = error "Cannot instatiate case"
 231  
 232  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 233  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 234  
 235  {- | Formatting Results -}
 236  
 237  showResults :: [TiState] -> String
 238  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 239  
 240  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 241  mapoid (f, g) (x:xs) = case xs of
 242      [] -> f x : [g x]
 243      _  -> f x : mapoid (f,g) xs
 244  
 245  showState :: TiState -> IseqRep
 246  showState state = iConcat
 247      [ showHeap state.heap, iNewline
 248      , showStack state.heap state.stack, iNewline
 249      , showRuleId state.ruleid, iNewline
 250      ]
 251  
 252  showHeap :: TiHeap -> IseqRep
 253  showHeap heap = iConcat
 254      [ iStr "Heap ["
 255      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 256      , iStr " ]"
 257      ]
 258  
 259  showHeapItem :: (Addr, Node) -> IseqRep
 260  showHeapItem (addr, node) = iConcat
 261              [ showFWAddr addr, iStr ": "
 262              , showNode node
 263              ]
 264  
 265  showAddr :: Addr -> IseqRep
 266  showAddr addr = iStr ('#' : show addr)
 267  
 268  showFWAddr :: Addr -> IseqRep
 269  showFWAddr addr = iStr (rjustify 4 (show addr))
 270  
 271  showNode :: Node -> IseqRep
 272  showNode node = dispatchNode
 273      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 274      (\ name args body -> iStr ("NSupercomb " ++ name))
 275      (\ n -> iStr "NNum " `iAppend` iNum n)
 276      node
 277  
 278  showStack :: TiHeap -> TiStack -> IseqRep
 279  showStack heap stack = iConcat
 280      [ iStr "Stack ["
 281      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 282      , iStr " ]"
 283      ]
 284      where
 285          showStackItem addr = iConcat
 286              [ showFWAddr addr, iStr ": "
 287              , showStkNode heap (hLookup heap addr)
 288              ]
 289  
 290  showStkNode :: TiHeap -> Node -> IseqRep
 291  showStkNode heap node = dispatchNode
 292      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 293                                    , iStr " ", showFWAddr argAddr, iStr " ("
 294                                    , showNode (hLookup heap argAddr), iStr ")" ])
 295      (\ _ _ _ -> showNode node)
 296      (\ _ -> showNode node)
 297      node
 298  
 299  showRuleId :: TiRuleId -> IseqRep
 300  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 301  
 302  showStats :: TiState -> IseqRep
 303  showStats state = iConcat
 304      [ iNewline, iStr "Total number of steps = "
 305      , iNum state.stats.totalSteps
 306      , iNewline, iStr "             Sc steps = "
 307      , iNum state.stats.scSteps
 308      , iNewline, iStr "           Prim steps = "
 309      , iNum state.stats.primSteps
 310      , iNewline, iStr "          Delta steps = "
 311      , iNum state.stats.deltaSteps
 312      , iNewline, iStr "     Allocation count = "
 313      , iNum state.heap.maxAllocs
 314      , iNewline, iStr "   Max depth of stack = "
 315      , iNum state.stack.maxDepth
 316      ]
 317  
 318  {- | Testing -}
 319  
 320  test :: String -> IO ()
 321  test = putStr . run
 322  
 323  {- | 01 
 324  -}
 325  prog01 :: String
 326  prog01 = unlines
 327      ["main = S K K 3"]
 328  
 329  istate01 :: TiState
 330  istate01 = compile $ parse prog01
 331  
 332  iheap01 :: TiHeap
 333  iheap01 = istate01.heap
 334  
 335  iitems01 :: Assoc Addr Node
 336  iitems01 = iheap01.assocs
[11 of 22] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )

src/Template/Mark5b/Machine.hs:43:33: error:
    Not in scope: control
   |
43 | setControl ctrl state = state { control = ctrl }
   |                                 ^^^^^^^

src/Template/Mark5b/Machine.hs:49:7: error: Not in scope: control
   |
49 |     { control = []
   |       ^^^^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.2.2 (lib) (first run)
Preprocessing library for ifl-tut-0.2.8.2.2..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 22] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 22] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 22] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 22] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 22] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 22] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 22] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 22] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 22] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 22] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 22] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )

src/Template/Mark5b/Machine.hs:43:33: error:
    Not in scope: control
   |
43 | setControl ctrl state = state { control = ctrl }
   |                                 ^^^^^^^

src/Template/Mark5b/Machine.hs:49:7: error: Not in scope: control
   |
49 |     { control = []
   |       ^^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 125  buildInitialHeap = let ?sz = defaultHeapSize in
 126      mapAccumL allocateSc hInitial
 127  
 128  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 129  allocateSc heap scDefn = case scDefn of
 130      (name, args, body) -> (heap', (name, addr))
 131          where
 132              (heap', addr) = hAlloc heap (NSupercomb name args body)
 133  
 134  {- | Evaluator -}
 135  
 136  eval :: TiState -> [TiState]
 137  eval state = state : rests
 138      where
 139          rests | tiFinal state = []
 140                | otherwise      = eval $ doAdminTotalSteps $ step state
 141  
 142  tiFinal :: TiState -> Bool
 143  tiFinal state
 144      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 145      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 146      | otherwise                    = False
 147      where
 148          (soleAddr, _) = pop state.stack
 149  
 150  isDataNode :: Node -> Bool
 151  isDataNode node = case node of
 152      NNum _ -> True
 153      _      -> False
 154  
 155  doAdminTotalSteps :: TiState -> TiState
 156  doAdminTotalSteps = applyToStats incTotalSteps
 157  
 158  doAdminScSteps :: TiState -> TiState
 159  doAdminScSteps = applyToStats incScSteps
 160  
 161  doAdminPrimSteps :: TiState -> TiState
 162  doAdminPrimSteps = applyToStats incPrimSteps
 163  
 164  step :: TiState -> TiState
 165  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 166             $ state
 167  
 168  numStep :: Int -> TiState -> TiState
 169  numStep n = error "numStep: Number applied as a function"
 170  
 171  apStep :: Addr -> Addr -> TiState -> TiState
 172  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 173  
 174  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 175  scStep name args body state
 176      | state.stack.curDepth < n' 
 177          = error "scStep: too few arguments given"
 178      | otherwise
 179          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 180      where
 181          stack' = push resultAddr (discard n' state.stack)
 182          (heap', resultAddr) = instantiate body state.heap env
 183          env = argBindings ++ state.globals
 184          argBindings = zip args (getargs state.heap state.stack)
 185          n' = succ (length args)
 186  
 187  getargs :: TiHeap -> TiStack -> [Addr]
 188  getargs heap stack = case pop stack of
 189      (sc, stack') -> map getarg stack'.stkItems
 190          where
 191              getarg addr = arg
 192                  where
 193                      NAp fun arg = hLookup heap addr
 194  
 195  {- | Instantiation -}
 196  
 197  instantiate :: CoreExpr
 198              -> TiHeap
 199              -> Assoc Name Addr
 200              -> (TiHeap, Addr)
 201  instantiate expr heap env = dispatchCoreExpr
 202      (instantiateVar heap env)
 203      (instantiateNum heap env)
 204      (instantiateConstr heap env)
 205      (instantiateAp heap env)
 206      (instantiateLet heap env)
 207      (instantiateCase heap env)
 208      (instantiateLam heap env)
 209      expr
 210  
 211  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 212  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 213  
 214  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 215  instantiateNum heap env num = hAlloc heap (NNum num)
 216  
 217  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 218  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 219  
 220  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 221  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 222      where
 223          (heap1, a1) = instantiate a heap  env
 224          (heap2, a2) = instantiate b heap1 env
 225  
 226  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 227  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 228  
 229  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 230  instantiateCase heap env expr alters = error "Cannot instatiate case"
 231  
 232  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 233  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 234  
 235  {- | Formatting Results -}
 236  
 237  showResults :: [TiState] -> String
 238  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 239  
 240  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 241  mapoid (f, g) (x:xs) = case xs of
 242      [] -> f x : [g x]
 243      _  -> f x : mapoid (f,g) xs
 244  
 245  showState :: TiState -> IseqRep
 246  showState state = iConcat
 247      [ showHeap state.heap, iNewline
 248      , showStack state.heap state.stack, iNewline
 249      , showRuleId state.ruleid, iNewline
 250      ]
 251  
 252  showHeap :: TiHeap -> IseqRep
 253  showHeap heap = iConcat
 254      [ iStr "Heap ["
 255      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 256      , iStr " ]"
 257      ]
 258  
 259  showHeapItem :: (Addr, Node) -> IseqRep
 260  showHeapItem (addr, node) = iConcat
 261              [ showFWAddr addr, iStr ": "
 262              , showNode node
 263              ]
 264  
 265  showAddr :: Addr -> IseqRep
 266  showAddr addr = iStr ('#' : show addr)
 267  
 268  showFWAddr :: Addr -> IseqRep
 269  showFWAddr addr = iStr (rjustify 4 (show addr))
 270  
 271  showNode :: Node -> IseqRep
 272  showNode node = dispatchNode
 273      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 274      (\ name args body -> iStr ("NSupercomb " ++ name))
 275      (\ n -> iStr "NNum " `iAppend` iNum n)
 276      node
 277  
 278  showStack :: TiHeap -> TiStack -> IseqRep
 279  showStack heap stack = iConcat
 280      [ iStr "Stack ["
 281      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 282      , iStr " ]"
 283      ]
 284      where
 285          showStackItem addr = iConcat
 286              [ showFWAddr addr, iStr ": "
 287              , showStkNode heap (hLookup heap addr)
 288              ]
 289  
 290  showStkNode :: TiHeap -> Node -> IseqRep
 291  showStkNode heap node = dispatchNode
 292      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 293                                    , iStr " ", showFWAddr argAddr, iStr " ("
 294                                    , showNode (hLookup heap argAddr), iStr ")" ])
 295      (\ _ _ _ -> showNode node)
 296      (\ _ -> showNode node)
 297      node
 298  
 299  showRuleId :: TiRuleId -> IseqRep
 300  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 301  
 302  showStats :: TiState -> IseqRep
 303  showStats state = iConcat
 304      [ iNewline, iStr "Total number of steps = "
 305      , iNum state.stats.totalSteps
 306      , iNewline, iStr "             Sc steps = "
 307      , iNum state.stats.scSteps
 308      , iNewline, iStr "           Prim steps = "
 309      , iNum state.stats.primSteps
 310      , iNewline, iStr "          Delta steps = "
 311      , iNum state.stats.deltaSteps
 312      , iNewline, iStr "     Allocation count = "
 313      , iNum state.heap.maxAllocs
 314      , iNewline, iStr "   Max depth of stack = "
 315      , iNum state.stack.maxDepth
 316      ]
 317  
 318  {- | Testing -}
 319  
 320  test :: String -> IO ()
 321  test = putStr . run
 322  
 323  {- | 01 
 324  -}
 325  prog01 :: String
 326  prog01 = unlines
 327      ["main = S K K 3"]
 328  
 329  istate01 :: TiState
 330  istate01 = compile $ parse prog01
 331  
 332  iheap01 :: TiHeap
 333  iheap01 = istate01.heap
 334  
 335  iitems01 :: Assoc Addr Node
 336  iitems01 = iheap01.assocs
[ 9 of 22] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 22] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted ) [Template.Mark5b.State changed]
[11 of 22] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[12 of 22] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[13 of 22] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[14 of 22] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[15 of 22] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[16 of 22] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[17 of 22] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[18 of 22] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[19 of 22] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[20 of 22] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[21 of 22] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[22 of 22] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 22 modules loaded.
>>> mapAccumL (\ js i -> (tail js, map (i *) js)) [1 .. 9] 

<interactive>:2:1: error:
    Variable not in scope:
      mapAccumL :: ([b0] -> b0 -> ([b0], [b0])) -> [a0] -> t
>>> import Data.List
>>> mapAccumL (\ js i -> (tail js, map (i *) js)) [1 .. 9] 

<interactive>:4:1: error:
     No instance for (Show ([Integer] -> ([Integer], [[Integer]])))
        arising from a use of Text.Show.Unicode.uprint
        (maybe you haven't applied a function to enough arguments?)
     In a stmt of an interactive GHCi command:
        Text.Show.Unicode.uprint it
>>> mapAccumL (\ js i -> (tail js, map (i *) js)) [1 .. 9] [1 .. 9]
([],[[1,2,3,4,5,6,7,8,9],[4,6,8,10,12,14,16,18],[9,12,15,18,21,24,27],[16,20,24,28,32,36],[25,30,35,40,45],[36,42,48,54],[49,56,63],[64,72],[81]])
>>> map (\ i -> flip map [1 .. 9] (* i)) [1 .. 9]
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> map (flip map [1..9] . (*)) [1..9]
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> rjustify = reverse . take 3 . foldr (:) (repeat ' ')
>>> rjustify (show 1)
"  1"
>>> [ [ i * j | i <- [1..9]] | j <- [1 .. 9]] 
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> putStr (unlines (concatMap (map (reverse . take 3 . foldr (:) (repeat ' ') . show)) it))
  1
  2
  3
  4
  5
  6
  7
  8
  9
  2
  4
  6
  8
 01
 21
 41
 61
 81
  3
  6
  9
 21
 51
 81
 12
 42
 72
  4
  8
 21
 61
 02
 42
 82
 23
 63
  5
 01
 51
 02
 52
 03
 53
 04
 54
  6
 21
 81
 42
 03
 63
 24
 84
 45
  7
 41
 12
 82
 53
 24
 94
 65
 36
  8
 61
 42
 23
 04
 84
 65
 46
 27
  9
 81
 72
 63
 54
 45
 36
 27
 18
>>> rjustify (show 72)
" 27"
>>> 
>>> 
>>> 
>>> 
>>> 
>>> putStr (unlines (map (concatMap (reverse . take 3 . foldr (:) (repeat ' ') . show)) it))

<interactive>:18:85: error:
     Couldn't match type Char with t0 a0
      Expected: [t0 a0]
        Actual: [Char]
     In the second argument of map, namely it
      In the first argument of unlines, namely
        (map
            (concatMap (reverse . take 3 . foldr (:) (repeat ' ') . show)) it)
      In the first argument of putStr, namely
        (unlines
            (map
               (concatMap (reverse . take 3 . foldr (:) (repeat ' ') . show))
               it))
>>> [ [ i * j | i <- [1..9]] | j <- [1 .. 9]] 
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> putStr (unlines (map (concatMap (reverse . take 3 . foldr (:) (repeat ' ') . show)) it))
  1  2  3  4  5  6  7  8  9
  2  4  6  8 01 21 41 61 81
  3  6  9 21 51 81 12 42 72
  4  8 21 61 02 42 82 23 63
  5 01 51 02 52 03 53 04 54
  6 21 81 42 03 63 24 84 45
  7 41 12 82 53 24 94 65 36
  8 61 42 23 04 84 65 46 27
  9 81 72 63 54 45 36 27 18
>>> [ [ i * j | i <- [1..9]] | j <- [1 .. 9]] 
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> putStr (unlines (map (concatMap (reverse . take 3 . foldl (flip (:)) (repeat ' ') . show)) it))
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> [ [ i * j | i <- [1..9]] | j <- [1 .. 9]] 
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> putStr (unlines (map (>>= (reverse . take 3 . foldl (flip (:)) (repeat ' ') . show)) it))
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> [ [ revreverse $ take 3 $ foldl (flip (:)) (repeat ' ') $ show     $ i * j | i <- [1..9]] | j <- [1 .. 9] ] 

<interactive>:25:5: error:
     Variable not in scope: revreverse :: [Char] -> a
     Perhaps you meant reverse (imported from Data.List)
>>> 
>>> 
>>> 
>>> 
>>> 
>>> [concat  [ reverse $ take 3 $ foldl (flip (:)) (repeat ' ') $ show     $ i * j | i <- [1..9]] | j <- [1 .. 9] ] 
["  1  2  3  4  5  6  7  8  9","  2  4  6  8 10 12 14 16 18","  3  6  9 12 15 18 21 24 27","  4  8 12 16 20 24 28 32 36","  5 10 15 20 25 30 35 40 45","  6 12 18 24 30 36 42 48 54","  7 14 21 28 35 42 49 56 63","  8 16 24 32 40 48 56 64 72","  9 18 27 36 45 54 63 72 81"]
>>> :t for

<interactive>:1:1: error:
     Variable not in scope: for
     Perhaps you meant or (imported from Data.List)
>>> :i &

<interactive>:1:1: error: Not in scope: &
>>> :e
No files to edit.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.2.2 (lib) (first run)
Preprocessing library for ifl-tut-0.2.8.2.2..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 22] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 22] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 22] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 22] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 22] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 22] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 22] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 22] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 22] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:328:18: error:
    Ambiguous occurrence rjustify
    It could refer to
       either Utils.rjustify,
              imported from Utils at src/Template/Mark5b/State.hs:11:1-12
              (and originally defined at src/Utils.hs:16:1-8)
           or Template.Mark5b.State.rjustify,
              defined at src/Template/Mark5b/State.hs:322:1
    |
328 |           $ kuku rjustify
    |                  ^^^^^^^^
Failed, 8 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 125  buildInitialHeap = let ?sz = defaultHeapSize in
 126      mapAccumL allocateSc hInitial
 127  
 128  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 129  allocateSc heap scDefn = case scDefn of
 130      (name, args, body) -> (heap', (name, addr))
 131          where
 132              (heap', addr) = hAlloc heap (NSupercomb name args body)
 133  
 134  {- | Evaluator -}
 135  
 136  eval :: TiState -> [TiState]
 137  eval state = state : rests
 138      where
 139          rests | tiFinal state = []
 140                | otherwise      = eval $ doAdminTotalSteps $ step state
 141  
 142  tiFinal :: TiState -> Bool
 143  tiFinal state
 144      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 145      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 146      | otherwise                    = False
 147      where
 148          (soleAddr, _) = pop state.stack
 149  
 150  isDataNode :: Node -> Bool
 151  isDataNode node = case node of
 152      NNum _ -> True
 153      _      -> False
 154  
 155  doAdminTotalSteps :: TiState -> TiState
 156  doAdminTotalSteps = applyToStats incTotalSteps
 157  
 158  doAdminScSteps :: TiState -> TiState
 159  doAdminScSteps = applyToStats incScSteps
 160  
 161  doAdminPrimSteps :: TiState -> TiState
 162  doAdminPrimSteps = applyToStats incPrimSteps
 163  
 164  step :: TiState -> TiState
 165  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 166             $ state
 167  
 168  numStep :: Int -> TiState -> TiState
 169  numStep n = error "numStep: Number applied as a function"
 170  
 171  apStep :: Addr -> Addr -> TiState -> TiState
 172  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 173  
 174  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 175  scStep name args body state
 176      | state.stack.curDepth < n' 
 177          = error "scStep: too few arguments given"
 178      | otherwise
 179          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 180      where
 181          stack' = push resultAddr (discard n' state.stack)
 182          (heap', resultAddr) = instantiate body state.heap env
 183          env = argBindings ++ state.globals
 184          argBindings = zip args (getargs state.heap state.stack)
 185          n' = succ (length args)
 186  
 187  getargs :: TiHeap -> TiStack -> [Addr]
 188  getargs heap stack = case pop stack of
 189      (sc, stack') -> map getarg stack'.stkItems
 190          where
 191              getarg addr = arg
 192                  where
 193                      NAp fun arg = hLookup heap addr
 194  
 195  {- | Instantiation -}
 196  
 197  instantiate :: CoreExpr
 198              -> TiHeap
 199              -> Assoc Name Addr
 200              -> (TiHeap, Addr)
 201  instantiate expr heap env = dispatchCoreExpr
 202      (instantiateVar heap env)
 203      (instantiateNum heap env)
 204      (instantiateConstr heap env)
 205      (instantiateAp heap env)
 206      (instantiateLet heap env)
 207      (instantiateCase heap env)
 208      (instantiateLam heap env)
 209      expr
 210  
 211  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 212  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 213  
 214  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 215  instantiateNum heap env num = hAlloc heap (NNum num)
 216  
 217  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 218  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 219  
 220  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 221  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 222      where
 223          (heap1, a1) = instantiate a heap  env
 224          (heap2, a2) = instantiate b heap1 env
 225  
 226  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 227  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 228  
 229  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 230  instantiateCase heap env expr alters = error "Cannot instatiate case"
 231  
 232  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 233  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 234  
 235  {- | Formatting Results -}
 236  
 237  showResults :: [TiState] -> String
 238  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 239  
 240  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 241  mapoid (f, g) (x:xs) = case xs of
 242      [] -> f x : [g x]
 243      _  -> f x : mapoid (f,g) xs
 244  
 245  showState :: TiState -> IseqRep
 246  showState state = iConcat
 247      [ showHeap state.heap, iNewline
 248      , showStack state.heap state.stack, iNewline
 249      , showRuleId state.ruleid, iNewline
 250      ]
 251  
 252  showHeap :: TiHeap -> IseqRep
 253  showHeap heap = iConcat
 254      [ iStr "Heap ["
 255      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 256      , iStr " ]"
 257      ]
 258  
 259  showHeapItem :: (Addr, Node) -> IseqRep
 260  showHeapItem (addr, node) = iConcat
 261              [ showFWAddr addr, iStr ": "
 262              , showNode node
 263              ]
 264  
 265  showAddr :: Addr -> IseqRep
 266  showAddr addr = iStr ('#' : show addr)
 267  
 268  showFWAddr :: Addr -> IseqRep
 269  showFWAddr addr = iStr (rjustify 4 (show addr))
 270  
 271  showNode :: Node -> IseqRep
 272  showNode node = dispatchNode
 273      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 274      (\ name args body -> iStr ("NSupercomb " ++ name))
 275      (\ n -> iStr "NNum " `iAppend` iNum n)
 276      node
 277  
 278  showStack :: TiHeap -> TiStack -> IseqRep
 279  showStack heap stack = iConcat
 280      [ iStr "Stack ["
 281      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 282      , iStr " ]"
 283      ]
 284      where
 285          showStackItem addr = iConcat
 286              [ showFWAddr addr, iStr ": "
 287              , showStkNode heap (hLookup heap addr)
 288              ]
 289  
 290  showStkNode :: TiHeap -> Node -> IseqRep
 291  showStkNode heap node = dispatchNode
 292      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 293                                    , iStr " ", showFWAddr argAddr, iStr " ("
 294                                    , showNode (hLookup heap argAddr), iStr ")" ])
 295      (\ _ _ _ -> showNode node)
 296      (\ _ -> showNode node)
 297      node
 298  
 299  showRuleId :: TiRuleId -> IseqRep
 300  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 301  
 302  showStats :: TiState -> IseqRep
 303  showStats state = iConcat
 304      [ iNewline, iStr "Total number of steps = "
 305      , iNum state.stats.totalSteps
 306      , iNewline, iStr "             Sc steps = "
 307      , iNum state.stats.scSteps
 308      , iNewline, iStr "           Prim steps = "
 309      , iNum state.stats.primSteps
 310      , iNewline, iStr "          Delta steps = "
 311      , iNum state.stats.deltaSteps
 312      , iNewline, iStr "     Allocation count = "
 313      , iNum state.heap.maxAllocs
 314      , iNewline, iStr "   Max depth of stack = "
 315      , iNum state.stack.maxDepth
 316      ]
 317  
 318  {- | Testing -}
 319  
 320  test :: String -> IO ()
 321  test = putStr . run
 322  
 323  {- | 01 
 324  -}
 325  prog01 :: String
 326  prog01 = unlines
 327      ["main = S K K 3"]
 328  
 329  istate01 :: TiState
 330  istate01 = compile $ parse prog01
 331  
 332  iheap01 :: TiHeap
 333  iheap01 = istate01.heap
 334  
 335  iitems01 :: Assoc Addr Node
 336  iitems01 = iheap01.assocs
[ 9 of 22] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:328:18: error:
    Ambiguous occurrence rjustify
    It could refer to
       either Utils.rjustify,
              imported from Utils at src/Template/Mark5b/State.hs:11:1-12
              (and originally defined at src/Utils.hs:16:1-8)
           or Template.Mark5b.State.rjustify,
              defined at src/Template/Mark5b/State.hs:322:1
    |
328 |           $ kuku rjustify
    |                  ^^^^^^^^
Failed, 8 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 125  buildInitialHeap = let ?sz = defaultHeapSize in
 126      mapAccumL allocateSc hInitial
 127  
 128  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 129  allocateSc heap scDefn = case scDefn of
 130      (name, args, body) -> (heap', (name, addr))
 131          where
 132              (heap', addr) = hAlloc heap (NSupercomb name args body)
 133  
 134  {- | Evaluator -}
 135  
 136  eval :: TiState -> [TiState]
 137  eval state = state : rests
 138      where
 139          rests | tiFinal state = []
 140                | otherwise      = eval $ doAdminTotalSteps $ step state
 141  
 142  tiFinal :: TiState -> Bool
 143  tiFinal state
 144      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 145      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 146      | otherwise                    = False
 147      where
 148          (soleAddr, _) = pop state.stack
 149  
 150  isDataNode :: Node -> Bool
 151  isDataNode node = case node of
 152      NNum _ -> True
 153      _      -> False
 154  
 155  doAdminTotalSteps :: TiState -> TiState
 156  doAdminTotalSteps = applyToStats incTotalSteps
 157  
 158  doAdminScSteps :: TiState -> TiState
 159  doAdminScSteps = applyToStats incScSteps
 160  
 161  doAdminPrimSteps :: TiState -> TiState
 162  doAdminPrimSteps = applyToStats incPrimSteps
 163  
 164  step :: TiState -> TiState
 165  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 166             $ state
 167  
 168  numStep :: Int -> TiState -> TiState
 169  numStep n = error "numStep: Number applied as a function"
 170  
 171  apStep :: Addr -> Addr -> TiState -> TiState
 172  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 173  
 174  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 175  scStep name args body state
 176      | state.stack.curDepth < n' 
 177          = error "scStep: too few arguments given"
 178      | otherwise
 179          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 180      where
 181          stack' = push resultAddr (discard n' state.stack)
 182          (heap', resultAddr) = instantiate body state.heap env
 183          env = argBindings ++ state.globals
 184          argBindings = zip args (getargs state.heap state.stack)
 185          n' = succ (length args)
 186  
 187  getargs :: TiHeap -> TiStack -> [Addr]
 188  getargs heap stack = case pop stack of
 189      (sc, stack') -> map getarg stack'.stkItems
 190          where
 191              getarg addr = arg
 192                  where
 193                      NAp fun arg = hLookup heap addr
 194  
 195  {- | Instantiation -}
 196  
 197  instantiate :: CoreExpr
 198              -> TiHeap
 199              -> Assoc Name Addr
 200              -> (TiHeap, Addr)
 201  instantiate expr heap env = dispatchCoreExpr
 202      (instantiateVar heap env)
 203      (instantiateNum heap env)
 204      (instantiateConstr heap env)
 205      (instantiateAp heap env)
 206      (instantiateLet heap env)
 207      (instantiateCase heap env)
 208      (instantiateLam heap env)
 209      expr
 210  
 211  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 212  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 213  
 214  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 215  instantiateNum heap env num = hAlloc heap (NNum num)
 216  
 217  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 218  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 219  
 220  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 221  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 222      where
 223          (heap1, a1) = instantiate a heap  env
 224          (heap2, a2) = instantiate b heap1 env
 225  
 226  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 227  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 228  
 229  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 230  instantiateCase heap env expr alters = error "Cannot instatiate case"
 231  
 232  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 233  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 234  
 235  {- | Formatting Results -}
 236  
 237  showResults :: [TiState] -> String
 238  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 239  
 240  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 241  mapoid (f, g) (x:xs) = case xs of
 242      [] -> f x : [g x]
 243      _  -> f x : mapoid (f,g) xs
 244  
 245  showState :: TiState -> IseqRep
 246  showState state = iConcat
 247      [ showHeap state.heap, iNewline
 248      , showStack state.heap state.stack, iNewline
 249      , showRuleId state.ruleid, iNewline
 250      ]
 251  
 252  showHeap :: TiHeap -> IseqRep
 253  showHeap heap = iConcat
 254      [ iStr "Heap ["
 255      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 256      , iStr " ]"
 257      ]
 258  
 259  showHeapItem :: (Addr, Node) -> IseqRep
 260  showHeapItem (addr, node) = iConcat
 261              [ showFWAddr addr, iStr ": "
 262              , showNode node
 263              ]
 264  
 265  showAddr :: Addr -> IseqRep
 266  showAddr addr = iStr ('#' : show addr)
 267  
 268  showFWAddr :: Addr -> IseqRep
 269  showFWAddr addr = iStr (rjustify 4 (show addr))
 270  
 271  showNode :: Node -> IseqRep
 272  showNode node = dispatchNode
 273      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 274      (\ name args body -> iStr ("NSupercomb " ++ name))
 275      (\ n -> iStr "NNum " `iAppend` iNum n)
 276      node
 277  
 278  showStack :: TiHeap -> TiStack -> IseqRep
 279  showStack heap stack = iConcat
 280      [ iStr "Stack ["
 281      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 282      , iStr " ]"
 283      ]
 284      where
 285          showStackItem addr = iConcat
 286              [ showFWAddr addr, iStr ": "
 287              , showStkNode heap (hLookup heap addr)
 288              ]
 289  
 290  showStkNode :: TiHeap -> Node -> IseqRep
 291  showStkNode heap node = dispatchNode
 292      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 293                                    , iStr " ", showFWAddr argAddr, iStr " ("
 294                                    , showNode (hLookup heap argAddr), iStr ")" ])
 295      (\ _ _ _ -> showNode node)
 296      (\ _ -> showNode node)
 297      node
 298  
 299  showRuleId :: TiRuleId -> IseqRep
 300  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 301  
 302  showStats :: TiState -> IseqRep
 303  showStats state = iConcat
 304      [ iNewline, iStr "Total number of steps = "
 305      , iNum state.stats.totalSteps
 306      , iNewline, iStr "             Sc steps = "
 307      , iNum state.stats.scSteps
 308      , iNewline, iStr "           Prim steps = "
 309      , iNum state.stats.primSteps
 310      , iNewline, iStr "          Delta steps = "
 311      , iNum state.stats.deltaSteps
 312      , iNewline, iStr "     Allocation count = "
 313      , iNum state.heap.maxAllocs
 314      , iNewline, iStr "   Max depth of stack = "
 315      , iNum state.stack.maxDepth
 316      ]
 317  
 318  {- | Testing -}
 319  
 320  test :: String -> IO ()
 321  test = putStr . run
 322  
 323  {- | 01 
 324  -}
 325  prog01 :: String
 326  prog01 = unlines
 327      ["main = S K K 3"]
 328  
 329  istate01 :: TiState
 330  istate01 = compile $ parse prog01
 331  
 332  iheap01 :: TiHeap
 333  iheap01 = istate01.heap
 334  
 335  iitems01 :: Assoc Addr Node
 336  iitems01 = iheap01.assocs

src/Template/Mark5b/State.hs:11:21: error:
    parse error on input rjustify
   |
11 | import Utils hiding rjustify
   |                     ^^^^^^^^
Failed, no modules loaded.
>>> :e
No files to edit.
>>> import Template.Mark5b.State

<no location info>: error:
    Could not load module Template.Mark5b.State
    It is a member of the hidden package ifl-tut-0.2.8.2.1.
    Perhaps you need to add ifl-tut to the build-depends in your .cabal file.
    It is a member of the hidden package ifl-tut-0.2.8.2.
    Perhaps you need to add ifl-tut to the build-depends in your .cabal file.
    It is a member of the hidden package ifl-tut-0.2.8.2.
    Perhaps you need to add ifl-tut to the build-depends in your .cabal file.
    It is a member of the hidden package ifl-tut-0.2.8.2.
    Perhaps you need to add ifl-tut to the build-depends in your .cabal file.
    It is a member of the hidden package ifl-tut-0.2.8.2.
    Perhaps you need to add ifl-tut to the build-depends in your .cabal file.
>>> kukuPrint

<interactive>:5:1: error: Variable not in scope: kukuPrint
>>> :e Template.Mark5a.State
:l Template.Mark5a.State
catn: Template.Mark5a.State: openFile: does not exist (No such file or directory)
>>> 
<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[1 of 7] Compiling Parser           ( src/Parser.hs, interpreted )
[2 of 7] Compiling Stack            ( src/Stack.hs, interpreted )
[3 of 7] Compiling Utils            ( src/Utils.hs, interpreted )
[4 of 7] Compiling Iseq             ( src/Iseq.hs, interpreted )
[5 of 7] Compiling Language         ( src/Language.hs, interpreted )
[6 of 7] Compiling Heap             ( src/Heap.hs, interpreted )
[7 of 7] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
Ok, 7 modules loaded.
>>> kukuPrint

<interactive>:8:1: error: Variable not in scope: kukuPrint
>>> printKuku

<interactive>:9:1: error: Variable not in scope: printKuku
>>> :e src/Template/Mark5b/State.hs
:l src/Template/Mark5b/State.hs 
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: (Int -> a) -> [[a]]
 319  kuku f = [ [ f (i * j) | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take 3 . foldl (flip (:)) (repeat ' ') . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr 
 326            $ unlines 
 327            $ map concat
 328            $ kuku rjustify

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
Ok, 7 modules loaded.
>>> 
<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[1 of 7] Compiling Parser           ( src/Parser.hs, interpreted )
[2 of 7] Compiling Stack            ( src/Stack.hs, interpreted )
[3 of 7] Compiling Utils            ( src/Utils.hs, interpreted )
[4 of 7] Compiling Iseq             ( src/Iseq.hs, interpreted )
[5 of 7] Compiling Language         ( src/Language.hs, interpreted )
[6 of 7] Compiling Heap             ( src/Heap.hs, interpreted )
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:328:18: error:
     Couldn't match type: a0 -> String
                     with: [Char]
      Expected: Int -> [Char]
        Actual: Int -> a0 -> String
     Probable cause: rjustify is applied to too few arguments
      In the first argument of kuku, namely rjustify
      In the second argument of ($), namely kuku rjustify
      In the second argument of ($), namely
        map concat $ kuku rjustify
    |
328 |           $ kuku rjustify
    |                  ^^^^^^^^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: (Int -> a) -> [[a]]
 319  kuku f = [ [ f (i * j) | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take 3 . foldl (flip (:)) (repeat ' ') . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr 
 326            $ unlines 
 327            $ map concat
 328            $ kuku (rjustify 3)

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> printKuku
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: (Int -> a) -> [[a]]
 319  kuku f = [ [ f (i * j) | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take 3 . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map concat $ kuku (rjustify 3)

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> printKuku
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: (Int -> a) -> [[a]]
 319  kuku f = [ [ f (i * j) | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map concat $ kuku (rjustify 3)

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> printKuku
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: [[a]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:319:43: error:
     No instance for (Enum a)
        arising from the arithmetic sequence 1 .. 9
      Possible fix:
        add (Enum a) to the context of
          the type signature for:
            kuku :: forall a. [[a]]
     In the expression: [1 .. 9]
      In a stmt of a list comprehension: i <- [1 .. 9]
      In the expression: [[i * j | j <- [1 .. 9]] | i <- [1 .. 9]]
    |
319 | kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
    |                                           ^^^^^^^^

src/Template/Mark5b/State.hs:319:44: error:
     No instance for (Num a) arising from the literal 1
      Possible fix:
        add (Num a) to the context of
          the type signature for:
            kuku :: forall a. [[a]]
     In the expression: 1
      In the expression: [1 .. 9]
      In a stmt of a list comprehension: i <- [1 .. 9]
    |
319 | kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
    |                                            ^

src/Template/Mark5b/State.hs:325:41: error:
     Ambiguous type variable a0 arising from a use of rjustify
      prevents the constraint (Show a0) from being solved.
      Probable fix: use a type annotation to specify what a0 should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in Data.Either
        instance Show Ordering -- Defined in GHC.Show
        instance Show Associativity -- Defined at src/Language.hs:208:38
        ...plus 28 others
        ...plus 53 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
     In the expression: rjustify 3
      In the first argument of map, namely (>>= rjustify 3)
      In the second argument of (.), namely map (>>= rjustify 3)
    |
325 | printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
    |                                         ^^^^^^^^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> printKuku
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> import Data.Function
>>> :i &
(&) :: a -> (a -> b) -> b 	-- Defined in Data.Function
infixl 1 &
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint
 330      = flip mapM_ [1 .. 9] $ \ i -> do
 331          { flip mapM_ [1 .. 9] $ \ j -> do
 332              { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
 333          ; putStrLn ""
 334          }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:332:21: error:
    Variable not in scope: (&) :: t0 -> (a0 -> String) -> t1
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                     ^

src/Template/Mark5b/State.hs:332:28: error:
    Variable not in scope:
      (&) :: t1 -> ([a1] -> [a1]) -> ([Char] -> [Char]) -> t2
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                            ^

src/Template/Mark5b/State.hs:332:56: error:
    Variable not in scope: (&) :: t2 -> ([a2] -> [a2]) -> t3
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                                                        ^

src/Template/Mark5b/State.hs:332:65: error:
    Variable not in scope: (&) :: t3 -> ([a3] -> [a3]) -> t4
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                                                                 ^

src/Template/Mark5b/State.hs:332:75: error:
    Variable not in scope: (&) :: t4 -> (String -> IO ()) -> IO b0
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                                                                           ^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint = do
 330      { let { (&) = flip ($); infixl & 1 }
 331      ; flip mapM_ [1 .. 9] $ \ i -> do
 332          { flip mapM_ [1 .. 9] $ \ j -> do
 333              { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
 334          ; putStrLn ""
 335          }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:330:38: error:
    parse error on input 1
    |
330 |     { let { (&) = flip ($); infixl & 1 }
    |                                      ^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint = do
 330      { let { (&) = flip ($); infixl 1 & }
 331      ; flip mapM_ [1 .. 9] $ \ i -> do
 332          { flip mapM_ [1 .. 9] $ \ j -> do
 333              { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
 334          ; putStrLn ""
 335          }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:336:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint = let { (&) = flip ($); infixl 1 & } in do
 330      { flip mapM_ [1 .. 9] $ \ i -> do
 331          { flip mapM_ [1 .. 9] $ \ j -> do
 332              { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
 333          ; putStrLn ""
 334          }
 335      }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:332:30: error:
     Couldn't match type: [Char]
                     with: IO () -> IO b0
      Expected: String -> IO () -> IO b0
        Actual: [Char] -> [Char]
     In the second argument of (&), namely reverse
      In the first argument of ($), namely i * j & show & reverse
      In a stmt of a 'do' block:
        i * j & show & reverse
          $ (++ repeat ' ') & take 3 & reverse & putStr
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                              ^^^^^^^

src/Template/Mark5b/State.hs:332:58: error:
     Couldn't match type: [Char]
                     with: [Char] -> [Char]
      Expected: ([Char] -> [Char]) -> [Char]
        Actual: [Char] -> [Char]
     In the second argument of (&), namely take 3
      In the first argument of (&), namely (++ repeat ' ') & take 3
      In the first argument of (&), namely
        (++ repeat ' ') & take 3 & reverse
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                                                          ^^^^^^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint = let { (&) = flip ($); infixl 1 & } in do
 330      { flip mapM_ [1 .. 9] $ \ i -> do
 331          { flip mapM_ [1 .. 9] $ \ j -> do
 332              { let rep = i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse
 333              ; putStr rep 
 334              }
 335          ; putStrLn ""
 336          }
 337      }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:332:40: error:
     Couldn't match type: [Char]
                     with: [a0] -> b
      Expected: String -> [a0] -> b
        Actual: [Char] -> [Char]
     In the second argument of (&), namely reverse
      In the first argument of ($), namely i * j & show & reverse
      In the expression:
        i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse
     Relevant bindings include
        rep :: b (bound at src/Template/Mark5b/State.hs:332:19)
    |
332 |             { let rep = i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse
    |                                        ^^^^^^^

src/Template/Mark5b/State.hs:332:68: error:
     Couldn't match type: [a0]
                     with: [Char] -> [Char]
      Expected: ([Char] -> [Char]) -> [a0]
        Actual: [a0] -> [a0]
     In the second argument of (&), namely take 3
      In the first argument of (&), namely (++ repeat ' ') & take 3
      In the second argument of ($), namely
        (++ repeat ' ') & take 3 & reverse
    |
332 |             { let rep = i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse
    |                                                                    ^^^^^^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint = let { (&) = flip ($); infixl 1 & } in do
 330      { flip mapM_ [1 .. 9] $ \ i -> do
 331          { flip mapM_ [1 .. 9] $ \ j -> do
 332              { let str = i * j & show & reverse $ (++ repeat ' ')
 333              ; let rep = str $ take 3
 334              ; putStr rep 
 335              }
 336          ; putStrLn ""
 337          }
 338      }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:332:40: error:
     Couldn't match type: [Char]
                     with: ([Char] -> [Char]) -> b
      Expected: String -> ([Char] -> [Char]) -> b
        Actual: [Char] -> [Char]
     In the second argument of (&), namely reverse
      In the first argument of ($), namely i * j & show & reverse
      In the expression: i * j & show & reverse $ (++ repeat ' ')
     Relevant bindings include
        str :: b (bound at src/Template/Mark5b/State.hs:332:19)
    |
332 |             { let str = i * j & show & reverse $ (++ repeat ' ')
    |                                        ^^^^^^^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  import Data.Function
  13  
  14  data TiState
  15      = TiState
  16      { control :: TiControl
  17      , output  :: TiOutput
  18      , stack   :: TiStack
  19      , dump    :: TiDump
  20      , heap    :: TiHeap
  21      , globals :: TiGlobals
  22      , stats   :: TiStats
  23      , ruleid  :: TiRuleId
  24      }
  25  
  26  type TiControl = [String]
  27  
  28  type TiOutput  = [Int]
  29  
  30  type TiStack   = Stack Addr
  31  
  32  type TiDump    = Stack Int
  33  initialDump :: TiDump
  34  initialDump = emptyStack
  35  
  36  type TiHeap    = Heap Node
  37  
  38  type TiGlobals = Assoc Name Addr
  39  
  40  data TiStats 
  41      = TiStats
  42      { totalSteps :: Int
  43      , scSteps    :: Int
  44      , primSteps  :: Int
  45      }
  46      deriving Show
  47  
  48  initialStats :: TiStats
  49  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  50  
  51  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  52  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  53  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  54  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  55  
  56  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  57  applyToStats f state = state { stats = f state.stats }
  58  
  59  type TiRuleId = Int
  60  
  61  setRuleId :: TiRuleId -> TiState -> TiState
  62  setRuleId r state = state { ruleid = r }
  63  
  64  tiFinal :: TiState -> Bool
  65  tiFinal state = isEmptyStack state.stack
  66  
  67  -- | Primitive
  68  
  69  type Primitive = TiState -> TiState
  70  
  71  primitives :: Assoc Name Primitive
  72  primitives = [ ("negate", primNeg)
  73               , ("+", primArith (+)), ("-", primArith (-))
  74               , ("*", primArith (+)), ("/", primArith div)
  75               , ("<", primComp (<)), ("<=", primComp (<=))
  76               , (">", primComp (>)), (">=", primComp (>=))
  77               , ("==", primComp (==)), ("/=", primComp (/=))
  78               , ("if", primIf)
  79               , ("casePair", primCasePair)
  80               , ("caseList", primCaseList)
  81               , ("abort", primAbort)
  82               , ("stop", primStop)
  83               , ("print", primPrint)
  84               ]
  85  
  86  primNeg :: TiState -> TiState
  87  primNeg state
  88      | length args < 1          = error "primNeg: wrong number of args"
  89      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  90          (stack2, dump2) -> setRuleId 9
  91                           $ state { stack = stack2, dump = dump2 }
  92      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  93                                 $ state { stack = stack1, heap = heap1 }
  94      where
  95          args      = take 1 $ getargs state.heap state.stack
  96          [argAddr] = args
  97          argNode   = hLookup state.heap argAddr
  98          NNum argValue = argNode
  99          (_, stack1) = pop state.stack
 100          (root, _)   = pop stack1
 101          heap1 = hUpdate state.heap root (NNum (negate argValue))
 102  
 103  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 104  primArith op = primDyadic op'
 105      where
 106          op' (NNum m) (NNum n) = NNum (m `op` n)
 107  
 108  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 109  primComp op = primDyadic op'
 110      where
 111          op' (NNum m) (NNum n)
 112              | m `op` n  = NData 1 []
 113              | otherwise = NData 0 []
 114  
 115  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 116  primDyadic op state 
 117      | length args < 2 = error "primDyadic: wrong number of args"
 118      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 119          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 120      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 121          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 122      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 123                                  $ state { stack = stack1, heap = heap1 }
 124      where
 125          args = take 2 $ getargs state.heap state.stack
 126          [arg1Addr, arg2Addr] = args
 127          [arg1Node, arg2Node] = map (hLookup state.heap) args
 128          stack1 = discard 2 state.stack
 129          (root, _) = pop stack1
 130          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 131  
 132  primConstr :: Tag -> Arity -> TiState -> TiState
 133  primConstr tag arity state
 134      | length args < arity = error "primConstr: wrong number of args"
 135      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 136      where
 137          args = take arity $ getargs state.heap state.stack
 138          stack1 = discard arity state.stack
 139          (root,_) = pop stack1
 140          heap1 = hUpdate state.heap root (NData tag args)
 141  
 142  primIf :: TiState -> TiState
 143  primIf state
 144      | length args < 3 = error "primIf: wrong number of args"
 145      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 146          (stack2, dump2) -> setRuleId 19
 147                           $ state { stack = stack2, dump = dump2 }
 148      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 149      where
 150          args = take 3 $ getargs state.heap state.stack
 151          [arg1Addr, arg2Addr, arg3Addr] = args
 152          arg1Node = hLookup state.heap arg1Addr
 153          stack1 = discard 3 state.stack 
 154          (root, _) = pop stack1
 155          result = case arg1Node of
 156              NData 0 [] -> arg3Addr
 157              _          -> arg2Addr
 158          heap1 = hUpdate state.heap root (NInd result)
 159  
 160  primCasePair :: TiState -> TiState
 161  primCasePair state
 162      | length args < 2 = error "primCasePair: wrong number of args"
 163      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 164          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 165      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 166      where
 167          args = take 2 $ getargs state.heap state.stack
 168          [arg1Addr, arg2Addr] = args
 169          arg1Node = hLookup state.heap arg1Addr
 170          stack1 = discard 2 state.stack
 171          (root, _) = pop stack1
 172          heap1 = case arg1Node of
 173              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 174                  where
 175                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 176  
 177  primCaseList :: TiState -> TiState
 178  primCaseList state
 179      | length args < 3 = error "primCaseList: wrong number of args"
 180      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 181          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 182      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 183      where
 184          args = take 3 $ getargs state.heap state.stack
 185          [arg1Addr, arg2Addr, arg3Addr] = args
 186          arg1Node = hLookup state.heap arg1Addr
 187          stack1 = discard 3 state.stack
 188          (root, _) = pop stack1
 189          heap1 = case arg1Node of
 190              NData tag cmpnts
 191                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 192                  | otherwise -> case cmpnts of
 193                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 194                          where
 195                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 196                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 197              _ -> error "not NData node"
 198  
 199  primAbort :: TiState -> TiState
 200  primAbort = error "Program abort!"
 201  
 202  primStop :: TiState -> TiState
 203  primStop state 
 204      | not (isEmptyStack state.dump) 
 205          = error "primStop: dump is not empty"
 206      | otherwise
 207          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 208  
 209  primPrint :: TiState -> TiState
 210  primPrint state
 211      | argsLen < 2 = error "primPrint: wrong number of args"
 212      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 213      | otherwise = case arg1Node of
 214          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 215                                            , stack = push arg2Addr (emptyStack' state.stack)
 216                                            }
 217          NData _ _ -> error "primPrint: not a number"
 218          _         -> case saveAndPush arg1Addr stack1 state.dump of
 219              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 220      where
 221          args = take 2 $ getargs state.heap state.stack
 222          argsLen = length args
 223          [arg1Addr, arg2Addr] = args
 224          arg1Node = hLookup state.heap arg1Addr
 225          NNum arg1Value = arg1Node
 226          stack1 = discard argsLen state.stack
 227  
 228  -- | Node
 229  
 230  data Node
 231      = NAp Addr Addr
 232      | NSupercomb Name [Name] CoreExpr
 233      | NNum Int
 234      | NInd Addr
 235      | NPrim Name Primitive
 236      | NData Tag [Addr]
 237  
 238  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 239               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 240               -> (Int -> a)                        -- ^ NInt
 241               -> (Addr -> a)                       -- ^ NInd
 242               -> (Name -> Primitive -> a)          -- ^ NPrim
 243               -> (Tag -> [Addr] -> a)              -- ^ NData
 244               -> Node -> a
 245  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 246      NAp a b                -> nap a b
 247      NSupercomb f args body -> nsupercomb f args body
 248      NNum n                 -> nnum n
 249      NInd a                 -> nind a
 250      NPrim name prim        -> nprim name prim
 251      NData tag contents     -> ndata tag contents
 252  
 253  isDataNode :: Node -> Bool
 254  isDataNode node = case node of
 255      NNum _    -> True
 256      NData _ _ -> True
 257      _         -> False
 258  
 259  doAdminTotalSteps :: TiState -> TiState
 260  doAdminTotalSteps = applyToStats incTotalSteps
 261  
 262  doAdminScSteps :: TiState -> TiState
 263  doAdminScSteps = applyToStats incScSteps
 264  
 265  doAdminPrimSteps :: TiState -> TiState
 266  doAdminPrimSteps = applyToStats incPrimSteps
 267  
 268  getargs :: TiHeap -> TiStack -> [Addr]
 269  getargs heap stack = case pop stack of
 270      (sc, stack1) -> map getarg stack1.stkItems
 271          where
 272              getarg addr = case hLookup heap addr of
 273                  NAp _ arg -> arg
 274                  _         -> error "getarg: not application node"
 275  
 276  --
 277  emptyStack' :: TiStack -> TiStack
 278  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 279  
 280  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 281  saveAndPush addr stack dump
 282      = (push addr stack, push stack.curDepth dump)
 283  
 284  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 285  restore stack dump
 286      | isEmptyStack dump = error "restore: dump is empty"
 287      | otherwise         = case pop dump of
 288          (sp, dump') 
 289              -> ( discard (stack.curDepth - sp) stack, dump' )
 290  
 291  --
 292  ruleTable :: [(TiRuleId, String)]
 293  ruleTable 
 294      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 295        , (2, "Rule (2.2): Perform a supercombinator reduction")
 296        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 297        , (4, "Rule (2.4): Update the indirection node to immediate node")
 298        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 299        , (6, "Rule (2.6): For operand evaluation of negation")
 300        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 301        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 302        , (9, "Rule (2.9): For operand evaluation of negation")
 303        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 304        , (11, "Rule (2.11): For `NPrim Stop`")
 305        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 306        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 307        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 308        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 309        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 310        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 311        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 312        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 313        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 314        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 315        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 316        ]
 317  
 318  {-
 319  kuku :: [[Int]]
 320  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 321  
 322  rjustify :: (Show a) => Int -> a -> String
 323  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 324  
 325  printKuku :: IO ()
 326  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 327  -}
 328  
 329  kukuPrint :: IO ()
 330  kukuPrint = flip mapM_ [1 .. 9] $ \ i -> do
 331                  { flip mapM_ [1 .. 9] $ \ j -> do
 332                      { let rep = i * j & show
 333                      ; putStrLn rep
 334                      }
 335          ; putStrLn ""
 336          }
 337      }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:337:5: error: parse error on input }
    |
337 |     }
    |     ^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  import Data.Function
  13  
  14  data TiState
  15      = TiState
  16      { control :: TiControl
  17      , output  :: TiOutput
  18      , stack   :: TiStack
  19      , dump    :: TiDump
  20      , heap    :: TiHeap
  21      , globals :: TiGlobals
  22      , stats   :: TiStats
  23      , ruleid  :: TiRuleId
  24      }
  25  
  26  type TiControl = [String]
  27  
  28  type TiOutput  = [Int]
  29  
  30  type TiStack   = Stack Addr
  31  
  32  type TiDump    = Stack Int
  33  initialDump :: TiDump
  34  initialDump = emptyStack
  35  
  36  type TiHeap    = Heap Node
  37  
  38  type TiGlobals = Assoc Name Addr
  39  
  40  data TiStats 
  41      = TiStats
  42      { totalSteps :: Int
  43      , scSteps    :: Int
  44      , primSteps  :: Int
  45      }
  46      deriving Show
  47  
  48  initialStats :: TiStats
  49  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  50  
  51  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  52  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  53  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  54  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  55  
  56  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  57  applyToStats f state = state { stats = f state.stats }
  58  
  59  type TiRuleId = Int
  60  
  61  setRuleId :: TiRuleId -> TiState -> TiState
  62  setRuleId r state = state { ruleid = r }
  63  
  64  tiFinal :: TiState -> Bool
  65  tiFinal state = isEmptyStack state.stack
  66  
  67  -- | Primitive
  68  
  69  type Primitive = TiState -> TiState
  70  
  71  primitives :: Assoc Name Primitive
  72  primitives = [ ("negate", primNeg)
  73               , ("+", primArith (+)), ("-", primArith (-))
  74               , ("*", primArith (+)), ("/", primArith div)
  75               , ("<", primComp (<)), ("<=", primComp (<=))
  76               , (">", primComp (>)), (">=", primComp (>=))
  77               , ("==", primComp (==)), ("/=", primComp (/=))
  78               , ("if", primIf)
  79               , ("casePair", primCasePair)
  80               , ("caseList", primCaseList)
  81               , ("abort", primAbort)
  82               , ("stop", primStop)
  83               , ("print", primPrint)
  84               ]
  85  
  86  primNeg :: TiState -> TiState
  87  primNeg state
  88      | length args < 1          = error "primNeg: wrong number of args"
  89      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  90          (stack2, dump2) -> setRuleId 9
  91                           $ state { stack = stack2, dump = dump2 }
  92      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  93                                 $ state { stack = stack1, heap = heap1 }
  94      where
  95          args      = take 1 $ getargs state.heap state.stack
  96          [argAddr] = args
  97          argNode   = hLookup state.heap argAddr
  98          NNum argValue = argNode
  99          (_, stack1) = pop state.stack
 100          (root, _)   = pop stack1
 101          heap1 = hUpdate state.heap root (NNum (negate argValue))
 102  
 103  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 104  primArith op = primDyadic op'
 105      where
 106          op' (NNum m) (NNum n) = NNum (m `op` n)
 107  
 108  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 109  primComp op = primDyadic op'
 110      where
 111          op' (NNum m) (NNum n)
 112              | m `op` n  = NData 1 []
 113              | otherwise = NData 0 []
 114  
 115  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 116  primDyadic op state 
 117      | length args < 2 = error "primDyadic: wrong number of args"
 118      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 119          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 120      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 121          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 122      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 123                                  $ state { stack = stack1, heap = heap1 }
 124      where
 125          args = take 2 $ getargs state.heap state.stack
 126          [arg1Addr, arg2Addr] = args
 127          [arg1Node, arg2Node] = map (hLookup state.heap) args
 128          stack1 = discard 2 state.stack
 129          (root, _) = pop stack1
 130          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 131  
 132  primConstr :: Tag -> Arity -> TiState -> TiState
 133  primConstr tag arity state
 134      | length args < arity = error "primConstr: wrong number of args"
 135      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 136      where
 137          args = take arity $ getargs state.heap state.stack
 138          stack1 = discard arity state.stack
 139          (root,_) = pop stack1
 140          heap1 = hUpdate state.heap root (NData tag args)
 141  
 142  primIf :: TiState -> TiState
 143  primIf state
 144      | length args < 3 = error "primIf: wrong number of args"
 145      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 146          (stack2, dump2) -> setRuleId 19
 147                           $ state { stack = stack2, dump = dump2 }
 148      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 149      where
 150          args = take 3 $ getargs state.heap state.stack
 151          [arg1Addr, arg2Addr, arg3Addr] = args
 152          arg1Node = hLookup state.heap arg1Addr
 153          stack1 = discard 3 state.stack 
 154          (root, _) = pop stack1
 155          result = case arg1Node of
 156              NData 0 [] -> arg3Addr
 157              _          -> arg2Addr
 158          heap1 = hUpdate state.heap root (NInd result)
 159  
 160  primCasePair :: TiState -> TiState
 161  primCasePair state
 162      | length args < 2 = error "primCasePair: wrong number of args"
 163      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 164          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 165      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 166      where
 167          args = take 2 $ getargs state.heap state.stack
 168          [arg1Addr, arg2Addr] = args
 169          arg1Node = hLookup state.heap arg1Addr
 170          stack1 = discard 2 state.stack
 171          (root, _) = pop stack1
 172          heap1 = case arg1Node of
 173              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 174                  where
 175                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 176  
 177  primCaseList :: TiState -> TiState
 178  primCaseList state
 179      | length args < 3 = error "primCaseList: wrong number of args"
 180      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 181          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 182      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 183      where
 184          args = take 3 $ getargs state.heap state.stack
 185          [arg1Addr, arg2Addr, arg3Addr] = args
 186          arg1Node = hLookup state.heap arg1Addr
 187          stack1 = discard 3 state.stack
 188          (root, _) = pop stack1
 189          heap1 = case arg1Node of
 190              NData tag cmpnts
 191                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 192                  | otherwise -> case cmpnts of
 193                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 194                          where
 195                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 196                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 197              _ -> error "not NData node"
 198  
 199  primAbort :: TiState -> TiState
 200  primAbort = error "Program abort!"
 201  
 202  primStop :: TiState -> TiState
 203  primStop state 
 204      | not (isEmptyStack state.dump) 
 205          = error "primStop: dump is not empty"
 206      | otherwise
 207          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 208  
 209  primPrint :: TiState -> TiState
 210  primPrint state
 211      | argsLen < 2 = error "primPrint: wrong number of args"
 212      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 213      | otherwise = case arg1Node of
 214          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 215                                            , stack = push arg2Addr (emptyStack' state.stack)
 216                                            }
 217          NData _ _ -> error "primPrint: not a number"
 218          _         -> case saveAndPush arg1Addr stack1 state.dump of
 219              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 220      where
 221          args = take 2 $ getargs state.heap state.stack
 222          argsLen = length args
 223          [arg1Addr, arg2Addr] = args
 224          arg1Node = hLookup state.heap arg1Addr
 225          NNum arg1Value = arg1Node
 226          stack1 = discard argsLen state.stack
 227  
 228  -- | Node
 229  
 230  data Node
 231      = NAp Addr Addr
 232      | NSupercomb Name [Name] CoreExpr
 233      | NNum Int
 234      | NInd Addr
 235      | NPrim Name Primitive
 236      | NData Tag [Addr]
 237  
 238  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 239               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 240               -> (Int -> a)                        -- ^ NInt
 241               -> (Addr -> a)                       -- ^ NInd
 242               -> (Name -> Primitive -> a)          -- ^ NPrim
 243               -> (Tag -> [Addr] -> a)              -- ^ NData
 244               -> Node -> a
 245  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 246      NAp a b                -> nap a b
 247      NSupercomb f args body -> nsupercomb f args body
 248      NNum n                 -> nnum n
 249      NInd a                 -> nind a
 250      NPrim name prim        -> nprim name prim
 251      NData tag contents     -> ndata tag contents
 252  
 253  isDataNode :: Node -> Bool
 254  isDataNode node = case node of
 255      NNum _    -> True
 256      NData _ _ -> True
 257      _         -> False
 258  
 259  doAdminTotalSteps :: TiState -> TiState
 260  doAdminTotalSteps = applyToStats incTotalSteps
 261  
 262  doAdminScSteps :: TiState -> TiState
 263  doAdminScSteps = applyToStats incScSteps
 264  
 265  doAdminPrimSteps :: TiState -> TiState
 266  doAdminPrimSteps = applyToStats incPrimSteps
 267  
 268  getargs :: TiHeap -> TiStack -> [Addr]
 269  getargs heap stack = case pop stack of
 270      (sc, stack1) -> map getarg stack1.stkItems
 271          where
 272              getarg addr = case hLookup heap addr of
 273                  NAp _ arg -> arg
 274                  _         -> error "getarg: not application node"
 275  
 276  --
 277  emptyStack' :: TiStack -> TiStack
 278  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 279  
 280  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 281  saveAndPush addr stack dump
 282      = (push addr stack, push stack.curDepth dump)
 283  
 284  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 285  restore stack dump
 286      | isEmptyStack dump = error "restore: dump is empty"
 287      | otherwise         = case pop dump of
 288          (sp, dump') 
 289              -> ( discard (stack.curDepth - sp) stack, dump' )
 290  
 291  --
 292  ruleTable :: [(TiRuleId, String)]
 293  ruleTable 
 294      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 295        , (2, "Rule (2.2): Perform a supercombinator reduction")
 296        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 297        , (4, "Rule (2.4): Update the indirection node to immediate node")
 298        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 299        , (6, "Rule (2.6): For operand evaluation of negation")
 300        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 301        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 302        , (9, "Rule (2.9): For operand evaluation of negation")
 303        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 304        , (11, "Rule (2.11): For `NPrim Stop`")
 305        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 306        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 307        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 308        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 309        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 310        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 311        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 312        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 313        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 314        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 315        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 316        ]
 317  
 318  {-
 319  kuku :: [[Int]]
 320  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 321  
 322  rjustify :: (Show a) => Int -> a -> String
 323  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 324  
 325  printKuku :: IO ()
 326  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 327  -}
 328  
 329  kukuPrint :: IO ()
 330  kukuPrint = flip mapM_ [1 .. 9] $ \ i -> do
 331                  { flip mapM_ [1 .. 9] $ \ j -> do
 332                      { let rep = i * j & show
 333                      ; putStrLn rep
 334                      }
 335                  ; putStrLn ""
 336                  }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  import Data.Function
  13  import Control.Monad
  14  
  15  data TiState
  16      = TiState
  17      { control :: TiControl
  18      , output  :: TiOutput
  19      , stack   :: TiStack
  20      , dump    :: TiDump
  21      , heap    :: TiHeap
  22      , globals :: TiGlobals
  23      , stats   :: TiStats
  24      , ruleid  :: TiRuleId
  25      }
  26  
  27  type TiControl = [String]
  28  
  29  type TiOutput  = [Int]
  30  
  31  type TiStack   = Stack Addr
  32  
  33  type TiDump    = Stack Int
  34  initialDump :: TiDump
  35  initialDump = emptyStack
  36  
  37  type TiHeap    = Heap Node
  38  
  39  type TiGlobals = Assoc Name Addr
  40  
  41  data TiStats 
  42      = TiStats
  43      { totalSteps :: Int
  44      , scSteps    :: Int
  45      , primSteps  :: Int
  46      }
  47      deriving Show
  48  
  49  initialStats :: TiStats
  50  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  51  
  52  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  53  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  54  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  55  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  56  
  57  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  58  applyToStats f state = state { stats = f state.stats }
  59  
  60  type TiRuleId = Int
  61  
  62  setRuleId :: TiRuleId -> TiState -> TiState
  63  setRuleId r state = state { ruleid = r }
  64  
  65  tiFinal :: TiState -> Bool
  66  tiFinal state = isEmptyStack state.stack
  67  
  68  -- | Primitive
  69  
  70  type Primitive = TiState -> TiState
  71  
  72  primitives :: Assoc Name Primitive
  73  primitives = [ ("negate", primNeg)
  74               , ("+", primArith (+)), ("-", primArith (-))
  75               , ("*", primArith (+)), ("/", primArith div)
  76               , ("<", primComp (<)), ("<=", primComp (<=))
  77               , (">", primComp (>)), (">=", primComp (>=))
  78               , ("==", primComp (==)), ("/=", primComp (/=))
  79               , ("if", primIf)
  80               , ("casePair", primCasePair)
  81               , ("caseList", primCaseList)
  82               , ("abort", primAbort)
  83               , ("stop", primStop)
  84               , ("print", primPrint)
  85               ]
  86  
  87  primNeg :: TiState -> TiState
  88  primNeg state
  89      | length args < 1          = error "primNeg: wrong number of args"
  90      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  91          (stack2, dump2) -> setRuleId 9
  92                           $ state { stack = stack2, dump = dump2 }
  93      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  94                                 $ state { stack = stack1, heap = heap1 }
  95      where
  96          args      = take 1 $ getargs state.heap state.stack
  97          [argAddr] = args
  98          argNode   = hLookup state.heap argAddr
  99          NNum argValue = argNode
 100          (_, stack1) = pop state.stack
 101          (root, _)   = pop stack1
 102          heap1 = hUpdate state.heap root (NNum (negate argValue))
 103  
 104  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 105  primArith op = primDyadic op'
 106      where
 107          op' (NNum m) (NNum n) = NNum (m `op` n)
 108  
 109  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 110  primComp op = primDyadic op'
 111      where
 112          op' (NNum m) (NNum n)
 113              | m `op` n  = NData 1 []
 114              | otherwise = NData 0 []
 115  
 116  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 117  primDyadic op state 
 118      | length args < 2 = error "primDyadic: wrong number of args"
 119      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 120          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 121      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 122          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 123      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 124                                  $ state { stack = stack1, heap = heap1 }
 125      where
 126          args = take 2 $ getargs state.heap state.stack
 127          [arg1Addr, arg2Addr] = args
 128          [arg1Node, arg2Node] = map (hLookup state.heap) args
 129          stack1 = discard 2 state.stack
 130          (root, _) = pop stack1
 131          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 132  
 133  primConstr :: Tag -> Arity -> TiState -> TiState
 134  primConstr tag arity state
 135      | length args < arity = error "primConstr: wrong number of args"
 136      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 137      where
 138          args = take arity $ getargs state.heap state.stack
 139          stack1 = discard arity state.stack
 140          (root,_) = pop stack1
 141          heap1 = hUpdate state.heap root (NData tag args)
 142  
 143  primIf :: TiState -> TiState
 144  primIf state
 145      | length args < 3 = error "primIf: wrong number of args"
 146      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 147          (stack2, dump2) -> setRuleId 19
 148                           $ state { stack = stack2, dump = dump2 }
 149      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 150      where
 151          args = take 3 $ getargs state.heap state.stack
 152          [arg1Addr, arg2Addr, arg3Addr] = args
 153          arg1Node = hLookup state.heap arg1Addr
 154          stack1 = discard 3 state.stack 
 155          (root, _) = pop stack1
 156          result = case arg1Node of
 157              NData 0 [] -> arg3Addr
 158              _          -> arg2Addr
 159          heap1 = hUpdate state.heap root (NInd result)
 160  
 161  primCasePair :: TiState -> TiState
 162  primCasePair state
 163      | length args < 2 = error "primCasePair: wrong number of args"
 164      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 165          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 166      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 167      where
 168          args = take 2 $ getargs state.heap state.stack
 169          [arg1Addr, arg2Addr] = args
 170          arg1Node = hLookup state.heap arg1Addr
 171          stack1 = discard 2 state.stack
 172          (root, _) = pop stack1
 173          heap1 = case arg1Node of
 174              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 175                  where
 176                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 177  
 178  primCaseList :: TiState -> TiState
 179  primCaseList state
 180      | length args < 3 = error "primCaseList: wrong number of args"
 181      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 182          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 183      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 184      where
 185          args = take 3 $ getargs state.heap state.stack
 186          [arg1Addr, arg2Addr, arg3Addr] = args
 187          arg1Node = hLookup state.heap arg1Addr
 188          stack1 = discard 3 state.stack
 189          (root, _) = pop stack1
 190          heap1 = case arg1Node of
 191              NData tag cmpnts
 192                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 193                  | otherwise -> case cmpnts of
 194                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 195                          where
 196                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 197                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 198              _ -> error "not NData node"
 199  
 200  primAbort :: TiState -> TiState
 201  primAbort = error "Program abort!"
 202  
 203  primStop :: TiState -> TiState
 204  primStop state 
 205      | not (isEmptyStack state.dump) 
 206          = error "primStop: dump is not empty"
 207      | otherwise
 208          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 209  
 210  primPrint :: TiState -> TiState
 211  primPrint state
 212      | argsLen < 2 = error "primPrint: wrong number of args"
 213      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 214      | otherwise = case arg1Node of
 215          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 216                                            , stack = push arg2Addr (emptyStack' state.stack)
 217                                            }
 218          NData _ _ -> error "primPrint: not a number"
 219          _         -> case saveAndPush arg1Addr stack1 state.dump of
 220              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 221      where
 222          args = take 2 $ getargs state.heap state.stack
 223          argsLen = length args
 224          [arg1Addr, arg2Addr] = args
 225          arg1Node = hLookup state.heap arg1Addr
 226          NNum arg1Value = arg1Node
 227          stack1 = discard argsLen state.stack
 228  
 229  -- | Node
 230  
 231  data Node
 232      = NAp Addr Addr
 233      | NSupercomb Name [Name] CoreExpr
 234      | NNum Int
 235      | NInd Addr
 236      | NPrim Name Primitive
 237      | NData Tag [Addr]
 238  
 239  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 240               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 241               -> (Int -> a)                        -- ^ NInt
 242               -> (Addr -> a)                       -- ^ NInd
 243               -> (Name -> Primitive -> a)          -- ^ NPrim
 244               -> (Tag -> [Addr] -> a)              -- ^ NData
 245               -> Node -> a
 246  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 247      NAp a b                -> nap a b
 248      NSupercomb f args body -> nsupercomb f args body
 249      NNum n                 -> nnum n
 250      NInd a                 -> nind a
 251      NPrim name prim        -> nprim name prim
 252      NData tag contents     -> ndata tag contents
 253  
 254  isDataNode :: Node -> Bool
 255  isDataNode node = case node of
 256      NNum _    -> True
 257      NData _ _ -> True
 258      _         -> False
 259  
 260  doAdminTotalSteps :: TiState -> TiState
 261  doAdminTotalSteps = applyToStats incTotalSteps
 262  
 263  doAdminScSteps :: TiState -> TiState
 264  doAdminScSteps = applyToStats incScSteps
 265  
 266  doAdminPrimSteps :: TiState -> TiState
 267  doAdminPrimSteps = applyToStats incPrimSteps
 268  
 269  getargs :: TiHeap -> TiStack -> [Addr]
 270  getargs heap stack = case pop stack of
 271      (sc, stack1) -> map getarg stack1.stkItems
 272          where
 273              getarg addr = case hLookup heap addr of
 274                  NAp _ arg -> arg
 275                  _         -> error "getarg: not application node"
 276  
 277  --
 278  emptyStack' :: TiStack -> TiStack
 279  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 280  
 281  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 282  saveAndPush addr stack dump
 283      = (push addr stack, push stack.curDepth dump)
 284  
 285  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 286  restore stack dump
 287      | isEmptyStack dump = error "restore: dump is empty"
 288      | otherwise         = case pop dump of
 289          (sp, dump') 
 290              -> ( discard (stack.curDepth - sp) stack, dump' )
 291  
 292  --
 293  ruleTable :: [(TiRuleId, String)]
 294  ruleTable 
 295      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 296        , (2, "Rule (2.2): Perform a supercombinator reduction")
 297        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 298        , (4, "Rule (2.4): Update the indirection node to immediate node")
 299        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 300        , (6, "Rule (2.6): For operand evaluation of negation")
 301        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 302        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 303        , (9, "Rule (2.9): For operand evaluation of negation")
 304        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 305        , (11, "Rule (2.11): For `NPrim Stop`")
 306        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 307        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 308        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 309        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 310        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 311        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 312        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 313        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 314        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 315        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 316        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 317        ]
 318  
 319  {-
 320  kuku :: [[Int]]
 321  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 322  
 323  rjustify :: (Show a) => Int -> a -> String
 324  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 325  
 326  printKuku :: IO ()
 327  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 328  -}
 329  
 330  kukuPrint :: IO ()
 331  kukuPrint = forM_ [1 .. 9] $ \ i -> do
 332                  { forM_ [1 .. 9] $ \ j -> do
 333                      { let rep = i * j & show & reverse & (++ repeat ' ') & take 3 & reverse
 334                      ; putStr rep
 335                      }
 336                  ; putStrLn ""
 337                  }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> import Template.Mark5b.State
>>> kukuPrint
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.1 (lib) (file src/Template/Mark5mgc/Machine.hs changed)
Preprocessing library for ifl-tut-0.2.9.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 28] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 28] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 28] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 28] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 28] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 28] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 28] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 28] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 28] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[10 of 28] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[11 of 28] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[12 of 28] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[13 of 28] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[14 of 28] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[15 of 28] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[16 of 28] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[17 of 28] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[18 of 28] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[19 of 28] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[20 of 28] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[21 of 28] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[22 of 28] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 28] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[24 of 28] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[25 of 28] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[26 of 28] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[27 of 28] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[28 of 28] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )

src/Template/Mark5mgc/Machine.hs:378:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
    |
378 | scanHeap :: TiHeap -> TiHeap
    | ^
Failed, 27 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.1 (lib) (file src/Template/Mark5mgc/Machine.hs changed)
Preprocessing library for ifl-tut-0.2.9.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 28] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 28] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 28] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 28] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 28] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 28] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 28] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 28] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 28] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[10 of 28] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[11 of 28] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[12 of 28] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[13 of 28] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[14 of 28] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[15 of 28] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[16 of 28] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[17 of 28] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[18 of 28] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[19 of 28] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[20 of 28] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[21 of 28] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[22 of 28] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 28] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[24 of 28] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[25 of 28] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[26 of 28] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[27 of 28] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[28 of 28] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )

src/Template/Mark5mgc/Machine.hs:373:57: error:
     Data constructor not in scope: Marked :: Node -> Node
     Perhaps you meant NMarked (imported from Template.Mark5mgc.State)
    |
373 |                 (heap', as')    -> (hUpdate heap' addr (Marked (NData tag as')), addr))
    |                                                         ^^^^^^
Failed, 27 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5mgc.Machine
   6      where
   7  
   8  import Data.Bool
   9  import Data.Char
  10  import Data.List
  11  import Data.List.Extra
  12  
  13  import Language
  14  import Heap
  15  import Stack
  16  import Iseq
  17  import Utils
  18  
  19  import Template.Mark5mgc.State
  20  import Template.Mark5mgc.PPrint
  21  
  22  import Debug.Trace qualified as Deb
  23  
  24  debug :: Bool
  25  debug = True
  26  
  27  trace :: String -> a -> a
  28  trace | debug     = Deb.trace
  29        | otherwise = const id 
  30  
  31  traceShow :: Show a => a -> b -> b
  32  traceShow | debug     = Deb.traceShow
  33            | otherwise = const id
  34  
  35  {- * Mark 5 : Structured data -}
  36  {- | Structure of the implementations -}
  37  
  38  drive :: ([String] -> [String]) -> (String -> String)
  39  drive f = unlines . f . ("" :) . lines
  40  
  41  run :: String -> ([String] -> [String])
  42  run prog inputs
  43      = showResults 
  44      $ eval
  45      $ setControl inputs
  46      $ compile 
  47      $ parse prog
  48  
  49  setControl :: [String] -> TiState -> TiState
  50  setControl ctrl state = state { control = ctrl }
  51  
  52  {- | Compiler -}
  53  
  54  compile :: CoreProgram -> TiState
  55  compile prog = TiState
  56      { control = []
  57      , output  = []
  58      , stack   = initialStack1
  59      , dump    = initialDump
  60      , heap    = initialHeap1
  61      , globals = initialGlobals
  62      , stats   = initialStats
  63      , ruleid  = 0
  64      }
  65      where
  66          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
  67          (initialHeap, initialGlobals) = buildInitialHeap scDefs
  68          initialStack = singletonStack addressOfMain
  69          initialStack1 = singletonStack addr
  70          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
  71          addressOfPrint = aLookup initialGlobals "printList" (error "printList is not defined")
  72          (initialHeap1, addr) = hAlloc initialHeap (NAp addressOfPrint addressOfMain)
  73  
  74  extraPreludeDefs :: CoreProgram
  75  extraPreludeDefs = 
  76      [ ("False", [], EConstr 0 0)
  77      , ("True" , [], EConstr 1 0)
  78      , ("not", ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  79                                (EVar "False"))
  80                           (EVar "True"))
  81      , ("and", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  82                                     (EVar "y"))
  83                                (EVar "False"))
  84      , ("or",  ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  85                                     (EVar "True"))
  86                                (EVar "y"))
  87      , ("xor", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  88                                     (EAp (EVar "not") (EVar "y")))
  89                                (EVar "y"))
  90      , ("MkPair", [], EConstr 0 2)
  91      , ("fst", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  92                           (EVar "K"))
  93      , ("snd", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  94                           (EVar "K1"))
  95      , ("Nil", [], EConstr 0 0)
  96      , ("Cons", [], EConstr 1 2)
  97      , ("head", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
  98                                  (EVar "abort"))
  99                             (EVar "K"))
 100      , ("tail", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 101                                  (EVar "abort"))
 102                             (EVar "K1"))
 103      , ("printList", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 104                                       (EVar "stop"))
 105                                  (EVar "printCons"))
 106      , ("printCons", ["h", "t"], EAp (EAp (EVar "print") (EVar "h"))
 107                                      (EAp (EVar "printList") (EVar "t")))
 108      ]
 109  
 110  defaultHeapSize :: Int
 111  defaultHeapSize = 1024
 112  
 113  defaultThreshold :: Int
 114  defaultThreshold = 64
 115  
 116  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 117  buildInitialHeap scDefs = (heap2, scAddrs ++ primAddrs)
 118      where
 119          (heap1, scAddrs)   = let { ?sz = defaultHeapSize; ?th = defaultThreshold }
 120                               in mapAccumL allocateSc hInitial scDefs
 121          (heap2, primAddrs) = mapAccumL allocatePrim heap1 primitives
 122  
 123  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 124  allocateSc heap scDefn = case scDefn of
 125      (name, args, body) -> (heap', (name, addr))
 126          where
 127              (heap', addr) = hAlloc heap (NSupercomb name args body)
 128  
 129  allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
 130  allocatePrim heap (name, prim) = (heap1, (name, addr))
 131      where
 132          (heap1, addr) = hAlloc heap (NPrim name prim)
 133  
 134  {- | Evaluator -}
 135  
 136  eval :: TiState -> [TiState]
 137  eval state = state : rests
 138      where
 139          rests | tiFinal state = []
 140                | otherwise      = eval $ doAdmin $ doAdminTotalSteps $ step state
 141  
 142  doAdmin :: TiState -> TiState
 143  doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
 144  
 145  step :: TiState -> TiState
 146  step state = case map toLower $ head state.control of
 147      ""                -> state' { control = tail state.control }
 148      "c"               -> state' { control = repeat "" }
 149      s | all isDigit s -> state' { control = replicate (pred $ read s) "" ++ tail state.control }
 150        | otherwise     -> state' { control = tail state.control }
 151    where
 152          state' = dispatchNode 
 153                      apStep
 154                      scStep
 155                      numStep
 156                      indStep
 157                      primStep
 158                      dataStep
 159                      (error "step: NMarked node")
 160                      (hLookup state.heap (fst (pop state.stack)))
 161                    $ state
 162  
 163  numStep :: Int -> TiState -> TiState
 164  numStep n state 
 165      | isEmptyStack state.dump = error "numStep: Number applied as a function"
 166      | otherwise = case restore state.stack state.dump of
 167          (stack1, dump1) -> setRuleId 7 $ state { stack = stack1, dump = dump1 }
 168  
 169  apStep :: Addr -> Addr -> TiState -> TiState
 170  apStep a1 a2 state = case hLookup state.heap a2 of
 171      NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
 172      _       -> setRuleId 1 $ state { stack = push a1 state.stack }
 173      where
 174          (a,_) = pop state.stack
 175  
 176  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 177  scStep name args body state
 178      | state.stack.curDepth < succ argsLen
 179          = error "scStep: too few arguments given"
 180      | otherwise
 181          = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
 182      where
 183          argsLen  = length args
 184          stack1   = discard argsLen state.stack
 185          (root,_) = pop stack1
 186          heap1    = instantiateAndUpdate body root state.heap (bindings ++ state.globals)
 187          bindings = zip args (getargs state.heap state.stack)
 188  
 189  indStep :: Addr -> TiState -> TiState
 190  indStep addr state = setRuleId 4 $ state { stack = push addr (discard 1 state.stack) }
 191  
 192  primStep :: Name -> Primitive -> TiState -> TiState
 193  primStep name prim = prim
 194  
 195  dataStep :: Tag -> [Addr] -> TiState -> TiState
 196  dataStep tag contents state = state { stack = stack1, dump = dump1 }
 197      where
 198          (stack1, dump1) = restore state.stack state.dump
 199  
 200  {- | Instantiation -}
 201  
 202  instantiate :: CoreExpr
 203              -> TiHeap
 204              -> Assoc Name Addr
 205              -> (TiHeap, Addr)
 206  instantiate expr heap env = dispatchCoreExpr
 207      (instantiateVar heap env)
 208      (instantiateNum heap env)
 209      (instantiateConstr heap env)
 210      (instantiateAp heap env)
 211      (instantiateLet heap env)
 212      (instantiateCase heap env)
 213      (instantiateLam heap env)
 214      expr
 215  
 216  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 217  instantiateVar heap env name
 218      = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 219  
 220  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 221  instantiateNum heap env num = hAlloc heap (NNum num)
 222  
 223  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 224  instantiateConstr heap env tag arity = hAlloc heap (NPrim "Constr" (primConstr tag arity))
 225  
 226  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 227  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 228      where
 229          (heap1, a1) = instantiate a heap  env
 230          (heap2, a2) = instantiate b heap1 env
 231  
 232  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 233  instantiateLet heap env isrec defs body = instantiate body heap' env'
 234      where
 235          (heap', extraBindings) = mapAccumL instantiateRhs heap defs
 236          env' = extraBindings ++ env
 237          rhsEnv | isrec     = env'
 238                 | otherwise = env
 239          instantiateRhs heap (name, rhs)
 240              = (heap1, (name, addr))
 241              where
 242                  (heap1, addr) = instantiate rhs heap rhsEnv
 243  
 244  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 245  instantiateCase heap env expr alters = error "Cannot instatiate case"
 246  
 247  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 248  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 249  
 250  instantiateAndUpdate :: CoreExpr
 251                       -> Addr
 252                       -> TiHeap
 253                       -> Assoc Name Addr
 254                       -> TiHeap
 255  instantiateAndUpdate expr updAddr heap env = dispatchCoreExpr
 256      (instUpdEVar updAddr heap env)
 257      (instUpdENum updAddr heap env)
 258      (instUpdEConstr updAddr heap env)
 259      (instUpdEAp updAddr heap env)
 260      (instUpdELet updAddr heap env)
 261      (instUpdECase updAddr heap env)
 262      (instUpdELam updAddr heap env)
 263      expr
 264  
 265  instUpdEVar :: Addr
 266              -> TiHeap
 267              -> Assoc Name Addr
 268              -> Name
 269              -> TiHeap
 270  instUpdEVar updAddr heap env v = hUpdate heap updAddr (NInd varAddr)
 271      where
 272          varAddr = aLookup env v (error ("undefined name " ++ show v))
 273  
 274  instUpdENum :: Addr
 275              -> TiHeap
 276              -> Assoc Name Addr
 277              -> Int
 278              -> TiHeap
 279  instUpdENum updAddr heap env n = hUpdate heap updAddr (NNum n)
 280  
 281  instUpdEConstr :: Addr
 282                 -> TiHeap
 283                 -> Assoc Name Addr
 284                 -> Tag
 285                 -> Arity
 286                 -> TiHeap
 287  instUpdEConstr updAddr heap env tag arity
 288      = hUpdate heap updAddr (NPrim "Constr" (primConstr tag arity))
 289  
 290  instUpdEAp :: Addr
 291             -> TiHeap
 292             -> Assoc Name Addr
 293             -> CoreExpr
 294             -> CoreExpr
 295             -> TiHeap
 296  instUpdEAp updAddr heap env e1 e2 = hUpdate heap2 updAddr (NAp a1 a2)
 297      where
 298          (heap1, a1) = instantiate e1 heap  env
 299          (heap2, a2) = instantiate e2 heap1 env
 300  
 301  instUpdELet :: Addr
 302              -> TiHeap
 303              -> Assoc Name Addr
 304              -> IsRec
 305              -> Assoc Name CoreExpr
 306              -> CoreExpr
 307              -> TiHeap
 308  instUpdELet updAddr heap env isrec defs body = instantiateAndUpdate body updAddr heap1 env1
 309      where
 310          (heap1, extraBindings) = mapAccumL instantiateRhs heap defs
 311          env1 = extraBindings ++ env
 312          rhsEnv | isrec     = env1
 313                 | otherwise = env
 314          instantiateRhs heap (name, rhs) = (heap1, (name, addr))
 315              where
 316                  (heap1, addr) = instantiate rhs heap rhsEnv
 317  
 318  instUpdECase :: Addr
 319               -> TiHeap
 320               -> Assoc Name Addr
 321               -> CoreExpr
 322               -> [CoreAlter]
 323               -> TiHeap
 324  instUpdECase updAddr heap env expr alts = error "not implemented"
 325  
 326  instUpdELam :: Addr
 327              -> TiHeap
 328              -> Assoc Name Addr
 329              -> [Name]
 330              -> CoreExpr
 331              -> TiHeap
 332  instUpdELam updAddr heap env vars body = error "not implemented"
 333  
 334  test :: String -> IO ()
 335  test = interact . drive . run 
 336  
 337  -- Gabage Collector (Mark-scan)
 338  
 339  gc :: TiState -> TiState
 340  gc state = state { heap = scanHeap $ fst
 341                          $ mapAccumL markFrom state.heap
 342                          $ findRoots state 
 343                   , stats = incGcCount state.stats
 344                   }
 345  
 346  findStackRoots :: TiStack -> [Addr]
 347  findStackRoots stack = stack.stkItems
 348  
 349  findDumpRoots :: TiDump -> [Addr]
 350  findDumpRoots dump = []
 351  
 352  findGlobalRoots :: TiGlobals -> [Addr]
 353  findGlobalRoots globals = aRange globals
 354  
 355  findRoots :: TiState -> [Addr]
 356  findRoots state = concat
 357      [ findStackRoots state.stack
 358      , findDumpRoots state.dump
 359      , findGlobalRoots state.globals
 360      ]
 361  
 362  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
 363  markFrom heap addr = case hLookup heap addr of
 364      node -> dispatchNode 
 365              (\ addr1 addr2 -> case markFrom heap addr1 of
 366                  (heap1, addr1') -> case markFrom heap1 addr2 of
 367                      (heap2, addr2')  -> (hUpdate heap2 addr (NMarked (NAp addr1' addr2')), addr))
 368              (\ _ _ _       -> (hUpdate heap addr (NMarked node), addr)) -- NSupercomb
 369              (\ _           -> (hUpdate heap addr (NMarked node), addr)) -- NNum
 370              (\ addr1       -> markFrom heap addr1)                      -- NInd
 371              (\ _ _         -> (hUpdate heap addr (NMarked node), addr)) -- NPrim
 372              (\ tag as      -> case mapAccumL markFrom heap as of
 373                  (heap', as')    -> (hUpdate heap' addr (NMarked (NData tag as')), addr))
 374                                                                          -- NData
 375              (\ _           -> (heap, addr))                             -- NMarked
 376              node
 377  
 378  scanHeap :: TiHeap -> TiHeap
 379  scanHeap heap =foldl phi heap heap.assocs
 380      where
 381          phi h (a, node) = case node of
 382              NMarked node1 -> hUpdate h a node1
 383              _             -> hFree h a
[28 of 28] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
Ok, 28 modules loaded.
>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Configuring library for ifl-tut-0.2.9.3..
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (ephemeral targets)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[21 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[25 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[26 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[27 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[28 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[29 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[30 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[31 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - extra-1.7.10 (lib) (requires download & build)
 - ifl-tut-0.2.9.3 (lib) (first run)
Downloading  extra-1.7.10
Downloaded   extra-1.7.10
Starting     extra-1.7.10 (lib)
Building     extra-1.7.10 (lib)
Installing   extra-1.7.10 (lib)
Completed    extra-1.7.10 (lib)
Configuring library for ifl-tut-0.2.9.3..
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )

src/Heap.hs:28:1: error:
    The type signature for hNull lacks an accompanying binding
   |
28 | hNull      :: Addr -- Null pointer
   | ^^^^^
Failed, 7 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Heap 
   6      where
   7  
   8  import Utils
   9  
  10  type Addr = Int
  11  
  12  {- | 
  13  -}
  14  data Heap a = Heap
  15      { maxAllocs :: Int
  16      , curAllocs :: Int
  17      , threshold :: Int
  18      , frees     :: [Addr]
  19      , assocs    :: Assoc Addr a
  20      }
  21  
  22  hInitial   :: (?sz :: Int, ?th :: Int) => Heap a 
  23  hAlloc     :: Heap a -> a -> (Heap a, Addr)
  24  hUpdate    :: Heap a -> Addr -> a -> Heap a
  25  hFree      :: Heap a -> Addr -> Heap a
  26  hLookup    :: Heap a -> Addr -> a
  27  hAddresses :: Heap a -> [Addr]
  28  hNull      :: Addr -- Null pointer
  29  
  30  hInitial = Heap 
  31      { maxAllocs = 0
  32      , curAllocs = 0
  33      , threshold = ?th
  34      , frees     = [1 .. ?sz]
  35      , assocs    = []
  36      }
  37  
  38  hAlloc heap node = case heap.frees of
  39      []   -> error "hAlloc: no space"
  40      a:rs -> (heap { maxAllocs = succ heap.maxAllocs
  41                    , curAllocs = succ heap.curAllocs
  42                    , frees     = rs
  43                    , assocs    = (a, node) : heap.assocs
  44                    }, a)
  45  
  46  hUpdate heap addr node = heap
  47      { assocs = case break ((addr ==) . fst) heap.assocs of
  48            (as, _:bs) -> (addr, node) : (as ++ bs)
  49            _          -> error "hUpdate: no entry"
  50      }
  51  
  52  hFree heap addr = heap
  53      { curAllocs = pred heap.curAllocs
  54      , frees     = addr : heap.frees
  55      , assocs    = case break ((addr ==) . fst) heap.assocs of
  56          (as,_:bs) -> as ++ bs
  57          _         -> heap.assocs
  58      }
  59  
  60  hLookup heap addr = aLookup heap.assocs addr (error "hLookup: no entry")
  61  
  62  hAddresses heap = aDomain heap.assocs
  63  
  64  hNull = 0
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:164:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
164 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:164:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
164 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:164:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
164 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:165:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:165:38: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^

src/Template/Mark5rvp/Machine.hs:175:66: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
175 |         = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
    |                                                                  ^^^^

src/Template/Mark5rvp/Machine.hs:335:20: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
335 | gc state = state { heap = scanHeap $ fst
    |                    ^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:117:55: error:
    Not in scope: type constructor or class Addr
    |
117 | allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
    |                                                       ^^^^

src/Template/Mark5rvp/Machine.hs:123:64: error:
    Not in scope: type constructor or class Addr
    |
123 | allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
    |                                                                ^^^^

src/Template/Mark5rvp/Machine.hs:163:11: error:
    Not in scope: type constructor or class Addr
    |
163 | apStep :: Addr -> Addr -> TiState -> TiState
    |           ^^^^

src/Template/Mark5rvp/Machine.hs:163:19: error:
    Not in scope: type constructor or class Addr
    |
163 | apStep :: Addr -> Addr -> TiState -> TiState
    |                   ^^^^

src/Template/Mark5rvp/Machine.hs:165:38: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^

src/Template/Mark5rvp/Machine.hs:175:66: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
175 |         = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
    |                                                                  ^^^^

src/Template/Mark5rvp/Machine.hs:183:12: error:
    Not in scope: type constructor or class Addr
    |
183 | indStep :: Addr -> TiState -> TiState
    |            ^^^^

src/Template/Mark5rvp/Machine.hs:189:21: error:
    Not in scope: type constructor or class Addr
    |
189 | dataStep :: Tag -> [Addr] -> TiState -> TiState
    |                     ^^^^

src/Template/Mark5rvp/Machine.hs:198:27: error:
    Not in scope: type constructor or class Addr
    |
198 |             -> Assoc Name Addr
    |                           ^^^^

src/Template/Mark5rvp/Machine.hs:199:25: error:
    Not in scope: type constructor or class Addr
    |
199 |             -> (TiHeap, Addr)
    |                         ^^^^

src/Template/Mark5rvp/Machine.hs:210:40: error:
    Not in scope: type constructor or class Addr
    |
210 | instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
    |                                        ^^^^

src/Template/Mark5rvp/Machine.hs:210:65: error:
    Not in scope: type constructor or class Addr
    |
210 | instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
    |                                                                 ^^^^

src/Template/Mark5rvp/Machine.hs:214:40: error:
    Not in scope: type constructor or class Addr
    |
214 | instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
    |                                        ^^^^

src/Template/Mark5rvp/Machine.hs:214:64: error:
    Not in scope: type constructor or class Addr
    |
214 | instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
    |                                                                ^^^^

src/Template/Mark5rvp/Machine.hs:217:43: error:
    Not in scope: type constructor or class Addr
    |
217 | instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
    |                                           ^^^^

src/Template/Mark5rvp/Machine.hs:217:76: error:
    Not in scope: type constructor or class Addr
    |
217 | instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
    |                                                                            ^^^^

src/Template/Mark5rvp/Machine.hs:220:39: error:
    Not in scope: type constructor or class Addr
    |
220 | instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
    |                                       ^^^^

src/Template/Mark5rvp/Machine.hs:220:80: error:
    Not in scope: type constructor or class Addr
    |
220 | instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
    |                                                                                ^^^^

src/Template/Mark5rvp/Machine.hs:226:40: error:
    Not in scope: type constructor or class Addr
    |
226 | instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
    |                                        ^^^^

src/Template/Mark5rvp/Machine.hs:226:101: error:
    Not in scope: type constructor or class Addr
    |
226 | instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
    |                                                                                                     ^^^^

src/Template/Mark5rvp/Machine.hs:238:41: error:
    Not in scope: type constructor or class Addr
    |
238 | instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
    |                                         ^^^^

src/Template/Mark5rvp/Machine.hs:238:85: error:
    Not in scope: type constructor or class Addr
    |
238 | instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
    |                                                                                     ^^^^

src/Template/Mark5rvp/Machine.hs:241:40: error:
    Not in scope: type constructor or class Addr
    |
241 | instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
    |                                        ^^^^

src/Template/Mark5rvp/Machine.hs:241:79: error:
    Not in scope: type constructor or class Addr
    |
241 | instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
    |                                                                               ^^^^

src/Template/Mark5rvp/Machine.hs:245:25: error:
    Not in scope: type constructor or class Addr
    |
245 |                      -> Addr
    |                         ^^^^

src/Template/Mark5rvp/Machine.hs:247:36: error:
    Not in scope: type constructor or class Addr
    |
247 |                      -> Assoc Name Addr
    |                                    ^^^^

src/Template/Mark5rvp/Machine.hs:259:16: error:
    Not in scope: type constructor or class Addr
    |
259 | instUpdEVar :: Addr
    |                ^^^^

src/Template/Mark5rvp/Machine.hs:261:27: error:
    Not in scope: type constructor or class Addr
    |
261 |             -> Assoc Name Addr
    |                           ^^^^

src/Template/Mark5rvp/Machine.hs:268:16: error:
    Not in scope: type constructor or class Addr
    |
268 | instUpdENum :: Addr
    |                ^^^^

src/Template/Mark5rvp/Machine.hs:270:27: error:
    Not in scope: type constructor or class Addr
    |
270 |             -> Assoc Name Addr
    |                           ^^^^

src/Template/Mark5rvp/Machine.hs:275:19: error:
    Not in scope: type constructor or class Addr
    |
275 | instUpdEConstr :: Addr
    |                   ^^^^

src/Template/Mark5rvp/Machine.hs:277:30: error:
    Not in scope: type constructor or class Addr
    |
277 |                -> Assoc Name Addr
    |                              ^^^^

src/Template/Mark5rvp/Machine.hs:284:15: error:
    Not in scope: type constructor or class Addr
    |
284 | instUpdEAp :: Addr
    |               ^^^^

src/Template/Mark5rvp/Machine.hs:286:26: error:
    Not in scope: type constructor or class Addr
    |
286 |            -> Assoc Name Addr
    |                          ^^^^

src/Template/Mark5rvp/Machine.hs:295:16: error:
    Not in scope: type constructor or class Addr
    |
295 | instUpdELet :: Addr
    |                ^^^^

src/Template/Mark5rvp/Machine.hs:297:27: error:
    Not in scope: type constructor or class Addr
    |
297 |             -> Assoc Name Addr
    |                           ^^^^

src/Template/Mark5rvp/Machine.hs:312:17: error:
    Not in scope: type constructor or class Addr
    |
312 | instUpdECase :: Addr
    |                 ^^^^

src/Template/Mark5rvp/Machine.hs:314:28: error:
    Not in scope: type constructor or class Addr
    |
314 |              -> Assoc Name Addr
    |                            ^^^^

src/Template/Mark5rvp/Machine.hs:320:16: error:
    Not in scope: type constructor or class Addr
    |
320 | instUpdELam :: Addr
    |                ^^^^

src/Template/Mark5rvp/Machine.hs:322:27: error:
    Not in scope: type constructor or class Addr
    |
322 |             -> Assoc Name Addr
    |                           ^^^^

src/Template/Mark5rvp/Machine.hs:335:20: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
335 | gc state = state { heap = scanHeap $ fst
    |                    ^^^^

src/Template/Mark5rvp/Machine.hs:341:31: error:
    Not in scope: type constructor or class Addr
    |
341 | findStackRoots :: TiStack -> [Addr]
    |                               ^^^^

src/Template/Mark5rvp/Machine.hs:344:29: error:
    Not in scope: type constructor or class Addr
    |
344 | findDumpRoots :: TiDump -> [Addr]
    |                             ^^^^

src/Template/Mark5rvp/Machine.hs:347:34: error:
    Not in scope: type constructor or class Addr
    |
347 | findGlobalRoots :: TiGlobals -> [Addr]
    |                                  ^^^^

src/Template/Mark5rvp/Machine.hs:350:26: error:
    Not in scope: type constructor or class Addr
    |
350 | findRoots :: TiState -> [Addr]
    |                          ^^^^

src/Template/Mark5rvp/Machine.hs:358:23: error:
    Not in scope: type constructor or class Addr
    |
358 | markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
    |                       ^^^^

src/Template/Mark5rvp/Machine.hs:358:40: error:
    Not in scope: type constructor or class Addr
    |
358 | markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
    |                                        ^^^^

src/Template/Mark5rvp/Machine.hs:361:10: error:
    Not in scope: type constructor or class Addr
    |
361 | mark :: (Addr, Addr, TiHeap) -> (TiHeap, Addr)
    |          ^^^^

src/Template/Mark5rvp/Machine.hs:361:16: error:
    Not in scope: type constructor or class Addr
    |
361 | mark :: (Addr, Addr, TiHeap) -> (TiHeap, Addr)
    |                ^^^^

src/Template/Mark5rvp/Machine.hs:361:42: error:
    Not in scope: type constructor or class Addr
    |
361 | mark :: (Addr, Addr, TiHeap) -> (TiHeap, Addr)
    |                                          ^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:165:38: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^

src/Template/Mark5rvp/Machine.hs:175:66: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
175 |         = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
    |                                                                  ^^^^

src/Template/Mark5rvp/Machine.hs:335:20: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
335 | gc state = state { heap = scanHeap $ fst
    |                    ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:20:40: error:
    Ambiguous name heap in import item. It could refer to:
      Template.Mark5rvp.State.GCState(heap)
      Template.Mark5rvp.State.TiState(heap)
   |
20 | import Template.Mark5rvp.State hiding (heap)
   |                                        ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )

src/Template/Mark5rvp/State.hs:333:7: error:
    parse error on input TiHeap
    |
333 |     , TiHeap   :: TiHeap
    |       ^^^^^^
Failed, 8 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:61:7: error:
    Not in scope: heap
    Perhaps you meant one of these:
      data constructor Heap (imported from Heap),
      head (imported from Data.List.Extra)
    Perhaps you want to remove heap from the explicit hiding list
    in the import of Template.Mark5rvp.State
    (src/Template/Mark5rvp/Machine.hs:20:1-44).
   |
61 |     , heap    = initialHeap1
   |       ^^^^

src/Template/Mark5rvp/Machine.hs:165:38: error:
    Not in scope: heap
    Perhaps you meant one of these:
      data constructor Heap (imported from Heap),
      head (imported from Data.List.Extra)
    Perhaps you want to remove heap from the explicit hiding list
    in the import of Template.Mark5rvp.State
    (src/Template/Mark5rvp/Machine.hs:20:1-44).
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^

src/Template/Mark5rvp/Machine.hs:175:66: error:
    Not in scope: heap
    Perhaps you meant one of these:
      data constructor Heap (imported from Heap),
      head (imported from Data.List.Extra)
    Perhaps you want to remove heap from the explicit hiding list
    in the import of Template.Mark5rvp.State
    (src/Template/Mark5rvp/Machine.hs:20:1-44).
    |
175 |         = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
    |                                                                  ^^^^

src/Template/Mark5rvp/Machine.hs:335:20: error:
    Not in scope: heap
    Perhaps you meant one of these:
      data constructor Heap (imported from Heap),
      head (imported from Data.List.Extra)
    Perhaps you want to remove heap from the explicit hiding list
    in the import of Template.Mark5rvp.State
    (src/Template/Mark5rvp/Machine.hs:20:1-44).
    |
335 | gc state = state { heap = scanHeap $ fst
    |                    ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:20:40: error:
    Ambiguous name heap in import item. It could refer to:
      Template.Mark5rvp.State.GCState(heap)
      Template.Mark5rvp.State.TiState(heap)
   |
20 | import Template.Mark5rvp.State hiding (heap)
   |                                        ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:20:40: error:
    Ambiguous name heap in import item. It could refer to:
      Template.Mark5rvp.State.GCState(heap)
      Template.Mark5rvp.State.TiState(heap)
   |
20 | import Template.Mark5rvp.State hiding (heap)
   |                                        ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:165:38: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:22:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:334:7-10)
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^

src/Template/Mark5rvp/Machine.hs:175:66: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:22:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:334:7-10)
    |
175 |         = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
    |                                                                  ^^^^

src/Template/Mark5rvp/Machine.hs:335:20: error:
    Ambiguous occurrence heap
    It could refer to
       either the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:22:7-10)
           or the field heap,
              imported from Template.Mark5rvp.State at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:334:7-10)
    |
335 | gc state = state { heap = scanHeap $ fst
    |                    ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:165:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:164:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
164 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:164:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
164 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:360:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
    |
360 | mark :: GcState -> (TiHeap, Addr)
    | ^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:395:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
    |
395 | scanHeap :: TiHeap -> TiHeap
    | ^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:358:28: error:
    Not in scope: data constructor GcState
    Perhaps you meant TiState (imported from Template.Mark5rvp.State)
    |
358 | markFrom heap addr = mark (GcState { forward = addr, backward = hNull, tiHeap = heap })
    |                            ^^^^^^^

src/Template/Mark5rvp/Machine.hs:360:9: error:
    Not in scope: type constructor or class GcState
    Perhaps you meant TiState (imported from Template.Mark5rvp.State)
    |
360 | mark :: GcState -> (TiHeap, Addr)
    |         ^^^^^^^

src/Template/Mark5rvp/Machine.hs:363:43: error:
    Not in scope: forward
    |
363 |         (\ addr1 addr2 -> mark (gcstate { forward = addr1
    |                                           ^^^^^^^

src/Template/Mark5rvp/Machine.hs:364:43: error:
    Not in scope: backward
    |
364 |                                         , backward = gcstate.forward
    |                                           ^^^^^^^^

src/Template/Mark5rvp/Machine.hs:365:43: error:
    Not in scope: tiheap
    |
365 |                                         , tiheap = hUpdate gcstate.tiheap gcstate.forward (NMarked (Visits 1) gcstate.backward)
    |                                           ^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted ) [Template.Mark5rvp.State changed]
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:358:72: error:
    Not in scope: tiHeap
    Perhaps you meant data constructor Heap (imported from Heap)
    |
358 | markFrom heap addr = mark (GcState { forward = addr, backward = hNull, tiHeap = heap })
    |                                                                        ^^^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:373:13: error:
     The constructor Done should have no arguments, but has been given 1
     In the pattern: Done _
      In a case alternative:
          Done _
            -> if hLookup gcstate.tiheap gcstate.backword == hNull then
                   (gcstate.tiheap, gcstate.forward)
               else
                   mark undefined
      In the expression:
        case markstate of
          Done _
            -> if hLookup gcstate.tiheap gcstate.backword == hNull then
                   (gcstate.tiheap, gcstate.forward)
               else
                   mark undefined
    |
373 |             Done _ -> if hLookup gcstate.tiheap gcstate.backword == hNull
    |             ^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:365:111: error:
     Couldn't match type Int with Node
        arising from selecting the field backward
     In the second argument of NMarked, namely gcstate.backward
      In the third argument of hUpdate, namely
        (NMarked (Visits 1) gcstate.backward)
      In the tiheap field of a record
    |
365 |                                         , tiheap = hUpdate gcstate.tiheap gcstate.forward (NMarked (Visits 1) gcstate.backward)
    |                                                                                                               ^^^^^^^^^^^^^^^^

src/Template/Mark5rvp/Machine.hs:373:32: error:
     Couldn't match type Node with Int
        arising from selecting the field tiheap
     In the first argument of hLookup, namely gcstate.tiheap
      In the first argument of (==), namely
        hLookup gcstate.tiheap gcstate.backword
      In the expression: hLookup gcstate.tiheap gcstate.backword == hNull
    |
373 |             Done -> if hLookup gcstate.tiheap gcstate.backword == hNull
    |                                ^^^^^^^^^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:366:41: error:
    parse error on input }
    |
366 |                                         }))
    |                                         ^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:373:32: error:
     Couldn't match type Node with Int
        arising from selecting the field tiheap
     In the first argument of hLookup, namely gcstate.tiheap
      In the first argument of (==), namely
        hLookup gcstate.tiheap gcstate.backword
      In the expression: hLookup gcstate.tiheap gcstate.backword == hNull
    |
373 |             Done -> if hLookup gcstate.tiheap gcstate.backword == hNull
    |                                ^^^^^^^^^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:376:18: error:
    parse error on input ->
    |
376 |             _    -> undefined
    |                  ^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:373:24: error:
     No instance for (GHC.Records.HasField "backword" GcState Addr)
        arising from selecting the field backword
     In the first argument of (==), namely gcstate.backword
      In the expression: gcstate.backword == hNull
      In the expression:
        if gcstate.backword == hNull then
            (gcstate.tiheap, gcstate.forward)
        else
            mark undefined
    |
373 |             Done -> if gcstate.backword == hNull
    |                        ^^^^^^^^^^^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:370:73: error:
    Variable not in scope: f :: Addr
    |
370 |         (\ name prim -> mark (gcstate { tiheap = hUpdate gcstate.tiheap f (NMarked Done (NPrim name prim))}))
    |                                                                         ^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | 01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (file src/Template/Mark5cp/PPrint.hs changed)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 34] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 34] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 34] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 34] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 34] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 34] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 34] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 34] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 34] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 34] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 34] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 34] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 34] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 34] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 34] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 34] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 34] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 34] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 34] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 34] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 34] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 34] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 34] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 34] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 34] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 34] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 34] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 34] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 34] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 34] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 34] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[32 of 34] Compiling Template.Mark5cp.State ( src/Template/Mark5cp/State.hs, interpreted )

src/Template/Mark5cp/State.hs:257:39: error:
     Couldn't match type Node with Int
      Expected: Addr
        Actual: Node
     In the first argument of nmarked, namely node
      In the expression: nmarked node
      In a case alternative: NForward new -> nmarked node
    |
257 |     NForward new           -> nmarked node
    |                                       ^^^^
Failed, 31 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5cp.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  import Data.Function
  13  import Control.Monad
  14  
  15  data TiState
  16      = TiState
  17      { control :: TiControl
  18      , output  :: TiOutput
  19      , stack   :: TiStack
  20      , dump    :: TiDump
  21      , heap    :: TiHeap
  22      , globals :: TiGlobals
  23      , stats   :: TiStats
  24      , ruleid  :: TiRuleId
  25      }
  26  
  27  type TiControl = [String]
  28  
  29  type TiOutput  = [Int]
  30  
  31  type TiStack   = Stack Addr
  32  
  33  type TiDump    = Stack Int
  34  initialDump :: TiDump
  35  initialDump = emptyStack
  36  
  37  type TiHeap    = Heap Node
  38  
  39  type TiGlobals = Assoc Name Addr
  40  
  41  data TiStats 
  42      = TiStats
  43      { totalSteps :: Int
  44      , scSteps    :: Int
  45      , primSteps  :: Int
  46      , gcCount    :: Int
  47      }
  48      deriving Show
  49  
  50  initialStats :: TiStats
  51  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, gcCount = 0 }
  52  
  53  incTotalSteps, incScSteps, incPrimSteps, incGcCount :: TiStats -> TiStats
  54  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  55  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  56  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  57  incGcCount    stats = stats { gcCount    = succ stats.gcCount }
  58  
  59  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  60  applyToStats f state = state { stats = f state.stats }
  61  
  62  type TiRuleId = Int
  63  
  64  setRuleId :: TiRuleId -> TiState -> TiState
  65  setRuleId r state = state { ruleid = r }
  66  
  67  tiFinal :: TiState -> Bool
  68  tiFinal state = isEmptyStack state.stack
  69  
  70  -- | Primitive
  71  
  72  type Primitive = TiState -> TiState
  73  
  74  primitives :: Assoc Name Primitive
  75  primitives = [ ("negate", primNeg)
  76               , ("+", primArith (+)), ("-", primArith (-))
  77               , ("*", primArith (+)), ("/", primArith div)
  78               , ("<", primComp (<)), ("<=", primComp (<=))
  79               , (">", primComp (>)), (">=", primComp (>=))
  80               , ("==", primComp (==)), ("/=", primComp (/=))
  81               , ("if", primIf)
  82               , ("casePair", primCasePair)
  83               , ("caseList", primCaseList)
  84               , ("abort", primAbort)
  85               , ("stop", primStop)
  86               , ("print", primPrint)
  87               ]
  88  
  89  primNeg :: TiState -> TiState
  90  primNeg state
  91      | length args < 1          = error "primNeg: wrong number of args"
  92      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  93          (stack2, dump2) -> setRuleId 9
  94                           $ state { stack = stack2, dump = dump2 }
  95      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  96                                 $ state { stack = stack1, heap = heap1 }
  97      where
  98          args      = take 1 $ getargs state.heap state.stack
  99          [argAddr] = args
 100          argNode   = hLookup state.heap argAddr
 101          NNum argValue = argNode
 102          (_, stack1) = pop state.stack
 103          (root, _)   = pop stack1
 104          heap1 = hUpdate state.heap root (NNum (negate argValue))
 105  
 106  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 107  primArith op = primDyadic op'
 108      where
 109          op' (NNum m) (NNum n) = NNum (m `op` n)
 110  
 111  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 112  primComp op = primDyadic op'
 113      where
 114          op' (NNum m) (NNum n)
 115              | m `op` n  = NData 1 []
 116              | otherwise = NData 0 []
 117  
 118  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 119  primDyadic op state 
 120      | length args < 2 = error "primDyadic: wrong number of args"
 121      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 122          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 123      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 124          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 125      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 126                                  $ state { stack = stack1, heap = heap1 }
 127      where
 128          args = take 2 $ getargs state.heap state.stack
 129          [arg1Addr, arg2Addr] = args
 130          [arg1Node, arg2Node] = map (hLookup state.heap) args
 131          stack1 = discard 2 state.stack
 132          (root, _) = pop stack1
 133          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 134  
 135  primConstr :: Tag -> Arity -> TiState -> TiState
 136  primConstr tag arity state
 137      | length args < arity = error "primConstr: wrong number of args"
 138      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 139      where
 140          args = take arity $ getargs state.heap state.stack
 141          stack1 = discard arity state.stack
 142          (root,_) = pop stack1
 143          heap1 = hUpdate state.heap root (NData tag args)
 144  
 145  primIf :: TiState -> TiState
 146  primIf state
 147      | length args < 3 = error "primIf: wrong number of args"
 148      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 149          (stack2, dump2) -> setRuleId 19
 150                           $ state { stack = stack2, dump = dump2 }
 151      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 152      where
 153          args = take 3 $ getargs state.heap state.stack
 154          [arg1Addr, arg2Addr, arg3Addr] = args
 155          arg1Node = hLookup state.heap arg1Addr
 156          stack1 = discard 3 state.stack 
 157          (root, _) = pop stack1
 158          result = case arg1Node of
 159              NData 0 [] -> arg3Addr
 160              _          -> arg2Addr
 161          heap1 = hUpdate state.heap root (NInd result)
 162  
 163  primCasePair :: TiState -> TiState
 164  primCasePair state
 165      | length args < 2 = error "primCasePair: wrong number of args"
 166      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 167          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 168      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 169      where
 170          args = take 2 $ getargs state.heap state.stack
 171          [arg1Addr, arg2Addr] = args
 172          arg1Node = hLookup state.heap arg1Addr
 173          stack1 = discard 2 state.stack
 174          (root, _) = pop stack1
 175          heap1 = case arg1Node of
 176              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 177                  where
 178                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 179  
 180  primCaseList :: TiState -> TiState
 181  primCaseList state
 182      | length args < 3 = error "primCaseList: wrong number of args"
 183      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 184          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 185      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 186      where
 187          args = take 3 $ getargs state.heap state.stack
 188          [arg1Addr, arg2Addr, arg3Addr] = args
 189          arg1Node = hLookup state.heap arg1Addr
 190          stack1 = discard 3 state.stack
 191          (root, _) = pop stack1
 192          heap1 = case arg1Node of
 193              NData tag cmpnts
 194                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 195                  | otherwise -> case cmpnts of
 196                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 197                          where
 198                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 199                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 200              _ -> error "not NData node"
 201  
 202  primAbort :: TiState -> TiState
 203  primAbort = error "Program abort!"
 204  
 205  primStop :: TiState -> TiState
 206  primStop state 
 207      | not (isEmptyStack state.dump) 
 208          = error "primStop: dump is not empty"
 209      | otherwise
 210          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 211  
 212  primPrint :: TiState -> TiState
 213  primPrint state
 214      | argsLen < 2 = error "primPrint: wrong number of args"
 215      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 216      | otherwise = case arg1Node of
 217          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 218                                            , stack = push arg2Addr (emptyStack' state.stack)
 219                                            }
 220          NData _ _ -> error "primPrint: not a number"
 221          _         -> case saveAndPush arg1Addr stack1 state.dump of
 222              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 223      where
 224          args = take 2 $ getargs state.heap state.stack
 225          argsLen = length args
 226          [arg1Addr, arg2Addr] = args
 227          arg1Node = hLookup state.heap arg1Addr
 228          NNum arg1Value = arg1Node
 229          stack1 = discard argsLen state.stack
 230  
 231  -- | Node
 232  
 233  data Node
 234      = NAp Addr Addr
 235      | NSupercomb Name [Name] CoreExpr
 236      | NNum Int
 237      | NInd Addr
 238      | NPrim Name Primitive
 239      | NData Tag [Addr]
 240      | NForward Addr
 241  
 242  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 243               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 244               -> (Int -> a)                        -- ^ NNum
 245               -> (Addr -> a)                       -- ^ NInd
 246               -> (Name -> Primitive -> a)          -- ^ NPrim
 247               -> (Tag -> [Addr] -> a)              -- ^ NData
 248               -> (Addr -> a)                       -- ^ NForward
 249               -> Node -> a
 250  dispatchNode nap nsupercomb nnum nind nprim ndata forward node = case node of
 251      NAp a b                -> nap a b
 252      NSupercomb f args body -> nsupercomb f args body
 253      NNum n                 -> nnum n
 254      NInd a                 -> nind a
 255      NPrim name prim        -> nprim name prim
 256      NData tag contents     -> ndata tag contents
 257      NForward new           -> forward new
 258  
 259  isDataNode :: Node -> Bool
 260  isDataNode node = case node of
 261      NNum _    -> True
 262      NData _ _ -> True
 263      _         -> False
 264  
 265  doAdminTotalSteps :: TiState -> TiState
 266  doAdminTotalSteps = applyToStats incTotalSteps
 267  
 268  doAdminScSteps :: TiState -> TiState
 269  doAdminScSteps = applyToStats incScSteps
 270  
 271  doAdminPrimSteps :: TiState -> TiState
 272  doAdminPrimSteps = applyToStats incPrimSteps
 273  
 274  getargs :: TiHeap -> TiStack -> [Addr]
 275  getargs heap stack = case pop stack of
 276      (sc, stack1) -> map getarg stack1.stkItems
 277          where
 278              getarg addr = case hLookup heap addr of
 279                  NAp _ arg -> arg
 280                  _         -> error "getarg: not application node"
 281  
 282  --
 283  emptyStack' :: TiStack -> TiStack
 284  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 285  
 286  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 287  saveAndPush addr stack dump
 288      = (push addr stack, push stack.curDepth dump)
 289  
 290  popAndRestore :: TiStack -> TiDump -> (TiStack, TiDump)
 291  popAndRestore stack dump
 292      | isEmptyStack dump = error "restore: dump is empty"
 293      | otherwise         = case pop dump of
 294          (sp, dump') 
 295              -> ( discard (stack.curDepth - sp) stack, dump' )
 296  
 297  --
 298  ruleTable :: [(TiRuleId, String)]
 299  ruleTable 
 300      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 301        , (2, "Rule (2.2): Perform a supercombinator reduction")
 302        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 303        , (4, "Rule (2.4): Update the indirection node to immediate node")
 304        , (5, "Rule (2.5): For -reduction of negation primitive application with a evaluated argument")
 305        , (6, "Rule (2.6): For operand evaluation of negation")
 306        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 307        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 308        , (9, "Rule (2.9): For operand evaluation of negation")
 309        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 310        , (11, "Rule (2.11): For `NPrim Stop`")
 311        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 312        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 313        , (15, "Rule (2.15): Ex 2.21: For -reduction of binary operator")
 314        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 315        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 316        , (18, "Rule (2.18): Ex 2.21: For -reduction of conditional")
 317        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 318        , (20, "Rule (2.20): Ex 2.22: For -reduction of casePair")
 319        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 320        , (22, "Rule (2.22): Ex 2.24: For -reduction of caseList")
 321        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 322        ]
 323        
[32 of 34] Compiling Template.Mark5cp.State ( src/Template/Mark5cp/State.hs, interpreted )
[33 of 34] Compiling Template.Mark5cp.PPrint ( src/Template/Mark5cp/PPrint.hs, interpreted )
[34 of 34] Compiling Template.Mark5cp.Machine ( src/Template/Mark5cp/Machine.hs, interpreted )

src/Template/Mark5cp/Machine.hs:95:25: error:
    Variable not in scope: venge :: Expr a4
   |
95 |                         venge      (EVar "y"))
   |                         ^^^^^

src/Template/Mark5cp/Machine.hs:158:16: error:
    Variable not in scope: venge :: Addr -> TiState -> TiState -> b
    |
158 |                venge     (error "step: NForward node")
    |                ^^^^^

src/Template/Mark5cp/Machine.hs:340:47: error:
     Variable not in scope: from :: TiHeap
     Perhaps you meant from1 (line 340)
    |
340 |     (from1, to1, stack1) -> case evacuateDump from state.dump of
    |                                               ^^^^

src/Template/Mark5cp/Machine.hs:341:38: error:
    Variable not in scope:
      markFromGlobals :: t1 -> TiGlobals -> (a3, b2, TiGlobals)
    |
341 |         (from2, to2, dump1)  -> case markFromGlobals hp2 state.globals of
    |                                      ^^^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:341:54: error:
    Variable not in scope: hp2
    |
341 |         (from2, to2, dump1)  -> case markFromGlobals hp2 state.globals of
    |                                                      ^^^

src/Template/Mark5cp/Machine.hs:343:54: error:
     Variable not in scope: scavengenHeap :: t0 -> TiHeap
     Perhaps you meant scavengeHeap (line 411)
    |
343 |                                             , heap = scavengenHeap hp3, globals = globals1, stats = incGcCount state.stats }
    |                                                      ^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:343:68: error:
    Variable not in scope: hp3
    |
343 |                                             , heap = scavengenHeap hp3, globals = globals1, stats = incGcCount state.stats }
    |                                                                    ^^^
Failed, 33 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5cp.Machine
   6      where
   7  
   8  import Data.Bool
   9  import Data.Char
  10  import Data.List
  11  import Data.List.Extra
  12  
  13  import Language
  14  import Heap
  15  import Stack
  16  import Iseq
  17  import Utils
  18  
  19  import Template.Mark5cp.State
  20  import Template.Mark5cp.PPrint
  21  
  22  import Debug.Trace qualified as Deb
  23  
  24  debug :: Bool
  25  debug = True
  26  
  27  trace :: String -> a -> a
  28  trace | debug     = Deb.trace
  29        | otherwise = const id 
  30  
  31  traceShow :: Show a => a -> b -> b
  32  traceShow | debug     = Deb.traceShow
  33            | otherwise = const id
  34  
  35  {- * Mark 5 : Structured data -}
  36  {- | Structure of the implementations -}
  37  
  38  drive :: ([String] -> [String]) -> (String -> String)
  39  drive f = unlines . f . ("" :) . lines
  40  
  41  run :: (?sz :: Int, ?th :: Int) => String -> ([String] -> [String])
  42  run prog inputs
  43      = showResults 
  44      $ eval
  45      $ setControl inputs
  46      $ compile 
  47      $ parse prog
  48  
  49  setControl :: [String] -> TiState -> TiState
  50  setControl ctrl state = state { control = ctrl }
  51  
  52  {- | Compiler -}
  53  
  54  compile :: (?sz :: Int, ?th :: Int) => CoreProgram -> TiState
  55  compile prog = TiState
  56      { control = []
  57      , output  = []
  58      , stack   = initialStack1
  59      , dump    = initialDump
  60      , heap    = initialHeap1
  61      , globals = initialGlobals
  62      , stats   = initialStats
  63      , ruleid  = 0
  64      }
  65      where
  66          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
  67          (initialHeap, initialGlobals) = buildInitialHeap scDefs
  68          initialStack = singletonStack addressOfMain
  69          initialStack1 = singletonStack addr
  70          addressOfMain = aLookup initialGlobals "main" (negate 1)
  71          (heap1, addr1)
  72              | addressOfMain < 0 = (initialHeap, aLookup initialGlobals "pmain" (error "no main and no pmain"))
  73              | otherwise         = case aLookup initialGlobals "Cons" (error "Cons is not defined") of
  74                  addressOfCons    -> case aLookup initialGlobals "Nil" (error "Nil is not defined") of
  75                      addressOfNil   -> case hAlloc initialHeap (NAp addressOfCons addressOfMain) of
  76                          (h, a)       -> hAlloc h (NAp a addressOfNil)
  77          addressOfPrint = aLookup initialGlobals "printList" (error "printList is not defined")
  78          (initialHeap1, addr) = hAlloc heap1 (NAp addressOfPrint addr1)
  79  
  80  extraPreludeDefs :: CoreProgram
  81  extraPreludeDefs = 
  82      [ ("False", [], EConstr 0 0)
  83      , ("True" , [], EConstr 1 0)
  84      , ("not", ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  85                                (EVar "False"))
  86                           (EVar "True"))
  87      , ("and", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  88                                     (EVar "y"))
  89                                (EVar "False"))
  90      , ("or",  ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  91                                     (EVar "True"))
  92                                (EVar "y"))
  93      , ("xor", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  94                                     (EAp (EVar "not") (EVar "y")))
  95                                (EVar "y"))
  96      , ("MkPair", [], EConstr 0 2)
  97      , ("fst", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  98                           (EVar "K"))
  99      , ("snd", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
 100                           (EVar "K1"))
 101      , ("Nil", [], EConstr 0 0)
 102      , ("Cons", [], EConstr 1 2)
 103      , ("head", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 104                                  (EVar "abort"))
 105                             (EVar "K"))
 106      , ("tail", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 107                                  (EVar "abort"))
 108                             (EVar "K1"))
 109      , ("printList", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 110                                       (EVar "stop"))
 111                                  (EVar "printCons"))
 112      , ("printCons", ["h", "t"], EAp (EAp (EVar "print") (EVar "h"))
 113                                      (EAp (EVar "printList") (EVar "t")))
 114      ]
 115  
 116  buildInitialHeap :: ( ?sz :: Int, ?th :: Int ) => [CoreScDefn] -> (TiHeap, TiGlobals)
 117  buildInitialHeap scDefs = (heap2, scAddrs ++ primAddrs)
 118      where
 119          (heap1, scAddrs)   = mapAccumL allocateSc hInitial scDefs
 120          (heap2, primAddrs) = mapAccumL allocatePrim heap1 primitives
 121  
 122  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 123  allocateSc heap scDefn = case scDefn of
 124      (name, args, body) -> (heap', (name, addr))
 125          where
 126              (heap', addr) = hAlloc heap (NSupercomb name args body)
 127  
 128  allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
 129  allocatePrim heap (name, prim) = (heap1, (name, addr))
 130      where
 131          (heap1, addr) = hAlloc heap (NPrim name prim)
 132  
 133  {- | Evaluator -}
 134  
 135  eval :: TiState -> [TiState]
 136  eval state = state : rests
 137      where
 138          rests | tiFinal state = []
 139                | otherwise      = eval $ doAdmin $ doAdminTotalSteps $ step state
 140  
 141  doAdmin :: TiState -> TiState
 142  doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
 143  
 144  step :: TiState -> TiState
 145  step state = case map toLower $ head state.control of
 146      ""                -> state' { control = tail state.control }
 147      "c"               -> state' { control = repeat "" }
 148      s | all isDigit s -> state' { control = replicate (pred $ read s) "" ++ tail state.control }
 149        | otherwise     -> state' { control = tail state.control }
 150    where
 151          state' = dispatchNode 
 152                      apStep
 153                      scStep
 154                      numStep
 155                      indStep
 156                      primStep
 157                      dataStep
 158                 venge     (error "step: NForward node")
 159                      (hLookup state.heap (fst (pop state.stack)))
 160                    $ state
 161  
 162  numStep :: Int -> TiState -> TiState
 163  numStep n state 
 164      | isEmptyStack state.dump = error "numStep: Number applied as a function"
 165      | otherwise = case popAndRestore state.stack state.dump of
 166          (stack1, dump1) -> setRuleId 7 $ state { stack = stack1, dump = dump1 }
 167  
 168  apStep :: Addr -> Addr -> TiState -> TiState
 169  apStep a1 a2 state = case hLookup state.heap a2 of
 170      NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
 171      _       -> setRuleId 1 $ state { stack = push a1 state.stack }
 172      where
 173          (a,_) = pop state.stack
 174  
 175  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 176  scStep name args body state
 177      | state.stack.curDepth < succ argsLen
 178          = error "scStep: too few arguments given"
 179      | otherwise
 180          = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
 181      where
 182          argsLen  = length args
 183          stack1   = discard argsLen state.stack
 184          (root,_) = pop stack1
 185          heap1    = instantiateAndUpdate body root state.heap (bindings ++ state.globals)
 186          bindings = zip args (getargs state.heap state.stack)
 187  
 188  indStep :: Addr -> TiState -> TiState
 189  indStep addr state = setRuleId 4 $ state { stack = push addr (discard 1 state.stack) }
 190  
 191  primStep :: Name -> Primitive -> TiState -> TiState
 192  primStep name prim = prim
 193  
 194  dataStep :: Tag -> [Addr] -> TiState -> TiState
 195  dataStep tag contents state = state { stack = stack1, dump = dump1 }
 196      where
 197          (stack1, dump1) = popAndRestore state.stack state.dump
 198  
 199  {- | Instantiation -}
 200  
 201  instantiate :: CoreExpr
 202              -> TiHeap
 203              -> Assoc Name Addr
 204              -> (TiHeap, Addr)
 205  instantiate expr heap env = dispatchCoreExpr
 206      (instantiateVar heap env)
 207      (instantiateNum heap env)
 208      (instantiateConstr heap env)
 209      (instantiateAp heap env)
 210      (instantiateLet heap env)
 211      (instantiateCase heap env)
 212      (instantiateLam heap env)
 213      expr
 214  
 215  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 216  instantiateVar heap env name
 217      = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 218  
 219  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 220  instantiateNum heap env num = hAlloc heap (NNum num)
 221  
 222  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 223  instantiateConstr heap env tag arity = hAlloc heap (NPrim "Constr" (primConstr tag arity))
 224  
 225  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 226  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 227      where
 228          (heap1, a1) = instantiate a heap  env
 229          (heap2, a2) = instantiate b heap1 env
 230  
 231  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 232  instantiateLet heap env isrec defs body = instantiate body heap' env'
 233      where
 234          (heap', extraBindings) = mapAccumL instantiateRhs heap defs
 235          env' = extraBindings ++ env
 236          rhsEnv | isrec     = env'
 237                 | otherwise = env
 238          instantiateRhs heap (name, rhs)
 239              = (heap1, (name, addr))
 240              where
 241                  (heap1, addr) = instantiate rhs heap rhsEnv
 242  
 243  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 244  instantiateCase heap env expr alters = error "Cannot instatiate case"
 245  
 246  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 247  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 248  
 249  instantiateAndUpdate :: CoreExpr
 250                       -> Addr
 251                       -> TiHeap
 252                       -> Assoc Name Addr
 253                       -> TiHeap
 254  instantiateAndUpdate expr updAddr heap env = dispatchCoreExpr
 255      (instUpdEVar updAddr heap env)
 256      (instUpdENum updAddr heap env)
 257      (instUpdEConstr updAddr heap env)
 258      (instUpdEAp updAddr heap env)
 259      (instUpdELet updAddr heap env)
 260      (instUpdECase updAddr heap env)
 261      (instUpdELam updAddr heap env)
 262      expr
 263  
 264  instUpdEVar :: Addr
 265              -> TiHeap
 266              -> Assoc Name Addr
 267              -> Name
 268              -> TiHeap
 269  instUpdEVar updAddr heap env v = hUpdate heap updAddr (NInd varAddr)
 270      where
 271          varAddr = aLookup env v (error ("undefined name " ++ show v))
 272  
 273  instUpdENum :: Addr
 274              -> TiHeap
 275              -> Assoc Name Addr
 276              -> Int
 277              -> TiHeap
 278  instUpdENum updAddr heap env n = hUpdate heap updAddr (NNum n)
 279  
 280  instUpdEConstr :: Addr
 281                 -> TiHeap
 282                 -> Assoc Name Addr
 283                 -> Tag
 284                 -> Arity
 285                 -> TiHeap
 286  instUpdEConstr updAddr heap env tag arity
 287      = hUpdate heap updAddr (NPrim "Constr" (primConstr tag arity))
 288  
 289  instUpdEAp :: Addr
 290             -> TiHeap
 291             -> Assoc Name Addr
 292             -> CoreExpr
 293             -> CoreExpr
 294             -> TiHeap
 295  instUpdEAp updAddr heap env e1 e2 = hUpdate heap2 updAddr (NAp a1 a2)
 296      where
 297          (heap1, a1) = instantiate e1 heap  env
 298          (heap2, a2) = instantiate e2 heap1 env
 299  
 300  instUpdELet :: Addr
 301              -> TiHeap
 302              -> Assoc Name Addr
 303              -> IsRec
 304              -> Assoc Name CoreExpr
 305              -> CoreExpr
 306              -> TiHeap
 307  instUpdELet updAddr heap env isrec defs body = instantiateAndUpdate body updAddr heap1 env1
 308      where
 309          (heap1, extraBindings) = mapAccumL instantiateRhs heap defs
 310          env1 = extraBindings ++ env
 311          rhsEnv | isrec     = env1
 312                 | otherwise = env
 313          instantiateRhs heap (name, rhs) = (heap1, (name, addr))
 314              where
 315                  (heap1, addr) = instantiate rhs heap rhsEnv
 316  
 317  instUpdECase :: Addr
 318               -> TiHeap
 319               -> Assoc Name Addr
 320               -> CoreExpr
 321               -> [CoreAlter]
 322               -> TiHeap
 323  instUpdECase updAddr heap env expr alts = error "not implemented"
 324  
 325  instUpdELam :: Addr
 326              -> TiHeap
 327              -> Assoc Name Addr
 328              -> [Name]
 329              -> CoreExpr
 330              -> TiHeap
 331  instUpdELam updAddr heap env vars body = error "not implemented"
 332  
 333  test :: (?sz :: Int, ?th :: Int) => String -> IO ()
 334  test = interact . drive . run 
 335  
 336  -- Gabage Collector (Mark-scan)
 337  
 338  gc :: TiState -> TiState
 339  gc state = case evacuateStack state.heap hInitial state.stack of
 340      (from1, to1, stack1) -> case evacuateDump from state.dump of
 341          (from2, to2, dump1)  -> case markFromGlobals hp2 state.globals of
 342              (from3, to3, globals1) -> state { stack = stack1
 343                                              , heap = scavengenHeap hp3, globals = globals1, stats = incGcCount state.stats }
 344  
 345  -- gc state = state { heap = scanHeap $ fst
 346  --                         $ mapAccumL markFrom state.heap
 347  --                         $ findRoots state 
 348  --                  , stats = incGcCount state.stats
 349  --                  }
 350  
 351  
 352  findStackRoots :: TiStack -> [Addr]
 353  findStackRoots stack = stack.stkItems
 354  
 355  findDumpRoots :: TiDump -> [Addr]
 356  findDumpRoots dump = []
 357  
 358  findGlobalRoots :: TiGlobals -> [Addr]
 359  findGlobalRoots globals = aRange globals
 360  
 361  findRoots :: TiState -> [Addr]
 362  findRoots state = concat
 363      [ findStackRoots state.stack
 364      , findDumpRoots state.dump
 365      , findGlobalRoots state.globals
 366      ]
 367  
 368  evacuateStack :: TiHeap -> TiHeap -> TiStack -> ((TiHeap, TiHeap), TiStack)
 369  evacuateStack from to stack = case mapAccumL evacuateFrom (from, to) stack.stkItems of
 370      (heaps', addrs') -> (heaps', stack { stkItems = addrs'})
 371  
 372  evacuateDump :: TiHeap -> TiHeap -> TiDump -> ((TiHeap, TiHeap), TiDump)
 373  evacuateDump from to dump = undefined
 374  
 375  evacuateGlobals :: TiHeap -> TiHeap -> TiGlobals -> ((TiHeap, TiHeap), TiGlobals)
 376  evacuateGlobals from to globals = undefined
 377  
 378  evacuateFrom :: (TiHeap, TiHeap) -> Addr -> ((TiHeap, TiHeap), Addr)
 379  evacuateFrom (from, to) addr = case hLookup from addr of
 380      node -> dispatchNode
 381          (\ addr1 addr2 -> case evacuateFrom (from, to) addr1 of
 382              ((from1, to1), addr11) -> case evacuateFrom (from1, to1) addr2 of
 383                  ((from2, to2), addr22) -> case hAlloc to2 (NAp addr11 addr22) of
 384                      (to3, addr3) -> case hUpdate from2 addr (NForward addr3) of
 385                          from3 -> ((from3, to3), addr3)
 386          )
 387          (\ sc args e -> case hAlloc to node of
 388              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 389                  from1 -> ((from1, to1), addr1)
 390          )
 391          (\ n -> case hAlloc to node of
 392              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 393                  from1 -> ((from1, to1), addr1)
 394          )
 395          (\ addr1 -> evacuateFrom (from, to) addr1
 396          ) 
 397          (\ name prim -> case hAlloc to node of
 398              (to1, addr1) -> case hUpdate from addr1 (NForward addr1) of
 399                  from1 -> ((from1, to1), addr1)
 400          )
 401          (\ tag args -> case mapAccumL evacuateFrom (from, to) args of
 402              ((from1, to1), args1) -> case hAlloc to1 (NData tag args1) of
 403                  (to2, addr2) -> case hUpdate from1 addr (NForward addr2) of
 404                      from2 -> ((from2, to2), addr2)
 405          )
 406          (\ fwaddr -> ((from, to), fwaddr)
 407          )
 408          node
 409  
 410  scavengeHeap :: TiHeap -> TiHeap -> TiHeap
 411  scavengeHeap from to = undefined
 412  
 413  {-
 414  markFromStack :: TiHeap -> TiStack -> (TiHeap, TiStack)
 415  markFromStack hp stk = case mapAccumL markFrom hp stk.stkItems of
 416      (hp', stk') -> (hp', stk { stkItems = stk'})
 417  
 418  markFromDump :: TiHeap -> TiDump -> (TiHeap, TiDump)
 419  markFromDump hp dump = (hp, dump)
 420  
 421  markFromGlobals :: TiHeap -> TiGlobals -> (TiHeap, TiGlobals)
 422  markFromGlobals hp env = mapAccumL markFrom_ hp env
 423      where
 424          markFrom_ heap (name, addr) = case markFrom heap addr of
 425              (heap', addr') -> (heap', (name, addr'))
 426  
 427  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
 428  markFrom heap addr = case hLookup heap addr of
 429      node -> dispatchNode 
 430              (\ addr1 addr2 -> case markFrom heap addr1 of
 431                  (heap1, addr1') -> case markFrom heap1 addr2 of
 432                      (heap2, addr2')  -> (hUpdate heap2 addr (NMarked (NAp addr1' addr2')), addr))
 433              (\ _ _ _       -> (hUpdate heap addr (NMarked node), addr)) -- NSupercomb
 434              (\ _           -> (hUpdate heap addr (NMarked node), addr)) -- NNum
 435              (\ addr1       -> markFrom heap addr1)                      -- NInd
 436              (\ _ _         -> (hUpdate heap addr (NMarked node), addr)) -- NPrim
 437              (\ tag as      -> case mapAccumL markFrom heap as of
 438                  (heap', as')    -> (hUpdate heap' addr (NMarked (NData tag as')), addr))
 439                                                                          -- NData
 440              (\ _           -> (heap, addr))                             -- NForward
 441              node
 442  
 443  scanHeap :: TiHeap -> TiHeap
 444  scanHeap heap =foldl phi heap heap.assocs
 445      where
 446          phi h (a, node) = case node of
 447              NMarked node1 -> hUpdate h a node1
 448              _             -> hFree h a
 449  -}
[34 of 34] Compiling Template.Mark5cp.Machine ( src/Template/Mark5cp/Machine.hs, interpreted )

src/Template/Mark5cp/Machine.hs:158:16: error:
    Variable not in scope: venge :: Addr -> TiState -> TiState -> b
    |
158 |                venge     (error "step: NForward node")
    |                ^^^^^

src/Template/Mark5cp/Machine.hs:340:47: error:
     Variable not in scope: from :: TiHeap
     Perhaps you meant from1 (line 340)
    |
340 |     (from1, to1, stack1) -> case evacuateDump from state.dump of
    |                                               ^^^^

src/Template/Mark5cp/Machine.hs:341:38: error:
    Variable not in scope:
      markFromGlobals :: t1 -> TiGlobals -> (a2, b2, TiGlobals)
    |
341 |         (from2, to2, dump1)  -> case markFromGlobals hp2 state.globals of
    |                                      ^^^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:341:54: error:
    Variable not in scope: hp2
    |
341 |         (from2, to2, dump1)  -> case markFromGlobals hp2 state.globals of
    |                                                      ^^^

src/Template/Mark5cp/Machine.hs:343:54: error:
     Variable not in scope: scavengenHeap :: t0 -> TiHeap
     Perhaps you meant scavengeHeap (line 411)
    |
343 |                                             , heap = scavengenHeap hp3, globals = globals1, stats = incGcCount state.stats }
    |                                                      ^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:343:68: error:
    Variable not in scope: hp3
    |
343 |                                             , heap = scavengenHeap hp3, globals = globals1, stats = incGcCount state.stats }
    |                                                                    ^^^
Failed, 33 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5cp.Machine
   6      where
   7  
   8  import Data.Bool
   9  import Data.Char
  10  import Data.List
  11  import Data.List.Extra
  12  
  13  import Language
  14  import Heap
  15  import Stack
  16  import Iseq
  17  import Utils
  18  
  19  import Template.Mark5cp.State
  20  import Template.Mark5cp.PPrint
  21  
  22  import Debug.Trace qualified as Deb
  23  
  24  debug :: Bool
  25  debug = True
  26  
  27  trace :: String -> a -> a
  28  trace | debug     = Deb.trace
  29        | otherwise = const id 
  30  
  31  traceShow :: Show a => a -> b -> b
  32  traceShow | debug     = Deb.traceShow
  33            | otherwise = const id
  34  
  35  {- * Mark 5 : Structured data -}
  36  {- | Structure of the implementations -}
  37  
  38  drive :: ([String] -> [String]) -> (String -> String)
  39  drive f = unlines . f . ("" :) . lines
  40  
  41  run :: (?sz :: Int, ?th :: Int) => String -> ([String] -> [String])
  42  run prog inputs
  43      = showResults 
  44      $ eval
  45      $ setControl inputs
  46      $ compile 
  47      $ parse prog
  48  
  49  setControl :: [String] -> TiState -> TiState
  50  setControl ctrl state = state { control = ctrl }
  51  
  52  {- | Compiler -}
  53  
  54  compile :: (?sz :: Int, ?th :: Int) => CoreProgram -> TiState
  55  compile prog = TiState
  56      { control = []
  57      , output  = []
  58      , stack   = initialStack1
  59      , dump    = initialDump
  60      , heap    = initialHeap1
  61      , globals = initialGlobals
  62      , stats   = initialStats
  63      , ruleid  = 0
  64      }
  65      where
  66          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
  67          (initialHeap, initialGlobals) = buildInitialHeap scDefs
  68          initialStack = singletonStack addressOfMain
  69          initialStack1 = singletonStack addr
  70          addressOfMain = aLookup initialGlobals "main" (negate 1)
  71          (heap1, addr1)
  72              | addressOfMain < 0 = (initialHeap, aLookup initialGlobals "pmain" (error "no main and no pmain"))
  73              | otherwise         = case aLookup initialGlobals "Cons" (error "Cons is not defined") of
  74                  addressOfCons    -> case aLookup initialGlobals "Nil" (error "Nil is not defined") of
  75                      addressOfNil   -> case hAlloc initialHeap (NAp addressOfCons addressOfMain) of
  76                          (h, a)       -> hAlloc h (NAp a addressOfNil)
  77          addressOfPrint = aLookup initialGlobals "printList" (error "printList is not defined")
  78          (initialHeap1, addr) = hAlloc heap1 (NAp addressOfPrint addr1)
  79  
  80  extraPreludeDefs :: CoreProgram
  81  extraPreludeDefs = 
  82      [ ("False", [], EConstr 0 0)
  83      , ("True" , [], EConstr 1 0)
  84      , ("not", ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  85                                (EVar "False"))
  86                           (EVar "True"))
  87      , ("and", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  88                                     (EVar "y"))
  89                                (EVar "False"))
  90      , ("or",  ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  91                                     (EVar "True"))
  92                                (EVar "y"))
  93      , ("xor", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  94                                     (EAp (EVar "not") (EVar "y")))
  95                                (EVar "y"))
  96      , ("MkPair", [], EConstr 0 2)
  97      , ("fst", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  98                           (EVar "K"))
  99      , ("snd", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
 100                           (EVar "K1"))
 101      , ("Nil", [], EConstr 0 0)
 102      , ("Cons", [], EConstr 1 2)
 103      , ("head", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 104                                  (EVar "abort"))
 105                             (EVar "K"))
 106      , ("tail", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 107                                  (EVar "abort"))
 108                             (EVar "K1"))
 109      , ("printList", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 110                                       (EVar "stop"))
 111                                  (EVar "printCons"))
 112      , ("printCons", ["h", "t"], EAp (EAp (EVar "print") (EVar "h"))
 113                                      (EAp (EVar "printList") (EVar "t")))
 114      ]
 115  
 116  buildInitialHeap :: ( ?sz :: Int, ?th :: Int ) => [CoreScDefn] -> (TiHeap, TiGlobals)
 117  buildInitialHeap scDefs = (heap2, scAddrs ++ primAddrs)
 118      where
 119          (heap1, scAddrs)   = mapAccumL allocateSc hInitial scDefs
 120          (heap2, primAddrs) = mapAccumL allocatePrim heap1 primitives
 121  
 122  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 123  allocateSc heap scDefn = case scDefn of
 124      (name, args, body) -> (heap', (name, addr))
 125          where
 126              (heap', addr) = hAlloc heap (NSupercomb name args body)
 127  
 128  allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
 129  allocatePrim heap (name, prim) = (heap1, (name, addr))
 130      where
 131          (heap1, addr) = hAlloc heap (NPrim name prim)
 132  
 133  {- | Evaluator -}
 134  
 135  eval :: TiState -> [TiState]
 136  eval state = state : rests
 137      where
 138          rests | tiFinal state = []
 139                | otherwise      = eval $ doAdmin $ doAdminTotalSteps $ step state
 140  
 141  doAdmin :: TiState -> TiState
 142  doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
 143  
 144  step :: TiState -> TiState
 145  step state = case map toLower $ head state.control of
 146      ""                -> state' { control = tail state.control }
 147      "c"               -> state' { control = repeat "" }
 148      s | all isDigit s -> state' { control = replicate (pred $ read s) "" ++ tail state.control }
 149        | otherwise     -> state' { control = tail state.control }
 150    where
 151          state' = dispatchNode 
 152                      apStep
 153                      scStep
 154                      numStep
 155                      indStep
 156                      primStep
 157                      dataStep
 158                      (error "step: NForward node")
 159                      (hLookup state.heap (fst (pop state.stack)))
 160                    $ state
 161  
 162  numStep :: Int -> TiState -> TiState
 163  numStep n state 
 164      | isEmptyStack state.dump = error "numStep: Number applied as a function"
 165      | otherwise = case popAndRestore state.stack state.dump of
 166          (stack1, dump1) -> setRuleId 7 $ state { stack = stack1, dump = dump1 }
 167  
 168  apStep :: Addr -> Addr -> TiState -> TiState
 169  apStep a1 a2 state = case hLookup state.heap a2 of
 170      NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
 171      _       -> setRuleId 1 $ state { stack = push a1 state.stack }
 172      where
 173          (a,_) = pop state.stack
 174  
 175  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 176  scStep name args body state
 177      | state.stack.curDepth < succ argsLen
 178          = error "scStep: too few arguments given"
 179      | otherwise
 180          = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
 181      where
 182          argsLen  = length args
 183          stack1   = discard argsLen state.stack
 184          (root,_) = pop stack1
 185          heap1    = instantiateAndUpdate body root state.heap (bindings ++ state.globals)
 186          bindings = zip args (getargs state.heap state.stack)
 187  
 188  indStep :: Addr -> TiState -> TiState
 189  indStep addr state = setRuleId 4 $ state { stack = push addr (discard 1 state.stack) }
 190  
 191  primStep :: Name -> Primitive -> TiState -> TiState
 192  primStep name prim = prim
 193  
 194  dataStep :: Tag -> [Addr] -> TiState -> TiState
 195  dataStep tag contents state = state { stack = stack1, dump = dump1 }
 196      where
 197          (stack1, dump1) = popAndRestore state.stack state.dump
 198  
 199  {- | Instantiation -}
 200  
 201  instantiate :: CoreExpr
 202              -> TiHeap
 203              -> Assoc Name Addr
 204              -> (TiHeap, Addr)
 205  instantiate expr heap env = dispatchCoreExpr
 206      (instantiateVar heap env)
 207      (instantiateNum heap env)
 208      (instantiateConstr heap env)
 209      (instantiateAp heap env)
 210      (instantiateLet heap env)
 211      (instantiateCase heap env)
 212      (instantiateLam heap env)
 213      expr
 214  
 215  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 216  instantiateVar heap env name
 217      = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 218  
 219  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 220  instantiateNum heap env num = hAlloc heap (NNum num)
 221  
 222  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 223  instantiateConstr heap env tag arity = hAlloc heap (NPrim "Constr" (primConstr tag arity))
 224  
 225  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 226  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 227      where
 228          (heap1, a1) = instantiate a heap  env
 229          (heap2, a2) = instantiate b heap1 env
 230  
 231  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 232  instantiateLet heap env isrec defs body = instantiate body heap' env'
 233      where
 234          (heap', extraBindings) = mapAccumL instantiateRhs heap defs
 235          env' = extraBindings ++ env
 236          rhsEnv | isrec     = env'
 237                 | otherwise = env
 238          instantiateRhs heap (name, rhs)
 239              = (heap1, (name, addr))
 240              where
 241                  (heap1, addr) = instantiate rhs heap rhsEnv
 242  
 243  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 244  instantiateCase heap env expr alters = error "Cannot instatiate case"
 245  
 246  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 247  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 248  
 249  instantiateAndUpdate :: CoreExpr
 250                       -> Addr
 251                       -> TiHeap
 252                       -> Assoc Name Addr
 253                       -> TiHeap
 254  instantiateAndUpdate expr updAddr heap env = dispatchCoreExpr
 255      (instUpdEVar updAddr heap env)
 256      (instUpdENum updAddr heap env)
 257      (instUpdEConstr updAddr heap env)
 258      (instUpdEAp updAddr heap env)
 259      (instUpdELet updAddr heap env)
 260      (instUpdECase updAddr heap env)
 261      (instUpdELam updAddr heap env)
 262      expr
 263  
 264  instUpdEVar :: Addr
 265              -> TiHeap
 266              -> Assoc Name Addr
 267              -> Name
 268              -> TiHeap
 269  instUpdEVar updAddr heap env v = hUpdate heap updAddr (NInd varAddr)
 270      where
 271          varAddr = aLookup env v (error ("undefined name " ++ show v))
 272  
 273  instUpdENum :: Addr
 274              -> TiHeap
 275              -> Assoc Name Addr
 276              -> Int
 277              -> TiHeap
 278  instUpdENum updAddr heap env n = hUpdate heap updAddr (NNum n)
 279  
 280  instUpdEConstr :: Addr
 281                 -> TiHeap
 282                 -> Assoc Name Addr
 283                 -> Tag
 284                 -> Arity
 285                 -> TiHeap
 286  instUpdEConstr updAddr heap env tag arity
 287      = hUpdate heap updAddr (NPrim "Constr" (primConstr tag arity))
 288  
 289  instUpdEAp :: Addr
 290             -> TiHeap
 291             -> Assoc Name Addr
 292             -> CoreExpr
 293             -> CoreExpr
 294             -> TiHeap
 295  instUpdEAp updAddr heap env e1 e2 = hUpdate heap2 updAddr (NAp a1 a2)
 296      where
 297          (heap1, a1) = instantiate e1 heap  env
 298          (heap2, a2) = instantiate e2 heap1 env
 299  
 300  instUpdELet :: Addr
 301              -> TiHeap
 302              -> Assoc Name Addr
 303              -> IsRec
 304              -> Assoc Name CoreExpr
 305              -> CoreExpr
 306              -> TiHeap
 307  instUpdELet updAddr heap env isrec defs body = instantiateAndUpdate body updAddr heap1 env1
 308      where
 309          (heap1, extraBindings) = mapAccumL instantiateRhs heap defs
 310          env1 = extraBindings ++ env
 311          rhsEnv | isrec     = env1
 312                 | otherwise = env
 313          instantiateRhs heap (name, rhs) = (heap1, (name, addr))
 314              where
 315                  (heap1, addr) = instantiate rhs heap rhsEnv
 316  
 317  instUpdECase :: Addr
 318               -> TiHeap
 319               -> Assoc Name Addr
 320               -> CoreExpr
 321               -> [CoreAlter]
 322               -> TiHeap
 323  instUpdECase updAddr heap env expr alts = error "not implemented"
 324  
 325  instUpdELam :: Addr
 326              -> TiHeap
 327              -> Assoc Name Addr
 328              -> [Name]
 329              -> CoreExpr
 330              -> TiHeap
 331  instUpdELam updAddr heap env vars body = error "not implemented"
 332  
 333  test :: (?sz :: Int, ?th :: Int) => String -> IO ()
 334  test = interact . drive . run 
 335  
 336  -- Gabage Collector (Mark-scan)
 337  
 338  gc :: TiState -> TiState
 339  gc state = case evacuateStack state.heap hInitial state.stack of
 340      (from1, to1, stack1) -> case evacuateDump from state.dump of
 341          (from2, to2, dump1)  -> case markFromGlobals hp2 state.globals of
 342              (from3, to3, globals1) -> state { stack = stack1
 343                                              , heap = scavengenHeap hp3, globals = globals1, stats = incGcCount state.stats }
 344  
 345  -- gc state = state { heap = scanHeap $ fst
 346  --                         $ mapAccumL markFrom state.heap
 347  --                         $ findRoots state 
 348  --                  , stats = incGcCount state.stats
 349  --                  }
 350  
 351  
 352  findStackRoots :: TiStack -> [Addr]
 353  findStackRoots stack = stack.stkItems
 354  
 355  findDumpRoots :: TiDump -> [Addr]
 356  findDumpRoots dump = []
 357  
 358  findGlobalRoots :: TiGlobals -> [Addr]
 359  findGlobalRoots globals = aRange globals
 360  
 361  findRoots :: TiState -> [Addr]
 362  findRoots state = concat
 363      [ findStackRoots state.stack
 364      , findDumpRoots state.dump
 365      , findGlobalRoots state.globals
 366      ]
 367  
 368  evacuateStack :: TiHeap -> TiHeap -> TiStack -> ((TiHeap, TiHeap), TiStack)
 369  evacuateStack from to stack = case mapAccumL evacuateFrom (from, to) stack.stkItems of
 370      (heaps', addrs') -> (heaps', stack { stkItems = addrs'})
 371  
 372  evacuateDump :: TiHeap -> TiHeap -> TiDump -> ((TiHeap, TiHeap), TiDump)
 373  evacuateDump from to dump = undefined
 374  
 375  evacuateGlobals :: TiHeap -> TiHeap -> TiGlobals -> ((TiHeap, TiHeap), TiGlobals)
 376  evacuateGlobals from to globals = undefined
 377  
 378  evacuateFrom :: (TiHeap, TiHeap) -> Addr -> ((TiHeap, TiHeap), Addr)
 379  evacuateFrom (from, to) addr = case hLookup from addr of
 380      node -> dispatchNode
 381          (\ addr1 addr2 -> case evacuateFrom (from, to) addr1 of
 382              ((from1, to1), addr11) -> case evacuateFrom (from1, to1) addr2 of
 383                  ((from2, to2), addr22) -> case hAlloc to2 (NAp addr11 addr22) of
 384                      (to3, addr3) -> case hUpdate from2 addr (NForward addr3) of
 385                          from3 -> ((from3, to3), addr3)
 386          )
 387          (\ sc args e -> case hAlloc to node of
 388              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 389                  from1 -> ((from1, to1), addr1)
 390          )
 391          (\ n -> case hAlloc to node of
 392              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 393                  from1 -> ((from1, to1), addr1)
 394          )
 395          (\ addr1 -> evacuateFrom (from, to) addr1
 396          ) 
 397          (\ name prim -> case hAlloc to node of
 398              (to1, addr1) -> case hUpdate from addr1 (NForward addr1) of
 399                  from1 -> ((from1, to1), addr1)
 400          )
 401          (\ tag args -> case mapAccumL evacuateFrom (from, to) args of
 402              ((from1, to1), args1) -> case hAlloc to1 (NData tag args1) of
 403                  (to2, addr2) -> case hUpdate from1 addr (NForward addr2) of
 404                      from2 -> ((from2, to2), addr2)
 405          )
 406          (\ fwaddr -> ((from, to), fwaddr)
 407          )
 408          node
 409  
 410  scavengeHeap :: TiHeap -> TiHeap -> TiHeap
 411  scavengeHeap from to = undefined
 412  
 413  {-
 414  markFromStack :: TiHeap -> TiStack -> (TiHeap, TiStack)
 415  markFromStack hp stk = case mapAccumL markFrom hp stk.stkItems of
 416      (hp', stk') -> (hp', stk { stkItems = stk'})
 417  
 418  markFromDump :: TiHeap -> TiDump -> (TiHeap, TiDump)
 419  markFromDump hp dump = (hp, dump)
 420  
 421  markFromGlobals :: TiHeap -> TiGlobals -> (TiHeap, TiGlobals)
 422  markFromGlobals hp env = mapAccumL markFrom_ hp env
 423      where
 424          markFrom_ heap (name, addr) = case markFrom heap addr of
 425              (heap', addr') -> (heap', (name, addr'))
 426  
 427  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
 428  markFrom heap addr = case hLookup heap addr of
 429      node -> dispatchNode 
 430              (\ addr1 addr2 -> case markFrom heap addr1 of
 431                  (heap1, addr1') -> case markFrom heap1 addr2 of
 432                      (heap2, addr2')  -> (hUpdate heap2 addr (NMarked (NAp addr1' addr2')), addr))
 433              (\ _ _ _       -> (hUpdate heap addr (NMarked node), addr)) -- NSupercomb
 434              (\ _           -> (hUpdate heap addr (NMarked node), addr)) -- NNum
 435              (\ addr1       -> markFrom heap addr1)                      -- NInd
 436              (\ _ _         -> (hUpdate heap addr (NMarked node), addr)) -- NPrim
 437              (\ tag as      -> case mapAccumL markFrom heap as of
 438                  (heap', as')    -> (hUpdate heap' addr (NMarked (NData tag as')), addr))
 439                                                                          -- NData
 440              (\ _           -> (heap, addr))                             -- NForward
 441              node
 442  
 443  scanHeap :: TiHeap -> TiHeap
 444  scanHeap heap =foldl phi heap heap.assocs
 445      where
 446          phi h (a, node) = case node of
 447              NMarked node1 -> hUpdate h a node1
 448              _             -> hFree h a
 449  -}
[34 of 34] Compiling Template.Mark5cp.Machine ( src/Template/Mark5cp/Machine.hs, interpreted )

src/Template/Mark5cp/Machine.hs:340:47: error:
     Variable not in scope: from :: TiHeap
     Perhaps you meant from1 (line 340)
    |
340 |     (from1, to1, stack1) -> case evacuateDump from state.dump of
    |                                               ^^^^

src/Template/Mark5cp/Machine.hs:341:38: error:
    Variable not in scope:
      markFromGlobals :: t1 -> TiGlobals -> (a2, b2, TiGlobals)
    |
341 |         (from2, to2, dump1)  -> case markFromGlobals hp2 state.globals of
    |                                      ^^^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:341:54: error:
    Variable not in scope: hp2
    |
341 |         (from2, to2, dump1)  -> case markFromGlobals hp2 state.globals of
    |                                                      ^^^

src/Template/Mark5cp/Machine.hs:343:54: error:
     Variable not in scope: scavengenHeap :: t0 -> TiHeap
     Perhaps you meant scavengeHeap (line 411)
    |
343 |                                             , heap = scavengenHeap hp3, globals = globals1, stats = incGcCount state.stats }
    |                                                      ^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:343:68: error:
    Variable not in scope: hp3
    |
343 |                                             , heap = scavengenHeap hp3, globals = globals1, stats = incGcCount state.stats }
    |                                                                    ^^^
Failed, 33 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5cp.Machine
   6      where
   7  
   8  import Data.Bool
   9  import Data.Char
  10  import Data.List
  11  import Data.List.Extra
  12  
  13  import Language
  14  import Heap
  15  import Stack
  16  import Iseq
  17  import Utils
  18  
  19  import Template.Mark5cp.State
  20  import Template.Mark5cp.PPrint
  21  
  22  import Debug.Trace qualified as Deb
  23  
  24  debug :: Bool
  25  debug = True
  26  
  27  trace :: String -> a -> a
  28  trace | debug     = Deb.trace
  29        | otherwise = const id 
  30  
  31  traceShow :: Show a => a -> b -> b
  32  traceShow | debug     = Deb.traceShow
  33            | otherwise = const id
  34  
  35  {- * Mark 5 : Structured data -}
  36  {- | Structure of the implementations -}
  37  
  38  drive :: ([String] -> [String]) -> (String -> String)
  39  drive f = unlines . f . ("" :) . lines
  40  
  41  run :: (?sz :: Int, ?th :: Int) => String -> ([String] -> [String])
  42  run prog inputs
  43      = showResults 
  44      $ eval
  45      $ setControl inputs
  46      $ compile 
  47      $ parse prog
  48  
  49  setControl :: [String] -> TiState -> TiState
  50  setControl ctrl state = state { control = ctrl }
  51  
  52  {- | Compiler -}
  53  
  54  compile :: (?sz :: Int, ?th :: Int) => CoreProgram -> TiState
  55  compile prog = TiState
  56      { control = []
  57      , output  = []
  58      , stack   = initialStack1
  59      , dump    = initialDump
  60      , heap    = initialHeap1
  61      , globals = initialGlobals
  62      , stats   = initialStats
  63      , ruleid  = 0
  64      }
  65      where
  66          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
  67          (initialHeap, initialGlobals) = buildInitialHeap scDefs
  68          initialStack = singletonStack addressOfMain
  69          initialStack1 = singletonStack addr
  70          addressOfMain = aLookup initialGlobals "main" (negate 1)
  71          (heap1, addr1)
  72              | addressOfMain < 0 = (initialHeap, aLookup initialGlobals "pmain" (error "no main and no pmain"))
  73              | otherwise         = case aLookup initialGlobals "Cons" (error "Cons is not defined") of
  74                  addressOfCons    -> case aLookup initialGlobals "Nil" (error "Nil is not defined") of
  75                      addressOfNil   -> case hAlloc initialHeap (NAp addressOfCons addressOfMain) of
  76                          (h, a)       -> hAlloc h (NAp a addressOfNil)
  77          addressOfPrint = aLookup initialGlobals "printList" (error "printList is not defined")
  78          (initialHeap1, addr) = hAlloc heap1 (NAp addressOfPrint addr1)
  79  
  80  extraPreludeDefs :: CoreProgram
  81  extraPreludeDefs = 
  82      [ ("False", [], EConstr 0 0)
  83      , ("True" , [], EConstr 1 0)
  84      , ("not", ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  85                                (EVar "False"))
  86                           (EVar "True"))
  87      , ("and", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  88                                     (EVar "y"))
  89                                (EVar "False"))
  90      , ("or",  ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  91                                     (EVar "True"))
  92                                (EVar "y"))
  93      , ("xor", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  94                                     (EAp (EVar "not") (EVar "y")))
  95                                (EVar "y"))
  96      , ("MkPair", [], EConstr 0 2)
  97      , ("fst", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  98                           (EVar "K"))
  99      , ("snd", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
 100                           (EVar "K1"))
 101      , ("Nil", [], EConstr 0 0)
 102      , ("Cons", [], EConstr 1 2)
 103      , ("head", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 104                                  (EVar "abort"))
 105                             (EVar "K"))
 106      , ("tail", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 107                                  (EVar "abort"))
 108                             (EVar "K1"))
 109      , ("printList", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 110                                       (EVar "stop"))
 111                                  (EVar "printCons"))
 112      , ("printCons", ["h", "t"], EAp (EAp (EVar "print") (EVar "h"))
 113                                      (EAp (EVar "printList") (EVar "t")))
 114      ]
 115  
 116  buildInitialHeap :: ( ?sz :: Int, ?th :: Int ) => [CoreScDefn] -> (TiHeap, TiGlobals)
 117  buildInitialHeap scDefs = (heap2, scAddrs ++ primAddrs)
 118      where
 119          (heap1, scAddrs)   = mapAccumL allocateSc hInitial scDefs
 120          (heap2, primAddrs) = mapAccumL allocatePrim heap1 primitives
 121  
 122  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 123  allocateSc heap scDefn = case scDefn of
 124      (name, args, body) -> (heap', (name, addr))
 125          where
 126              (heap', addr) = hAlloc heap (NSupercomb name args body)
 127  
 128  allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
 129  allocatePrim heap (name, prim) = (heap1, (name, addr))
 130      where
 131          (heap1, addr) = hAlloc heap (NPrim name prim)
 132  
 133  {- | Evaluator -}
 134  
 135  eval :: TiState -> [TiState]
 136  eval state = state : rests
 137      where
 138          rests | tiFinal state = []
 139                | otherwise      = eval $ doAdmin $ doAdminTotalSteps $ step state
 140  
 141  doAdmin :: TiState -> TiState
 142  doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
 143  
 144  step :: TiState -> TiState
 145  step state = case map toLower $ head state.control of
 146      ""                -> state' { control = tail state.control }
 147      "c"               -> state' { control = repeat "" }
 148      s | all isDigit s -> state' { control = replicate (pred $ read s) "" ++ tail state.control }
 149        | otherwise     -> state' { control = tail state.control }
 150    where
 151          state' = dispatchNode 
 152                      apStep
 153                      scStep
 154                      numStep
 155                      indStep
 156                      primStep
 157                      dataStep
 158                      (error "step: NForward node")
 159                      (hLookup state.heap (fst (pop state.stack)))
 160                    $ state
 161  
 162  numStep :: Int -> TiState -> TiState
 163  numStep n state 
 164      | isEmptyStack state.dump = error "numStep: Number applied as a function"
 165      | otherwise = case popAndRestore state.stack state.dump of
 166          (stack1, dump1) -> setRuleId 7 $ state { stack = stack1, dump = dump1 }
 167  
 168  apStep :: Addr -> Addr -> TiState -> TiState
 169  apStep a1 a2 state = case hLookup state.heap a2 of
 170      NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
 171      _       -> setRuleId 1 $ state { stack = push a1 state.stack }
 172      where
 173          (a,_) = pop state.stack
 174  
 175  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 176  scStep name args body state
 177      | state.stack.curDepth < succ argsLen
 178          = error "scStep: too few arguments given"
 179      | otherwise
 180          = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
 181      where
 182          argsLen  = length args
 183          stack1   = discard argsLen state.stack
 184          (root,_) = pop stack1
 185          heap1    = instantiateAndUpdate body root state.heap (bindings ++ state.globals)
 186          bindings = zip args (getargs state.heap state.stack)
 187  
 188  indStep :: Addr -> TiState -> TiState
 189  indStep addr state = setRuleId 4 $ state { stack = push addr (discard 1 state.stack) }
 190  
 191  primStep :: Name -> Primitive -> TiState -> TiState
 192  primStep name prim = prim
 193  
 194  dataStep :: Tag -> [Addr] -> TiState -> TiState
 195  dataStep tag contents state = state { stack = stack1, dump = dump1 }
 196      where
 197          (stack1, dump1) = popAndRestore state.stack state.dump
 198  
 199  {- | Instantiation -}
 200  
 201  instantiate :: CoreExpr
 202              -> TiHeap
 203              -> Assoc Name Addr
 204              -> (TiHeap, Addr)
 205  instantiate expr heap env = dispatchCoreExpr
 206      (instantiateVar heap env)
 207      (instantiateNum heap env)
 208      (instantiateConstr heap env)
 209      (instantiateAp heap env)
 210      (instantiateLet heap env)
 211      (instantiateCase heap env)
 212      (instantiateLam heap env)
 213      expr
 214  
 215  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 216  instantiateVar heap env name
 217      = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 218  
 219  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 220  instantiateNum heap env num = hAlloc heap (NNum num)
 221  
 222  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 223  instantiateConstr heap env tag arity = hAlloc heap (NPrim "Constr" (primConstr tag arity))
 224  
 225  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 226  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 227      where
 228          (heap1, a1) = instantiate a heap  env
 229          (heap2, a2) = instantiate b heap1 env
 230  
 231  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 232  instantiateLet heap env isrec defs body = instantiate body heap' env'
 233      where
 234          (heap', extraBindings) = mapAccumL instantiateRhs heap defs
 235          env' = extraBindings ++ env
 236          rhsEnv | isrec     = env'
 237                 | otherwise = env
 238          instantiateRhs heap (name, rhs)
 239              = (heap1, (name, addr))
 240              where
 241                  (heap1, addr) = instantiate rhs heap rhsEnv
 242  
 243  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 244  instantiateCase heap env expr alters = error "Cannot instatiate case"
 245  
 246  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 247  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 248  
 249  instantiateAndUpdate :: CoreExpr
 250                       -> Addr
 251                       -> TiHeap
 252                       -> Assoc Name Addr
 253                       -> TiHeap
 254  instantiateAndUpdate expr updAddr heap env = dispatchCoreExpr
 255      (instUpdEVar updAddr heap env)
 256      (instUpdENum updAddr heap env)
 257      (instUpdEConstr updAddr heap env)
 258      (instUpdEAp updAddr heap env)
 259      (instUpdELet updAddr heap env)
 260      (instUpdECase updAddr heap env)
 261      (instUpdELam updAddr heap env)
 262      expr
 263  
 264  instUpdEVar :: Addr
 265              -> TiHeap
 266              -> Assoc Name Addr
 267              -> Name
 268              -> TiHeap
 269  instUpdEVar updAddr heap env v = hUpdate heap updAddr (NInd varAddr)
 270      where
 271          varAddr = aLookup env v (error ("undefined name " ++ show v))
 272  
 273  instUpdENum :: Addr
 274              -> TiHeap
 275              -> Assoc Name Addr
 276              -> Int
 277              -> TiHeap
 278  instUpdENum updAddr heap env n = hUpdate heap updAddr (NNum n)
 279  
 280  instUpdEConstr :: Addr
 281                 -> TiHeap
 282                 -> Assoc Name Addr
 283                 -> Tag
 284                 -> Arity
 285                 -> TiHeap
 286  instUpdEConstr updAddr heap env tag arity
 287      = hUpdate heap updAddr (NPrim "Constr" (primConstr tag arity))
 288  
 289  instUpdEAp :: Addr
 290             -> TiHeap
 291             -> Assoc Name Addr
 292             -> CoreExpr
 293             -> CoreExpr
 294             -> TiHeap
 295  instUpdEAp updAddr heap env e1 e2 = hUpdate heap2 updAddr (NAp a1 a2)
 296      where
 297          (heap1, a1) = instantiate e1 heap  env
 298          (heap2, a2) = instantiate e2 heap1 env
 299  
 300  instUpdELet :: Addr
 301              -> TiHeap
 302              -> Assoc Name Addr
 303              -> IsRec
 304              -> Assoc Name CoreExpr
 305              -> CoreExpr
 306              -> TiHeap
 307  instUpdELet updAddr heap env isrec defs body = instantiateAndUpdate body updAddr heap1 env1
 308      where
 309          (heap1, extraBindings) = mapAccumL instantiateRhs heap defs
 310          env1 = extraBindings ++ env
 311          rhsEnv | isrec     = env1
 312                 | otherwise = env
 313          instantiateRhs heap (name, rhs) = (heap1, (name, addr))
 314              where
 315                  (heap1, addr) = instantiate rhs heap rhsEnv
 316  
 317  instUpdECase :: Addr
 318               -> TiHeap
 319               -> Assoc Name Addr
 320               -> CoreExpr
 321               -> [CoreAlter]
 322               -> TiHeap
 323  instUpdECase updAddr heap env expr alts = error "not implemented"
 324  
 325  instUpdELam :: Addr
 326              -> TiHeap
 327              -> Assoc Name Addr
 328              -> [Name]
 329              -> CoreExpr
 330              -> TiHeap
 331  instUpdELam updAddr heap env vars body = error "not implemented"
 332  
 333  test :: (?sz :: Int, ?th :: Int) => String -> IO ()
 334  test = interact . drive . run 
 335  
 336  -- Gabage Collector (Mark-scan)
 337  
 338  gc :: TiState -> TiState
 339  gc state = case evacuateStack state.heap hInitial state.stack of
 340      (from1, to1, stack1) -> case evacuateDump from1 state.dump of
 341          (from2, to2, dump1)  -> case markFromGlobals from2 state.globals of
 342              (from3, to3, globals1) -> state { stack = stack1
 343                                              , heap = scavengenHeap from3 to3
 344                                              , globals = globals1
 345                                              , stats = incGcCount state.stats
 346                                              }
 347  
 348  -- gc state = state { heap = scanHeap $ fst
 349  --                         $ mapAccumL markFrom state.heap
 350  --                         $ findRoots state 
 351  --                  , stats = incGcCount state.stats
 352  --                  }
 353  
 354  
 355  findStackRoots :: TiStack -> [Addr]
 356  findStackRoots stack = stack.stkItems
 357  
 358  findDumpRoots :: TiDump -> [Addr]
 359  findDumpRoots dump = []
 360  
 361  findGlobalRoots :: TiGlobals -> [Addr]
 362  findGlobalRoots globals = aRange globals
 363  
 364  findRoots :: TiState -> [Addr]
 365  findRoots state = concat
 366      [ findStackRoots state.stack
 367      , findDumpRoots state.dump
 368      , findGlobalRoots state.globals
 369      ]
 370  
 371  evacuateStack :: TiHeap -> TiHeap -> TiStack -> ((TiHeap, TiHeap), TiStack)
 372  evacuateStack from to stack = case mapAccumL evacuateFrom (from, to) stack.stkItems of
 373      (heaps', addrs') -> (heaps', stack { stkItems = addrs'})
 374  
 375  evacuateDump :: TiHeap -> TiHeap -> TiDump -> ((TiHeap, TiHeap), TiDump)
 376  evacuateDump from to dump = undefined
 377  
 378  evacuateGlobals :: TiHeap -> TiHeap -> TiGlobals -> ((TiHeap, TiHeap), TiGlobals)
 379  evacuateGlobals from to globals = undefined
 380  
 381  evacuateFrom :: (TiHeap, TiHeap) -> Addr -> ((TiHeap, TiHeap), Addr)
 382  evacuateFrom (from, to) addr = case hLookup from addr of
 383      node -> dispatchNode
 384          (\ addr1 addr2 -> case evacuateFrom (from, to) addr1 of
 385              ((from1, to1), addr11) -> case evacuateFrom (from1, to1) addr2 of
 386                  ((from2, to2), addr22) -> case hAlloc to2 (NAp addr11 addr22) of
 387                      (to3, addr3) -> case hUpdate from2 addr (NForward addr3) of
 388                          from3 -> ((from3, to3), addr3)
 389          )
 390          (\ sc args e -> case hAlloc to node of
 391              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 392                  from1 -> ((from1, to1), addr1)
 393          )
 394          (\ n -> case hAlloc to node of
 395              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 396                  from1 -> ((from1, to1), addr1)
 397          )
 398          (\ addr1 -> evacuateFrom (from, to) addr1
 399          ) 
 400          (\ name prim -> case hAlloc to node of
 401              (to1, addr1) -> case hUpdate from addr1 (NForward addr1) of
 402                  from1 -> ((from1, to1), addr1)
 403          )
 404          (\ tag args -> case mapAccumL evacuateFrom (from, to) args of
 405              ((from1, to1), args1) -> case hAlloc to1 (NData tag args1) of
 406                  (to2, addr2) -> case hUpdate from1 addr (NForward addr2) of
 407                      from2 -> ((from2, to2), addr2)
 408          )
 409          (\ fwaddr -> ((from, to), fwaddr)
 410          )
 411          node
 412  
 413  scavengeHeap :: TiHeap -> TiHeap -> TiHeap
 414  scavengeHeap from to = undefined
 415  
 416  {-
 417  markFromStack :: TiHeap -> TiStack -> (TiHeap, TiStack)
 418  markFromStack hp stk = case mapAccumL markFrom hp stk.stkItems of
 419      (hp', stk') -> (hp', stk { stkItems = stk'})
 420  
 421  markFromDump :: TiHeap -> TiDump -> (TiHeap, TiDump)
 422  markFromDump hp dump = (hp, dump)
 423  
 424  markFromGlobals :: TiHeap -> TiGlobals -> (TiHeap, TiGlobals)
 425  markFromGlobals hp env = mapAccumL markFrom_ hp env
 426      where
 427          markFrom_ heap (name, addr) = case markFrom heap addr of
 428              (heap', addr') -> (heap', (name, addr'))
 429  
 430  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
 431  markFrom heap addr = case hLookup heap addr of
 432      node -> dispatchNode 
 433              (\ addr1 addr2 -> case markFrom heap addr1 of
 434                  (heap1, addr1') -> case markFrom heap1 addr2 of
 435                      (heap2, addr2')  -> (hUpdate heap2 addr (NMarked (NAp addr1' addr2')), addr))
 436              (\ _ _ _       -> (hUpdate heap addr (NMarked node), addr)) -- NSupercomb
 437              (\ _           -> (hUpdate heap addr (NMarked node), addr)) -- NNum
 438              (\ addr1       -> markFrom heap addr1)                      -- NInd
 439              (\ _ _         -> (hUpdate heap addr (NMarked node), addr)) -- NPrim
 440              (\ tag as      -> case mapAccumL markFrom heap as of
 441                  (heap', as')    -> (hUpdate heap' addr (NMarked (NData tag as')), addr))
 442                                                                          -- NData
 443              (\ _           -> (heap, addr))                             -- NForward
 444              node
 445  
 446  scanHeap :: TiHeap -> TiHeap
 447  scanHeap heap =foldl phi heap heap.assocs
 448      where
 449          phi h (a, node) = case node of
 450              NMarked node1 -> hUpdate h a node1
 451              _             -> hFree h a
 452  -}
[34 of 34] Compiling Template.Mark5cp.Machine ( src/Template/Mark5cp/Machine.hs, interpreted )

src/Template/Mark5cp/Machine.hs:341:38: error:
    Variable not in scope:
      markFromGlobals :: t0 -> TiGlobals -> (t1, t2, TiGlobals)
    |
341 |         (from2, to2, dump1)  -> case markFromGlobals from2 state.globals of
    |                                      ^^^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:343:54: error:
     Variable not in scope: scavengenHeap :: t1 -> t2 -> TiHeap
     Perhaps you meant scavengeHeap (line 414)
    |
343 |                                             , heap = scavengenHeap from3 to3
    |                                                      ^^^^^^^^^^^^^
Failed, 33 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5cp.Machine
   6      where
   7  
   8  import Data.Bool
   9  import Data.Char
  10  import Data.List
  11  import Data.List.Extra
  12  
  13  import Language
  14  import Heap
  15  import Stack
  16  import Iseq
  17  import Utils
  18  
  19  import Template.Mark5cp.State
  20  import Template.Mark5cp.PPrint
  21  
  22  import Debug.Trace qualified as Deb
  23  
  24  debug :: Bool
  25  debug = True
  26  
  27  trace :: String -> a -> a
  28  trace | debug     = Deb.trace
  29        | otherwise = const id 
  30  
  31  traceShow :: Show a => a -> b -> b
  32  traceShow | debug     = Deb.traceShow
  33            | otherwise = const id
  34  
  35  {- * Mark 5 : Structured data -}
  36  {- | Structure of the implementations -}
  37  
  38  drive :: ([String] -> [String]) -> (String -> String)
  39  drive f = unlines . f . ("" :) . lines
  40  
  41  run :: (?sz :: Int, ?th :: Int) => String -> ([String] -> [String])
  42  run prog inputs
  43      = showResults 
  44      $ eval
  45      $ setControl inputs
  46      $ compile 
  47      $ parse prog
  48  
  49  setControl :: [String] -> TiState -> TiState
  50  setControl ctrl state = state { control = ctrl }
  51  
  52  {- | Compiler -}
  53  
  54  compile :: (?sz :: Int, ?th :: Int) => CoreProgram -> TiState
  55  compile prog = TiState
  56      { control = []
  57      , output  = []
  58      , stack   = initialStack1
  59      , dump    = initialDump
  60      , heap    = initialHeap1
  61      , globals = initialGlobals
  62      , stats   = initialStats
  63      , ruleid  = 0
  64      }
  65      where
  66          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
  67          (initialHeap, initialGlobals) = buildInitialHeap scDefs
  68          initialStack = singletonStack addressOfMain
  69          initialStack1 = singletonStack addr
  70          addressOfMain = aLookup initialGlobals "main" (negate 1)
  71          (heap1, addr1)
  72              | addressOfMain < 0 = (initialHeap, aLookup initialGlobals "pmain" (error "no main and no pmain"))
  73              | otherwise         = case aLookup initialGlobals "Cons" (error "Cons is not defined") of
  74                  addressOfCons    -> case aLookup initialGlobals "Nil" (error "Nil is not defined") of
  75                      addressOfNil   -> case hAlloc initialHeap (NAp addressOfCons addressOfMain) of
  76                          (h, a)       -> hAlloc h (NAp a addressOfNil)
  77          addressOfPrint = aLookup initialGlobals "printList" (error "printList is not defined")
  78          (initialHeap1, addr) = hAlloc heap1 (NAp addressOfPrint addr1)
  79  
  80  extraPreludeDefs :: CoreProgram
  81  extraPreludeDefs = 
  82      [ ("False", [], EConstr 0 0)
  83      , ("True" , [], EConstr 1 0)
  84      , ("not", ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  85                                (EVar "False"))
  86                           (EVar "True"))
  87      , ("and", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  88                                     (EVar "y"))
  89                                (EVar "False"))
  90      , ("or",  ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  91                                     (EVar "True"))
  92                                (EVar "y"))
  93      , ("xor", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  94                                     (EAp (EVar "not") (EVar "y")))
  95                                (EVar "y"))
  96      , ("MkPair", [], EConstr 0 2)
  97      , ("fst", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  98                           (EVar "K"))
  99      , ("snd", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
 100                           (EVar "K1"))
 101      , ("Nil", [], EConstr 0 0)
 102      , ("Cons", [], EConstr 1 2)
 103      , ("head", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 104                                  (EVar "abort"))
 105                             (EVar "K"))
 106      , ("tail", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 107                                  (EVar "abort"))
 108                             (EVar "K1"))
 109      , ("printList", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 110                                       (EVar "stop"))
 111                                  (EVar "printCons"))
 112      , ("printCons", ["h", "t"], EAp (EAp (EVar "print") (EVar "h"))
 113                                      (EAp (EVar "printList") (EVar "t")))
 114      ]
 115  
 116  buildInitialHeap :: ( ?sz :: Int, ?th :: Int ) => [CoreScDefn] -> (TiHeap, TiGlobals)
 117  buildInitialHeap scDefs = (heap2, scAddrs ++ primAddrs)
 118      where
 119          (heap1, scAddrs)   = mapAccumL allocateSc hInitial scDefs
 120          (heap2, primAddrs) = mapAccumL allocatePrim heap1 primitives
 121  
 122  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 123  allocateSc heap scDefn = case scDefn of
 124      (name, args, body) -> (heap', (name, addr))
 125          where
 126              (heap', addr) = hAlloc heap (NSupercomb name args body)
 127  
 128  allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
 129  allocatePrim heap (name, prim) = (heap1, (name, addr))
 130      where
 131          (heap1, addr) = hAlloc heap (NPrim name prim)
 132  
 133  {- | Evaluator -}
 134  
 135  eval :: TiState -> [TiState]
 136  eval state = state : rests
 137      where
 138          rests | tiFinal state = []
 139                | otherwise      = eval $ doAdmin $ doAdminTotalSteps $ step state
 140  
 141  doAdmin :: TiState -> TiState
 142  doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
 143  
 144  step :: TiState -> TiState
 145  step state = case map toLower $ head state.control of
 146      ""                -> state' { control = tail state.control }
 147      "c"               -> state' { control = repeat "" }
 148      s | all isDigit s -> state' { control = replicate (pred $ read s) "" ++ tail state.control }
 149        | otherwise     -> state' { control = tail state.control }
 150    where
 151          state' = dispatchNode 
 152                      apStep
 153                      scStep
 154                      numStep
 155                      indStep
 156                      primStep
 157                      dataStep
 158                      (error "step: NForward node")
 159                      (hLookup state.heap (fst (pop state.stack)))
 160                    $ state
 161  
 162  numStep :: Int -> TiState -> TiState
 163  numStep n state 
 164      | isEmptyStack state.dump = error "numStep: Number applied as a function"
 165      | otherwise = case popAndRestore state.stack state.dump of
 166          (stack1, dump1) -> setRuleId 7 $ state { stack = stack1, dump = dump1 }
 167  
 168  apStep :: Addr -> Addr -> TiState -> TiState
 169  apStep a1 a2 state = case hLookup state.heap a2 of
 170      NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
 171      _       -> setRuleId 1 $ state { stack = push a1 state.stack }
 172      where
 173          (a,_) = pop state.stack
 174  
 175  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 176  scStep name args body state
 177      | state.stack.curDepth < succ argsLen
 178          = error "scStep: too few arguments given"
 179      | otherwise
 180          = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
 181      where
 182          argsLen  = length args
 183          stack1   = discard argsLen state.stack
 184          (root,_) = pop stack1
 185          heap1    = instantiateAndUpdate body root state.heap (bindings ++ state.globals)
 186          bindings = zip args (getargs state.heap state.stack)
 187  
 188  indStep :: Addr -> TiState -> TiState
 189  indStep addr state = setRuleId 4 $ state { stack = push addr (discard 1 state.stack) }
 190  
 191  primStep :: Name -> Primitive -> TiState -> TiState
 192  primStep name prim = prim
 193  
 194  dataStep :: Tag -> [Addr] -> TiState -> TiState
 195  dataStep tag contents state = state { stack = stack1, dump = dump1 }
 196      where
 197          (stack1, dump1) = popAndRestore state.stack state.dump
 198  
 199  {- | Instantiation -}
 200  
 201  instantiate :: CoreExpr
 202              -> TiHeap
 203              -> Assoc Name Addr
 204              -> (TiHeap, Addr)
 205  instantiate expr heap env = dispatchCoreExpr
 206      (instantiateVar heap env)
 207      (instantiateNum heap env)
 208      (instantiateConstr heap env)
 209      (instantiateAp heap env)
 210      (instantiateLet heap env)
 211      (instantiateCase heap env)
 212      (instantiateLam heap env)
 213      expr
 214  
 215  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 216  instantiateVar heap env name
 217      = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 218  
 219  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 220  instantiateNum heap env num = hAlloc heap (NNum num)
 221  
 222  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 223  instantiateConstr heap env tag arity = hAlloc heap (NPrim "Constr" (primConstr tag arity))
 224  
 225  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 226  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 227      where
 228          (heap1, a1) = instantiate a heap  env
 229          (heap2, a2) = instantiate b heap1 env
 230  
 231  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 232  instantiateLet heap env isrec defs body = instantiate body heap' env'
 233      where
 234          (heap', extraBindings) = mapAccumL instantiateRhs heap defs
 235          env' = extraBindings ++ env
 236          rhsEnv | isrec     = env'
 237                 | otherwise = env
 238          instantiateRhs heap (name, rhs)
 239              = (heap1, (name, addr))
 240              where
 241                  (heap1, addr) = instantiate rhs heap rhsEnv
 242  
 243  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 244  instantiateCase heap env expr alters = error "Cannot instatiate case"
 245  
 246  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 247  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 248  
 249  instantiateAndUpdate :: CoreExpr
 250                       -> Addr
 251                       -> TiHeap
 252                       -> Assoc Name Addr
 253                       -> TiHeap
 254  instantiateAndUpdate expr updAddr heap env = dispatchCoreExpr
 255      (instUpdEVar updAddr heap env)
 256      (instUpdENum updAddr heap env)
 257      (instUpdEConstr updAddr heap env)
 258      (instUpdEAp updAddr heap env)
 259      (instUpdELet updAddr heap env)
 260      (instUpdECase updAddr heap env)
 261      (instUpdELam updAddr heap env)
 262      expr
 263  
 264  instUpdEVar :: Addr
 265              -> TiHeap
 266              -> Assoc Name Addr
 267              -> Name
 268              -> TiHeap
 269  instUpdEVar updAddr heap env v = hUpdate heap updAddr (NInd varAddr)
 270      where
 271          varAddr = aLookup env v (error ("undefined name " ++ show v))
 272  
 273  instUpdENum :: Addr
 274              -> TiHeap
 275              -> Assoc Name Addr
 276              -> Int
 277              -> TiHeap
 278  instUpdENum updAddr heap env n = hUpdate heap updAddr (NNum n)
 279  
 280  instUpdEConstr :: Addr
 281                 -> TiHeap
 282                 -> Assoc Name Addr
 283                 -> Tag
 284                 -> Arity
 285                 -> TiHeap
 286  instUpdEConstr updAddr heap env tag arity
 287      = hUpdate heap updAddr (NPrim "Constr" (primConstr tag arity))
 288  
 289  instUpdEAp :: Addr
 290             -> TiHeap
 291             -> Assoc Name Addr
 292             -> CoreExpr
 293             -> CoreExpr
 294             -> TiHeap
 295  instUpdEAp updAddr heap env e1 e2 = hUpdate heap2 updAddr (NAp a1 a2)
 296      where
 297          (heap1, a1) = instantiate e1 heap  env
 298          (heap2, a2) = instantiate e2 heap1 env
 299  
 300  instUpdELet :: Addr
 301              -> TiHeap
 302              -> Assoc Name Addr
 303              -> IsRec
 304              -> Assoc Name CoreExpr
 305              -> CoreExpr
 306              -> TiHeap
 307  instUpdELet updAddr heap env isrec defs body = instantiateAndUpdate body updAddr heap1 env1
 308      where
 309          (heap1, extraBindings) = mapAccumL instantiateRhs heap defs
 310          env1 = extraBindings ++ env
 311          rhsEnv | isrec     = env1
 312                 | otherwise = env
 313          instantiateRhs heap (name, rhs) = (heap1, (name, addr))
 314              where
 315                  (heap1, addr) = instantiate rhs heap rhsEnv
 316  
 317  instUpdECase :: Addr
 318               -> TiHeap
 319               -> Assoc Name Addr
 320               -> CoreExpr
 321               -> [CoreAlter]
 322               -> TiHeap
 323  instUpdECase updAddr heap env expr alts = error "not implemented"
 324  
 325  instUpdELam :: Addr
 326              -> TiHeap
 327              -> Assoc Name Addr
 328              -> [Name]
 329              -> CoreExpr
 330              -> TiHeap
 331  instUpdELam updAddr heap env vars body = error "not implemented"
 332  
 333  test :: (?sz :: Int, ?th :: Int) => String -> IO ()
 334  test = interact . drive . run 
 335  
 336  -- Gabage Collector (Mark-scan)
 337  
 338  gc :: TiState -> TiState
 339  gc state = case evacuateStack state.heap hInitial state.stack of
 340      (from1, to1, stack1) -> case evacuateDump from1 state.dump of
 341          (from2, to2, dump1)  -> case evacuateGlobals from2 state.globals of
 342              (from3, to3, globals1) -> state { stack = stack1
 343                                              , heap = scavengenHeap from3 to3
 344                                              , globals = globals1
 345                                              , stats = incGcCount state.stats
 346                                              }
 347  
 348  -- gc state = state { heap = scanHeap $ fst
 349  --                         $ mapAccumL markFrom state.heap
 350  --                         $ findRoots state 
 351  --                  , stats = incGcCount state.stats
 352  --                  }
 353  
 354  
 355  findStackRoots :: TiStack -> [Addr]
 356  findStackRoots stack = stack.stkItems
 357  
 358  findDumpRoots :: TiDump -> [Addr]
 359  findDumpRoots dump = []
 360  
 361  findGlobalRoots :: TiGlobals -> [Addr]
 362  findGlobalRoots globals = aRange globals
 363  
 364  findRoots :: TiState -> [Addr]
 365  findRoots state = concat
 366      [ findStackRoots state.stack
 367      , findDumpRoots state.dump
 368      , findGlobalRoots state.globals
 369      ]
 370  
 371  evacuateStack :: TiHeap -> TiHeap -> TiStack -> ((TiHeap, TiHeap), TiStack)
 372  evacuateStack from to stack = case mapAccumL evacuateFrom (from, to) stack.stkItems of
 373      (heaps', addrs') -> (heaps', stack { stkItems = addrs'})
 374  
 375  evacuateDump :: TiHeap -> TiHeap -> TiDump -> ((TiHeap, TiHeap), TiDump)
 376  evacuateDump from to dump = undefined
 377  
 378  evacuateGlobals :: TiHeap -> TiHeap -> TiGlobals -> ((TiHeap, TiHeap), TiGlobals)
 379  evacuateGlobals from to globals = undefined
 380  
 381  evacuateFrom :: (TiHeap, TiHeap) -> Addr -> ((TiHeap, TiHeap), Addr)
 382  evacuateFrom (from, to) addr = case hLookup from addr of
 383      node -> dispatchNode
 384          (\ addr1 addr2 -> case evacuateFrom (from, to) addr1 of
 385              ((from1, to1), addr11) -> case evacuateFrom (from1, to1) addr2 of
 386                  ((from2, to2), addr22) -> case hAlloc to2 (NAp addr11 addr22) of
 387                      (to3, addr3) -> case hUpdate from2 addr (NForward addr3) of
 388                          from3 -> ((from3, to3), addr3)
 389          )
 390          (\ sc args e -> case hAlloc to node of
 391              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 392                  from1 -> ((from1, to1), addr1)
 393          )
 394          (\ n -> case hAlloc to node of
 395              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 396                  from1 -> ((from1, to1), addr1)
 397          )
 398          (\ addr1 -> evacuateFrom (from, to) addr1
 399          ) 
 400          (\ name prim -> case hAlloc to node of
 401              (to1, addr1) -> case hUpdate from addr1 (NForward addr1) of
 402                  from1 -> ((from1, to1), addr1)
 403          )
 404          (\ tag args -> case mapAccumL evacuateFrom (from, to) args of
 405              ((from1, to1), args1) -> case hAlloc to1 (NData tag args1) of
 406                  (to2, addr2) -> case hUpdate from1 addr (NForward addr2) of
 407                      from2 -> ((from2, to2), addr2)
 408          )
 409          (\ fwaddr -> ((from, to), fwaddr)
 410          )
 411          node
 412  
 413  scavengeHeap :: TiHeap -> TiHeap -> TiHeap
 414  scavengeHeap from to = undefined
 415  
 416  {-
 417  markFromStack :: TiHeap -> TiStack -> (TiHeap, TiStack)
 418  markFromStack hp stk = case mapAccumL markFrom hp stk.stkItems of
 419      (hp', stk') -> (hp', stk { stkItems = stk'})
 420  
 421  markFromDump :: TiHeap -> TiDump -> (TiHeap, TiDump)
 422  markFromDump hp dump = (hp, dump)
 423  
 424  markFromGlobals :: TiHeap -> TiGlobals -> (TiHeap, TiGlobals)
 425  markFromGlobals hp env = mapAccumL markFrom_ hp env
 426      where
 427          markFrom_ heap (name, addr) = case markFrom heap addr of
 428              (heap', addr') -> (heap', (name, addr'))
 429  
 430  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
 431  markFrom heap addr = case hLookup heap addr of
 432      node -> dispatchNode 
 433              (\ addr1 addr2 -> case markFrom heap addr1 of
 434                  (heap1, addr1') -> case markFrom heap1 addr2 of
 435                      (heap2, addr2')  -> (hUpdate heap2 addr (NMarked (NAp addr1' addr2')), addr))
 436              (\ _ _ _       -> (hUpdate heap addr (NMarked node), addr)) -- NSupercomb
 437              (\ _           -> (hUpdate heap addr (NMarked node), addr)) -- NNum
 438              (\ addr1       -> markFrom heap addr1)                      -- NInd
 439              (\ _ _         -> (hUpdate heap addr (NMarked node), addr)) -- NPrim
 440              (\ tag as      -> case mapAccumL markFrom heap as of
 441                  (heap', as')    -> (hUpdate heap' addr (NMarked (NData tag as')), addr))
 442                                                                          -- NData
 443              (\ _           -> (heap, addr))                             -- NForward
 444              node
 445  
 446  scanHeap :: TiHeap -> TiHeap
 447  scanHeap heap =foldl phi heap heap.assocs
 448      where
 449          phi h (a, node) = case node of
 450              NMarked node1 -> hUpdate h a node1
 451              _             -> hFree h a
 452  -}
[34 of 34] Compiling Template.Mark5cp.Machine ( src/Template/Mark5cp/Machine.hs, interpreted )

src/Template/Mark5cp/Machine.hs:343:54: error:
     Variable not in scope: scavengenHeap :: t0 -> t1 -> TiHeap
     Perhaps you meant scavengeHeap (line 414)
    |
343 |                                             , heap = scavengenHeap from3 to3
    |                                                      ^^^^^^^^^^^^^
Failed, 33 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5cp.Machine
   6      where
   7  
   8  import Data.Bool
   9  import Data.Char
  10  import Data.List
  11  import Data.List.Extra
  12  
  13  import Language
  14  import Heap
  15  import Stack
  16  import Iseq
  17  import Utils
  18  
  19  import Template.Mark5cp.State
  20  import Template.Mark5cp.PPrint
  21  
  22  import Debug.Trace qualified as Deb
  23  
  24  debug :: Bool
  25  debug = True
  26  
  27  trace :: String -> a -> a
  28  trace | debug     = Deb.trace
  29        | otherwise = const id 
  30  
  31  traceShow :: Show a => a -> b -> b
  32  traceShow | debug     = Deb.traceShow
  33            | otherwise = const id
  34  
  35  {- * Mark 5 : Structured data -}
  36  {- | Structure of the implementations -}
  37  
  38  drive :: ([String] -> [String]) -> (String -> String)
  39  drive f = unlines . f . ("" :) . lines
  40  
  41  run :: (?sz :: Int, ?th :: Int) => String -> ([String] -> [String])
  42  run prog inputs
  43      = showResults 
  44      $ eval
  45      $ setControl inputs
  46      $ compile 
  47      $ parse prog
  48  
  49  setControl :: [String] -> TiState -> TiState
  50  setControl ctrl state = state { control = ctrl }
  51  
  52  {- | Compiler -}
  53  
  54  compile :: (?sz :: Int, ?th :: Int) => CoreProgram -> TiState
  55  compile prog = TiState
  56      { control = []
  57      , output  = []
  58      , stack   = initialStack1
  59      , dump    = initialDump
  60      , heap    = initialHeap1
  61      , globals = initialGlobals
  62      , stats   = initialStats
  63      , ruleid  = 0
  64      }
  65      where
  66          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
  67          (initialHeap, initialGlobals) = buildInitialHeap scDefs
  68          initialStack = singletonStack addressOfMain
  69          initialStack1 = singletonStack addr
  70          addressOfMain = aLookup initialGlobals "main" (negate 1)
  71          (heap1, addr1)
  72              | addressOfMain < 0 = (initialHeap, aLookup initialGlobals "pmain" (error "no main and no pmain"))
  73              | otherwise         = case aLookup initialGlobals "Cons" (error "Cons is not defined") of
  74                  addressOfCons    -> case aLookup initialGlobals "Nil" (error "Nil is not defined") of
  75                      addressOfNil   -> case hAlloc initialHeap (NAp addressOfCons addressOfMain) of
  76                          (h, a)       -> hAlloc h (NAp a addressOfNil)
  77          addressOfPrint = aLookup initialGlobals "printList" (error "printList is not defined")
  78          (initialHeap1, addr) = hAlloc heap1 (NAp addressOfPrint addr1)
  79  
  80  extraPreludeDefs :: CoreProgram
  81  extraPreludeDefs = 
  82      [ ("False", [], EConstr 0 0)
  83      , ("True" , [], EConstr 1 0)
  84      , ("not", ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  85                                (EVar "False"))
  86                           (EVar "True"))
  87      , ("and", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  88                                     (EVar "y"))
  89                                (EVar "False"))
  90      , ("or",  ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  91                                     (EVar "True"))
  92                                (EVar "y"))
  93      , ("xor", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  94                                     (EAp (EVar "not") (EVar "y")))
  95                                (EVar "y"))
  96      , ("MkPair", [], EConstr 0 2)
  97      , ("fst", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  98                           (EVar "K"))
  99      , ("snd", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
 100                           (EVar "K1"))
 101      , ("Nil", [], EConstr 0 0)
 102      , ("Cons", [], EConstr 1 2)
 103      , ("head", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 104                                  (EVar "abort"))
 105                             (EVar "K"))
 106      , ("tail", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 107                                  (EVar "abort"))
 108                             (EVar "K1"))
 109      , ("printList", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 110                                       (EVar "stop"))
 111                                  (EVar "printCons"))
 112      , ("printCons", ["h", "t"], EAp (EAp (EVar "print") (EVar "h"))
 113                                      (EAp (EVar "printList") (EVar "t")))
 114      ]
 115  
 116  buildInitialHeap :: ( ?sz :: Int, ?th :: Int ) => [CoreScDefn] -> (TiHeap, TiGlobals)
 117  buildInitialHeap scDefs = (heap2, scAddrs ++ primAddrs)
 118      where
 119          (heap1, scAddrs)   = mapAccumL allocateSc hInitial scDefs
 120          (heap2, primAddrs) = mapAccumL allocatePrim heap1 primitives
 121  
 122  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 123  allocateSc heap scDefn = case scDefn of
 124      (name, args, body) -> (heap', (name, addr))
 125          where
 126              (heap', addr) = hAlloc heap (NSupercomb name args body)
 127  
 128  allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
 129  allocatePrim heap (name, prim) = (heap1, (name, addr))
 130      where
 131          (heap1, addr) = hAlloc heap (NPrim name prim)
 132  
 133  {- | Evaluator -}
 134  
 135  eval :: TiState -> [TiState]
 136  eval state = state : rests
 137      where
 138          rests | tiFinal state = []
 139                | otherwise      = eval $ doAdmin $ doAdminTotalSteps $ step state
 140  
 141  doAdmin :: TiState -> TiState
 142  doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
 143  
 144  step :: TiState -> TiState
 145  step state = case map toLower $ head state.control of
 146      ""                -> state' { control = tail state.control }
 147      "c"               -> state' { control = repeat "" }
 148      s | all isDigit s -> state' { control = replicate (pred $ read s) "" ++ tail state.control }
 149        | otherwise     -> state' { control = tail state.control }
 150    where
 151          state' = dispatchNode 
 152                      apStep
 153                      scStep
 154                      numStep
 155                      indStep
 156                      primStep
 157                      dataStep
 158                      (error "step: NForward node")
 159                      (hLookup state.heap (fst (pop state.stack)))
 160                    $ state
 161  
 162  numStep :: Int -> TiState -> TiState
 163  numStep n state 
 164      | isEmptyStack state.dump = error "numStep: Number applied as a function"
 165      | otherwise = case popAndRestore state.stack state.dump of
 166          (stack1, dump1) -> setRuleId 7 $ state { stack = stack1, dump = dump1 }
 167  
 168  apStep :: Addr -> Addr -> TiState -> TiState
 169  apStep a1 a2 state = case hLookup state.heap a2 of
 170      NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
 171      _       -> setRuleId 1 $ state { stack = push a1 state.stack }
 172      where
 173          (a,_) = pop state.stack
 174  
 175  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 176  scStep name args body state
 177      | state.stack.curDepth < succ argsLen
 178          = error "scStep: too few arguments given"
 179      | otherwise
 180          = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
 181      where
 182          argsLen  = length args
 183          stack1   = discard argsLen state.stack
 184          (root,_) = pop stack1
 185          heap1    = instantiateAndUpdate body root state.heap (bindings ++ state.globals)
 186          bindings = zip args (getargs state.heap state.stack)
 187  
 188  indStep :: Addr -> TiState -> TiState
 189  indStep addr state = setRuleId 4 $ state { stack = push addr (discard 1 state.stack) }
 190  
 191  primStep :: Name -> Primitive -> TiState -> TiState
 192  primStep name prim = prim
 193  
 194  dataStep :: Tag -> [Addr] -> TiState -> TiState
 195  dataStep tag contents state = state { stack = stack1, dump = dump1 }
 196      where
 197          (stack1, dump1) = popAndRestore state.stack state.dump
 198  
 199  {- | Instantiation -}
 200  
 201  instantiate :: CoreExpr
 202              -> TiHeap
 203              -> Assoc Name Addr
 204              -> (TiHeap, Addr)
 205  instantiate expr heap env = dispatchCoreExpr
 206      (instantiateVar heap env)
 207      (instantiateNum heap env)
 208      (instantiateConstr heap env)
 209      (instantiateAp heap env)
 210      (instantiateLet heap env)
 211      (instantiateCase heap env)
 212      (instantiateLam heap env)
 213      expr
 214  
 215  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 216  instantiateVar heap env name
 217      = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 218  
 219  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 220  instantiateNum heap env num = hAlloc heap (NNum num)
 221  
 222  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 223  instantiateConstr heap env tag arity = hAlloc heap (NPrim "Constr" (primConstr tag arity))
 224  
 225  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 226  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 227      where
 228          (heap1, a1) = instantiate a heap  env
 229          (heap2, a2) = instantiate b heap1 env
 230  
 231  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 232  instantiateLet heap env isrec defs body = instantiate body heap' env'
 233      where
 234          (heap', extraBindings) = mapAccumL instantiateRhs heap defs
 235          env' = extraBindings ++ env
 236          rhsEnv | isrec     = env'
 237                 | otherwise = env
 238          instantiateRhs heap (name, rhs)
 239              = (heap1, (name, addr))
 240              where
 241                  (heap1, addr) = instantiate rhs heap rhsEnv
 242  
 243  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 244  instantiateCase heap env expr alters = error "Cannot instatiate case"
 245  
 246  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 247  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 248  
 249  instantiateAndUpdate :: CoreExpr
 250                       -> Addr
 251                       -> TiHeap
 252                       -> Assoc Name Addr
 253                       -> TiHeap
 254  instantiateAndUpdate expr updAddr heap env = dispatchCoreExpr
 255      (instUpdEVar updAddr heap env)
 256      (instUpdENum updAddr heap env)
 257      (instUpdEConstr updAddr heap env)
 258      (instUpdEAp updAddr heap env)
 259      (instUpdELet updAddr heap env)
 260      (instUpdECase updAddr heap env)
 261      (instUpdELam updAddr heap env)
 262      expr
 263  
 264  instUpdEVar :: Addr
 265              -> TiHeap
 266              -> Assoc Name Addr
 267              -> Name
 268              -> TiHeap
 269  instUpdEVar updAddr heap env v = hUpdate heap updAddr (NInd varAddr)
 270      where
 271          varAddr = aLookup env v (error ("undefined name " ++ show v))
 272  
 273  instUpdENum :: Addr
 274              -> TiHeap
 275              -> Assoc Name Addr
 276              -> Int
 277              -> TiHeap
 278  instUpdENum updAddr heap env n = hUpdate heap updAddr (NNum n)
 279  
 280  instUpdEConstr :: Addr
 281                 -> TiHeap
 282                 -> Assoc Name Addr
 283                 -> Tag
 284                 -> Arity
 285                 -> TiHeap
 286  instUpdEConstr updAddr heap env tag arity
 287      = hUpdate heap updAddr (NPrim "Constr" (primConstr tag arity))
 288  
 289  instUpdEAp :: Addr
 290             -> TiHeap
 291             -> Assoc Name Addr
 292             -> CoreExpr
 293             -> CoreExpr
 294             -> TiHeap
 295  instUpdEAp updAddr heap env e1 e2 = hUpdate heap2 updAddr (NAp a1 a2)
 296      where
 297          (heap1, a1) = instantiate e1 heap  env
 298          (heap2, a2) = instantiate e2 heap1 env
 299  
 300  instUpdELet :: Addr
 301              -> TiHeap
 302              -> Assoc Name Addr
 303              -> IsRec
 304              -> Assoc Name CoreExpr
 305              -> CoreExpr
 306              -> TiHeap
 307  instUpdELet updAddr heap env isrec defs body = instantiateAndUpdate body updAddr heap1 env1
 308      where
 309          (heap1, extraBindings) = mapAccumL instantiateRhs heap defs
 310          env1 = extraBindings ++ env
 311          rhsEnv | isrec     = env1
 312                 | otherwise = env
 313          instantiateRhs heap (name, rhs) = (heap1, (name, addr))
 314              where
 315                  (heap1, addr) = instantiate rhs heap rhsEnv
 316  
 317  instUpdECase :: Addr
 318               -> TiHeap
 319               -> Assoc Name Addr
 320               -> CoreExpr
 321               -> [CoreAlter]
 322               -> TiHeap
 323  instUpdECase updAddr heap env expr alts = error "not implemented"
 324  
 325  instUpdELam :: Addr
 326              -> TiHeap
 327              -> Assoc Name Addr
 328              -> [Name]
 329              -> CoreExpr
 330              -> TiHeap
 331  instUpdELam updAddr heap env vars body = error "not implemented"
 332  
 333  test :: (?sz :: Int, ?th :: Int) => String -> IO ()
 334  test = interact . drive . run 
 335  
 336  -- Gabage Collector (Mark-scan)
 337  
 338  gc :: TiState -> TiState
 339  gc state = case evacuateStack state.heap hInitial state.stack of
 340      (from1, to1, stack1) -> case evacuateDump from1 state.dump of
 341          (from2, to2, dump1)  -> case evacuateGlobals from2 state.globals of
 342              (from3, to3, globals1) -> state { stack = stack1
 343                                              , heap = scavengeHeap from3 to3
 344                                              , globals = globals1
 345                                              , stats = incGcCount state.stats
 346                                              }
 347  
 348  -- gc state = state { heap = scanHeap $ fst
 349  --                         $ mapAccumL markFrom state.heap
 350  --                         $ findRoots state 
 351  --                  , stats = incGcCount state.stats
 352  --                  }
 353  
 354  
 355  findStackRoots :: TiStack -> [Addr]
 356  findStackRoots stack = stack.stkItems
 357  
 358  findDumpRoots :: TiDump -> [Addr]
 359  findDumpRoots dump = []
 360  
 361  findGlobalRoots :: TiGlobals -> [Addr]
 362  findGlobalRoots globals = aRange globals
 363  
 364  findRoots :: TiState -> [Addr]
 365  findRoots state = concat
 366      [ findStackRoots state.stack
 367      , findDumpRoots state.dump
 368      , findGlobalRoots state.globals
 369      ]
 370  
 371  evacuateStack :: TiHeap -> TiHeap -> TiStack -> ((TiHeap, TiHeap), TiStack)
 372  evacuateStack from to stack = case mapAccumL evacuateFrom (from, to) stack.stkItems of
 373      (heaps', addrs') -> (heaps', stack { stkItems = addrs'})
 374  
 375  evacuateDump :: TiHeap -> TiHeap -> TiDump -> ((TiHeap, TiHeap), TiDump)
 376  evacuateDump from to dump = undefined
 377  
 378  evacuateGlobals :: TiHeap -> TiHeap -> TiGlobals -> ((TiHeap, TiHeap), TiGlobals)
 379  evacuateGlobals from to globals = undefined
 380  
 381  evacuateFrom :: (TiHeap, TiHeap) -> Addr -> ((TiHeap, TiHeap), Addr)
 382  evacuateFrom (from, to) addr = case hLookup from addr of
 383      node -> dispatchNode
 384          (\ addr1 addr2 -> case evacuateFrom (from, to) addr1 of
 385              ((from1, to1), addr11) -> case evacuateFrom (from1, to1) addr2 of
 386                  ((from2, to2), addr22) -> case hAlloc to2 (NAp addr11 addr22) of
 387                      (to3, addr3) -> case hUpdate from2 addr (NForward addr3) of
 388                          from3 -> ((from3, to3), addr3)
 389          )
 390          (\ sc args e -> case hAlloc to node of
 391              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 392                  from1 -> ((from1, to1), addr1)
 393          )
 394          (\ n -> case hAlloc to node of
 395              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 396                  from1 -> ((from1, to1), addr1)
 397          )
 398          (\ addr1 -> evacuateFrom (from, to) addr1
 399          ) 
 400          (\ name prim -> case hAlloc to node of
 401              (to1, addr1) -> case hUpdate from addr1 (NForward addr1) of
 402                  from1 -> ((from1, to1), addr1)
 403          )
 404          (\ tag args -> case mapAccumL evacuateFrom (from, to) args of
 405              ((from1, to1), args1) -> case hAlloc to1 (NData tag args1) of
 406                  (to2, addr2) -> case hUpdate from1 addr (NForward addr2) of
 407                      from2 -> ((from2, to2), addr2)
 408          )
 409          (\ fwaddr -> ((from, to), fwaddr)
 410          )
 411          node
 412  
 413  scavengeHeap :: TiHeap -> TiHeap -> TiHeap
 414  scavengeHeap from to = undefined
 415  
 416  {-
 417  markFromStack :: TiHeap -> TiStack -> (TiHeap, TiStack)
 418  markFromStack hp stk = case mapAccumL markFrom hp stk.stkItems of
 419      (hp', stk') -> (hp', stk { stkItems = stk'})
 420  
 421  markFromDump :: TiHeap -> TiDump -> (TiHeap, TiDump)
 422  markFromDump hp dump = (hp, dump)
 423  
 424  markFromGlobals :: TiHeap -> TiGlobals -> (TiHeap, TiGlobals)
 425  markFromGlobals hp env = mapAccumL markFrom_ hp env
 426      where
 427          markFrom_ heap (name, addr) = case markFrom heap addr of
 428              (heap', addr') -> (heap', (name, addr'))
 429  
 430  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
 431  markFrom heap addr = case hLookup heap addr of
 432      node -> dispatchNode 
 433              (\ addr1 addr2 -> case markFrom heap addr1 of
 434                  (heap1, addr1') -> case markFrom heap1 addr2 of
 435                      (heap2, addr2')  -> (hUpdate heap2 addr (NMarked (NAp addr1' addr2')), addr))
 436              (\ _ _ _       -> (hUpdate heap addr (NMarked node), addr)) -- NSupercomb
 437              (\ _           -> (hUpdate heap addr (NMarked node), addr)) -- NNum
 438              (\ addr1       -> markFrom heap addr1)                      -- NInd
 439              (\ _ _         -> (hUpdate heap addr (NMarked node), addr)) -- NPrim
 440              (\ tag as      -> case mapAccumL markFrom heap as of
 441                  (heap', as')    -> (hUpdate heap' addr (NMarked (NData tag as')), addr))
 442                                                                          -- NData
 443              (\ _           -> (heap, addr))                             -- NForward
 444              node
 445  
 446  scanHeap :: TiHeap -> TiHeap
 447  scanHeap heap =foldl phi heap heap.assocs
 448      where
 449          phi h (a, node) = case node of
 450              NMarked node1 -> hUpdate h a node1
 451              _             -> hFree h a
 452  -}
[34 of 34] Compiling Template.Mark5cp.Machine ( src/Template/Mark5cp/Machine.hs, interpreted )

src/Template/Mark5cp/Machine.hs:340:5: error:
     Couldn't match expected type: ((TiHeap, TiHeap), TiStack)
                  with actual type: (TiHeap, b0, TiStack)
     In the pattern: (from1, to1, stack1)
      In a case alternative:
          (from1, to1, stack1)
            -> case evacuateDump from1 state.dump of
                 (from2, to2, dump1)
                   -> case evacuateGlobals from2 ... of (from3, to3, globals1) -> ...
      In the expression:
        case evacuateStack state.heap hInitial state.stack of
          (from1, to1, stack1)
            -> case evacuateDump from1 state.dump of
                 (from2, to2, dump1)
                   -> case evacuateGlobals from2 ... of (from3, to3, globals1) -> ...
    |
340 |     (from1, to1, stack1) -> case evacuateDump from1 state.dump of
    |     ^^^^^^^^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:340:53: error:
     Couldn't match type: Stack Int
                     with: Heap Node
        arising from selecting the field dump
     In the second argument of evacuateDump, namely state.dump
      In the expression: evacuateDump from1 state.dump
      In the expression:
        case evacuateDump from1 state.dump of
          (from2, to2, dump1)
            -> case evacuateGlobals from2 state.globals of
                 (from3, to3, globals1)
                   -> state
                        {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                         stats = incGcCount ...}
    |
340 |     (from1, to1, stack1) -> case evacuateDump from1 state.dump of
    |                                                     ^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:341:9: error:
     Couldn't match expected type: TiDump
                                    -> ((TiHeap, TiHeap), TiDump)
                  with actual type: (TiHeap, b1, c0)
     In the pattern: (from2, to2, dump1)
      In a case alternative:
          (from2, to2, dump1)
            -> case evacuateGlobals from2 state.globals of
                 (from3, to3, globals1)
                   -> state
                        {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                         stats = incGcCount ...}
      In the expression:
        case evacuateDump from1 state.dump of
          (from2, to2, dump1)
            -> case evacuateGlobals from2 state.globals of
                 (from3, to3, globals1)
                   -> state
                        {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                         stats = incGcCount ...}
    |
341 |         (from2, to2, dump1)  -> case evacuateGlobals from2 state.globals of
    |         ^^^^^^^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:341:60: error:
     Couldn't match type: [(Name, Addr)]
                     with: Heap Node
        arising from selecting the field globals
     In the second argument of evacuateGlobals, namely
        state.globals
      In the expression: evacuateGlobals from2 state.globals
      In the expression:
        case evacuateGlobals from2 state.globals of
          (from3, to3, globals1)
            -> state
                 {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                  stats = incGcCount state.stats}
    |
341 |         (from2, to2, dump1)  -> case evacuateGlobals from2 state.globals of
    |                                                            ^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:342:13: error:
     Couldn't match expected type: TiGlobals
                                    -> ((TiHeap, TiHeap), TiGlobals)
                  with actual type: (TiHeap, TiHeap, TiGlobals)
     In the pattern: (from3, to3, globals1)
      In a case alternative:
          (from3, to3, globals1)
            -> state
                 {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                  stats = incGcCount state.stats}
      In the expression:
        case evacuateGlobals from2 state.globals of
          (from3, to3, globals1)
            -> state
                 {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                  stats = incGcCount state.stats}
    |
342 |             (from3, to3, globals1) -> state { stack = stack1
    |             ^^^^^^^^^^^^^^^^^^^^^^
Failed, 33 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5cp.Machine
   6      where
   7  
   8  import Data.Bool
   9  import Data.Char
  10  import Data.List
  11  import Data.List.Extra
  12  
  13  import Language
  14  import Heap
  15  import Stack
  16  import Iseq
  17  import Utils
  18  
  19  import Template.Mark5cp.State
  20  import Template.Mark5cp.PPrint
  21  
  22  import Debug.Trace qualified as Deb
  23  
  24  debug :: Bool
  25  debug = True
  26  
  27  trace :: String -> a -> a
  28  trace | debug     = Deb.trace
  29        | otherwise = const id 
  30  
  31  traceShow :: Show a => a -> b -> b
  32  traceShow | debug     = Deb.traceShow
  33            | otherwise = const id
  34  
  35  {- * Mark 5 : Structured data -}
  36  {- | Structure of the implementations -}
  37  
  38  drive :: ([String] -> [String]) -> (String -> String)
  39  drive f = unlines . f . ("" :) . lines
  40  
  41  run :: (?sz :: Int, ?th :: Int) => String -> ([String] -> [String])
  42  run prog inputs
  43      = showResults 
  44      $ eval
  45      $ setControl inputs
  46      $ compile 
  47      $ parse prog
  48  
  49  setControl :: [String] -> TiState -> TiState
  50  setControl ctrl state = state { control = ctrl }
  51  
  52  {- | Compiler -}
  53  
  54  compile :: (?sz :: Int, ?th :: Int) => CoreProgram -> TiState
  55  compile prog = TiState
  56      { control = []
  57      , output  = []
  58      , stack   = initialStack1
  59      , dump    = initialDump
  60      , heap    = initialHeap1
  61      , globals = initialGlobals
  62      , stats   = initialStats
  63      , ruleid  = 0
  64      }
  65      where
  66          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
  67          (initialHeap, initialGlobals) = buildInitialHeap scDefs
  68          initialStack = singletonStack addressOfMain
  69          initialStack1 = singletonStack addr
  70          addressOfMain = aLookup initialGlobals "main" (negate 1)
  71          (heap1, addr1)
  72              | addressOfMain < 0 = (initialHeap, aLookup initialGlobals "pmain" (error "no main and no pmain"))
  73              | otherwise         = case aLookup initialGlobals "Cons" (error "Cons is not defined") of
  74                  addressOfCons    -> case aLookup initialGlobals "Nil" (error "Nil is not defined") of
  75                      addressOfNil   -> case hAlloc initialHeap (NAp addressOfCons addressOfMain) of
  76                          (h, a)       -> hAlloc h (NAp a addressOfNil)
  77          addressOfPrint = aLookup initialGlobals "printList" (error "printList is not defined")
  78          (initialHeap1, addr) = hAlloc heap1 (NAp addressOfPrint addr1)
  79  
  80  extraPreludeDefs :: CoreProgram
  81  extraPreludeDefs = 
  82      [ ("False", [], EConstr 0 0)
  83      , ("True" , [], EConstr 1 0)
  84      , ("not", ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  85                                (EVar "False"))
  86                           (EVar "True"))
  87      , ("and", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  88                                     (EVar "y"))
  89                                (EVar "False"))
  90      , ("or",  ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  91                                     (EVar "True"))
  92                                (EVar "y"))
  93      , ("xor", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  94                                     (EAp (EVar "not") (EVar "y")))
  95                                (EVar "y"))
  96      , ("MkPair", [], EConstr 0 2)
  97      , ("fst", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  98                           (EVar "K"))
  99      , ("snd", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
 100                           (EVar "K1"))
 101      , ("Nil", [], EConstr 0 0)
 102      , ("Cons", [], EConstr 1 2)
 103      , ("head", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 104                                  (EVar "abort"))
 105                             (EVar "K"))
 106      , ("tail", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 107                                  (EVar "abort"))
 108                             (EVar "K1"))
 109      , ("printList", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 110                                       (EVar "stop"))
 111                                  (EVar "printCons"))
 112      , ("printCons", ["h", "t"], EAp (EAp (EVar "print") (EVar "h"))
 113                                      (EAp (EVar "printList") (EVar "t")))
 114      ]
 115  
 116  buildInitialHeap :: ( ?sz :: Int, ?th :: Int ) => [CoreScDefn] -> (TiHeap, TiGlobals)
 117  buildInitialHeap scDefs = (heap2, scAddrs ++ primAddrs)
 118      where
 119          (heap1, scAddrs)   = mapAccumL allocateSc hInitial scDefs
 120          (heap2, primAddrs) = mapAccumL allocatePrim heap1 primitives
 121  
 122  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 123  allocateSc heap scDefn = case scDefn of
 124      (name, args, body) -> (heap', (name, addr))
 125          where
 126              (heap', addr) = hAlloc heap (NSupercomb name args body)
 127  
 128  allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
 129  allocatePrim heap (name, prim) = (heap1, (name, addr))
 130      where
 131          (heap1, addr) = hAlloc heap (NPrim name prim)
 132  
 133  {- | Evaluator -}
 134  
 135  eval :: TiState -> [TiState]
 136  eval state = state : rests
 137      where
 138          rests | tiFinal state = []
 139                | otherwise      = eval $ doAdmin $ doAdminTotalSteps $ step state
 140  
 141  doAdmin :: TiState -> TiState
 142  doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
 143  
 144  step :: TiState -> TiState
 145  step state = case map toLower $ head state.control of
 146      ""                -> state' { control = tail state.control }
 147      "c"               -> state' { control = repeat "" }
 148      s | all isDigit s -> state' { control = replicate (pred $ read s) "" ++ tail state.control }
 149        | otherwise     -> state' { control = tail state.control }
 150    where
 151          state' = dispatchNode 
 152                      apStep
 153                      scStep
 154                      numStep
 155                      indStep
 156                      primStep
 157                      dataStep
 158                      (error "step: NForward node")
 159                      (hLookup state.heap (fst (pop state.stack)))
 160                    $ state
 161  
 162  numStep :: Int -> TiState -> TiState
 163  numStep n state 
 164      | isEmptyStack state.dump = error "numStep: Number applied as a function"
 165      | otherwise = case popAndRestore state.stack state.dump of
 166          (stack1, dump1) -> setRuleId 7 $ state { stack = stack1, dump = dump1 }
 167  
 168  apStep :: Addr -> Addr -> TiState -> TiState
 169  apStep a1 a2 state = case hLookup state.heap a2 of
 170      NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
 171      _       -> setRuleId 1 $ state { stack = push a1 state.stack }
 172      where
 173          (a,_) = pop state.stack
 174  
 175  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 176  scStep name args body state
 177      | state.stack.curDepth < succ argsLen
 178          = error "scStep: too few arguments given"
 179      | otherwise
 180          = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
 181      where
 182          argsLen  = length args
 183          stack1   = discard argsLen state.stack
 184          (root,_) = pop stack1
 185          heap1    = instantiateAndUpdate body root state.heap (bindings ++ state.globals)
 186          bindings = zip args (getargs state.heap state.stack)
 187  
 188  indStep :: Addr -> TiState -> TiState
 189  indStep addr state = setRuleId 4 $ state { stack = push addr (discard 1 state.stack) }
 190  
 191  primStep :: Name -> Primitive -> TiState -> TiState
 192  primStep name prim = prim
 193  
 194  dataStep :: Tag -> [Addr] -> TiState -> TiState
 195  dataStep tag contents state = state { stack = stack1, dump = dump1 }
 196      where
 197          (stack1, dump1) = popAndRestore state.stack state.dump
 198  
 199  {- | Instantiation -}
 200  
 201  instantiate :: CoreExpr
 202              -> TiHeap
 203              -> Assoc Name Addr
 204              -> (TiHeap, Addr)
 205  instantiate expr heap env = dispatchCoreExpr
 206      (instantiateVar heap env)
 207      (instantiateNum heap env)
 208      (instantiateConstr heap env)
 209      (instantiateAp heap env)
 210      (instantiateLet heap env)
 211      (instantiateCase heap env)
 212      (instantiateLam heap env)
 213      expr
 214  
 215  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 216  instantiateVar heap env name
 217      = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 218  
 219  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 220  instantiateNum heap env num = hAlloc heap (NNum num)
 221  
 222  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 223  instantiateConstr heap env tag arity = hAlloc heap (NPrim "Constr" (primConstr tag arity))
 224  
 225  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 226  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 227      where
 228          (heap1, a1) = instantiate a heap  env
 229          (heap2, a2) = instantiate b heap1 env
 230  
 231  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 232  instantiateLet heap env isrec defs body = instantiate body heap' env'
 233      where
 234          (heap', extraBindings) = mapAccumL instantiateRhs heap defs
 235          env' = extraBindings ++ env
 236          rhsEnv | isrec     = env'
 237                 | otherwise = env
 238          instantiateRhs heap (name, rhs)
 239              = (heap1, (name, addr))
 240              where
 241                  (heap1, addr) = instantiate rhs heap rhsEnv
 242  
 243  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 244  instantiateCase heap env expr alters = error "Cannot instatiate case"
 245  
 246  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 247  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 248  
 249  instantiateAndUpdate :: CoreExpr
 250                       -> Addr
 251                       -> TiHeap
 252                       -> Assoc Name Addr
 253                       -> TiHeap
 254  instantiateAndUpdate expr updAddr heap env = dispatchCoreExpr
 255      (instUpdEVar updAddr heap env)
 256      (instUpdENum updAddr heap env)
 257      (instUpdEConstr updAddr heap env)
 258      (instUpdEAp updAddr heap env)
 259      (instUpdELet updAddr heap env)
 260      (instUpdECase updAddr heap env)
 261      (instUpdELam updAddr heap env)
 262      expr
 263  
 264  instUpdEVar :: Addr
 265              -> TiHeap
 266              -> Assoc Name Addr
 267              -> Name
 268              -> TiHeap
 269  instUpdEVar updAddr heap env v = hUpdate heap updAddr (NInd varAddr)
 270      where
 271          varAddr = aLookup env v (error ("undefined name " ++ show v))
 272  
 273  instUpdENum :: Addr
 274              -> TiHeap
 275              -> Assoc Name Addr
 276              -> Int
 277              -> TiHeap
 278  instUpdENum updAddr heap env n = hUpdate heap updAddr (NNum n)
 279  
 280  instUpdEConstr :: Addr
 281                 -> TiHeap
 282                 -> Assoc Name Addr
 283                 -> Tag
 284                 -> Arity
 285                 -> TiHeap
 286  instUpdEConstr updAddr heap env tag arity
 287      = hUpdate heap updAddr (NPrim "Constr" (primConstr tag arity))
 288  
 289  instUpdEAp :: Addr
 290             -> TiHeap
 291             -> Assoc Name Addr
 292             -> CoreExpr
 293             -> CoreExpr
 294             -> TiHeap
 295  instUpdEAp updAddr heap env e1 e2 = hUpdate heap2 updAddr (NAp a1 a2)
 296      where
 297          (heap1, a1) = instantiate e1 heap  env
 298          (heap2, a2) = instantiate e2 heap1 env
 299  
 300  instUpdELet :: Addr
 301              -> TiHeap
 302              -> Assoc Name Addr
 303              -> IsRec
 304              -> Assoc Name CoreExpr
 305              -> CoreExpr
 306              -> TiHeap
 307  instUpdELet updAddr heap env isrec defs body = instantiateAndUpdate body updAddr heap1 env1
 308      where
 309          (heap1, extraBindings) = mapAccumL instantiateRhs heap defs
 310          env1 = extraBindings ++ env
 311          rhsEnv | isrec     = env1
 312                 | otherwise = env
 313          instantiateRhs heap (name, rhs) = (heap1, (name, addr))
 314              where
 315                  (heap1, addr) = instantiate rhs heap rhsEnv
 316  
 317  instUpdECase :: Addr
 318               -> TiHeap
 319               -> Assoc Name Addr
 320               -> CoreExpr
 321               -> [CoreAlter]
 322               -> TiHeap
 323  instUpdECase updAddr heap env expr alts = error "not implemented"
 324  
 325  instUpdELam :: Addr
 326              -> TiHeap
 327              -> Assoc Name Addr
 328              -> [Name]
 329              -> CoreExpr
 330              -> TiHeap
 331  instUpdELam updAddr heap env vars body = error "not implemented"
 332  
 333  test :: (?sz :: Int, ?th :: Int) => String -> IO ()
 334  test = interact . drive . run 
 335  
 336  -- Gabage Collector (Mark-scan)
 337  
 338  gc :: TiState -> TiState
 339  gc state = case evacuateStack state.heap hInitial state.stack of
 340      ((from1, to1), stack1) -> case evacuateDump from1 state.dump of
 341          ((from2, to2), dump1)  -> case evacuateGlobals from2 state.globals of
 342              ((from3, to3), globals1) -> state { stack = stack1
 343                                                , heap = scavengeHeap from3 to3
 344                                                , globals = globals1
 345                                                , stats = incGcCount state.stats
 346                                                }
 347  
 348  -- gc state = state { heap = scanHeap $ fst
 349  --                         $ mapAccumL markFrom state.heap
 350  --                         $ findRoots state 
 351  --                  , stats = incGcCount state.stats
 352  --                  }
 353  
 354  
 355  findStackRoots :: TiStack -> [Addr]
 356  findStackRoots stack = stack.stkItems
 357  
 358  findDumpRoots :: TiDump -> [Addr]
 359  findDumpRoots dump = []
 360  
 361  findGlobalRoots :: TiGlobals -> [Addr]
 362  findGlobalRoots globals = aRange globals
 363  
 364  findRoots :: TiState -> [Addr]
 365  findRoots state = concat
 366      [ findStackRoots state.stack
 367      , findDumpRoots state.dump
 368      , findGlobalRoots state.globals
 369      ]
 370  
 371  evacuateStack :: TiHeap -> TiHeap -> TiStack -> ((TiHeap, TiHeap), TiStack)
 372  evacuateStack from to stack = case mapAccumL evacuateFrom (from, to) stack.stkItems of
 373      (heaps', addrs') -> (heaps', stack { stkItems = addrs'})
 374  
 375  evacuateDump :: TiHeap -> TiHeap -> TiDump -> ((TiHeap, TiHeap), TiDump)
 376  evacuateDump from to dump = undefined
 377  
 378  evacuateGlobals :: TiHeap -> TiHeap -> TiGlobals -> ((TiHeap, TiHeap), TiGlobals)
 379  evacuateGlobals from to globals = undefined
 380  
 381  evacuateFrom :: (TiHeap, TiHeap) -> Addr -> ((TiHeap, TiHeap), Addr)
 382  evacuateFrom (from, to) addr = case hLookup from addr of
 383      node -> dispatchNode
 384          (\ addr1 addr2 -> case evacuateFrom (from, to) addr1 of
 385              ((from1, to1), addr11) -> case evacuateFrom (from1, to1) addr2 of
 386                  ((from2, to2), addr22) -> case hAlloc to2 (NAp addr11 addr22) of
 387                      (to3, addr3) -> case hUpdate from2 addr (NForward addr3) of
 388                          from3 -> ((from3, to3), addr3)
 389          )
 390          (\ sc args e -> case hAlloc to node of
 391              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 392                  from1 -> ((from1, to1), addr1)
 393          )
 394          (\ n -> case hAlloc to node of
 395              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 396                  from1 -> ((from1, to1), addr1)
 397          )
 398          (\ addr1 -> evacuateFrom (from, to) addr1
 399          ) 
 400          (\ name prim -> case hAlloc to node of
 401              (to1, addr1) -> case hUpdate from addr1 (NForward addr1) of
 402                  from1 -> ((from1, to1), addr1)
 403          )
 404          (\ tag args -> case mapAccumL evacuateFrom (from, to) args of
 405              ((from1, to1), args1) -> case hAlloc to1 (NData tag args1) of
 406                  (to2, addr2) -> case hUpdate from1 addr (NForward addr2) of
 407                      from2 -> ((from2, to2), addr2)
 408          )
 409          (\ fwaddr -> ((from, to), fwaddr)
 410          )
 411          node
 412  
 413  scavengeHeap :: TiHeap -> TiHeap -> TiHeap
 414  scavengeHeap from to = undefined
 415  
 416  {-
 417  markFromStack :: TiHeap -> TiStack -> (TiHeap, TiStack)
 418  markFromStack hp stk = case mapAccumL markFrom hp stk.stkItems of
 419      (hp', stk') -> (hp', stk { stkItems = stk'})
 420  
 421  markFromDump :: TiHeap -> TiDump -> (TiHeap, TiDump)
 422  markFromDump hp dump = (hp, dump)
 423  
 424  markFromGlobals :: TiHeap -> TiGlobals -> (TiHeap, TiGlobals)
 425  markFromGlobals hp env = mapAccumL markFrom_ hp env
 426      where
 427          markFrom_ heap (name, addr) = case markFrom heap addr of
 428              (heap', addr') -> (heap', (name, addr'))
 429  
 430  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
 431  markFrom heap addr = case hLookup heap addr of
 432      node -> dispatchNode 
 433              (\ addr1 addr2 -> case markFrom heap addr1 of
 434                  (heap1, addr1') -> case markFrom heap1 addr2 of
 435                      (heap2, addr2')  -> (hUpdate heap2 addr (NMarked (NAp addr1' addr2')), addr))
 436              (\ _ _ _       -> (hUpdate heap addr (NMarked node), addr)) -- NSupercomb
 437              (\ _           -> (hUpdate heap addr (NMarked node), addr)) -- NNum
 438              (\ addr1       -> markFrom heap addr1)                      -- NInd
 439              (\ _ _         -> (hUpdate heap addr (NMarked node), addr)) -- NPrim
 440              (\ tag as      -> case mapAccumL markFrom heap as of
 441                  (heap', as')    -> (hUpdate heap' addr (NMarked (NData tag as')), addr))
 442                                                                          -- NData
 443              (\ _           -> (heap, addr))                             -- NForward
 444              node
 445  
 446  scanHeap :: TiHeap -> TiHeap
 447  scanHeap heap =foldl phi heap heap.assocs
 448      where
 449          phi h (a, node) = case node of
 450              NMarked node1 -> hUpdate h a node1
 451              _             -> hFree h a
 452  -}
[34 of 34] Compiling Template.Mark5cp.Machine ( src/Template/Mark5cp/Machine.hs, interpreted )

src/Template/Mark5cp/Machine.hs:340:55: error:
     Couldn't match type: Stack Int
                     with: Heap Node
        arising from selecting the field dump
     In the second argument of evacuateDump, namely state.dump
      In the expression: evacuateDump from1 state.dump
      In the expression:
        case evacuateDump from1 state.dump of
          ((from2, to2), dump1)
            -> case evacuateGlobals from2 state.globals of
                 ((from3, to3), globals1)
                   -> state
                        {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                         stats = incGcCount ...}
    |
340 |     ((from1, to1), stack1) -> case evacuateDump from1 state.dump of
    |                                                       ^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:341:9: error:
     Couldn't match expected type: TiDump
                                    -> ((TiHeap, TiHeap), TiDump)
                  with actual type: ((TiHeap, b0), b1)
     In the pattern: ((from2, to2), dump1)
      In a case alternative:
          ((from2, to2), dump1)
            -> case evacuateGlobals from2 state.globals of
                 ((from3, to3), globals1)
                   -> state
                        {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                         stats = incGcCount ...}
      In the expression:
        case evacuateDump from1 state.dump of
          ((from2, to2), dump1)
            -> case evacuateGlobals from2 state.globals of
                 ((from3, to3), globals1)
                   -> state
                        {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                         stats = incGcCount ...}
    |
341 |         ((from2, to2), dump1)  -> case evacuateGlobals from2 state.globals of
    |         ^^^^^^^^^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:341:62: error:
     Couldn't match type: [(Name, Addr)]
                     with: Heap Node
        arising from selecting the field globals
     In the second argument of evacuateGlobals, namely
        state.globals
      In the expression: evacuateGlobals from2 state.globals
      In the expression:
        case evacuateGlobals from2 state.globals of
          ((from3, to3), globals1)
            -> state
                 {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                  stats = incGcCount state.stats}
    |
341 |         ((from2, to2), dump1)  -> case evacuateGlobals from2 state.globals of
    |                                                              ^^^^^^^^^^^^^

src/Template/Mark5cp/Machine.hs:342:13: error:
     Couldn't match expected type: TiGlobals
                                    -> ((TiHeap, TiHeap), TiGlobals)
                  with actual type: ((TiHeap, TiHeap), TiGlobals)
     In the pattern: ((from3, to3), globals1)
      In a case alternative:
          ((from3, to3), globals1)
            -> state
                 {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                  stats = incGcCount state.stats}
      In the expression:
        case evacuateGlobals from2 state.globals of
          ((from3, to3), globals1)
            -> state
                 {stack = stack1, heap = scavengeHeap from3 to3, globals = globals1,
                  stats = incGcCount state.stats}
    |
342 |             ((from3, to3), globals1) -> state { stack = stack1
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
Failed, 33 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5cp.Machine
   6      where
   7  
   8  import Data.Bool
   9  import Data.Char
  10  import Data.List
  11  import Data.List.Extra
  12  
  13  import Language
  14  import Heap
  15  import Stack
  16  import Iseq
  17  import Utils
  18  
  19  import Template.Mark5cp.State
  20  import Template.Mark5cp.PPrint
  21  
  22  import Debug.Trace qualified as Deb
  23  
  24  debug :: Bool
  25  debug = True
  26  
  27  trace :: String -> a -> a
  28  trace | debug     = Deb.trace
  29        | otherwise = const id 
  30  
  31  traceShow :: Show a => a -> b -> b
  32  traceShow | debug     = Deb.traceShow
  33            | otherwise = const id
  34  
  35  {- * Mark 5 : Structured data -}
  36  {- | Structure of the implementations -}
  37  
  38  drive :: ([String] -> [String]) -> (String -> String)
  39  drive f = unlines . f . ("" :) . lines
  40  
  41  run :: (?sz :: Int, ?th :: Int) => String -> ([String] -> [String])
  42  run prog inputs
  43      = showResults 
  44      $ eval
  45      $ setControl inputs
  46      $ compile 
  47      $ parse prog
  48  
  49  setControl :: [String] -> TiState -> TiState
  50  setControl ctrl state = state { control = ctrl }
  51  
  52  {- | Compiler -}
  53  
  54  compile :: (?sz :: Int, ?th :: Int) => CoreProgram -> TiState
  55  compile prog = TiState
  56      { control = []
  57      , output  = []
  58      , stack   = initialStack1
  59      , dump    = initialDump
  60      , heap    = initialHeap1
  61      , globals = initialGlobals
  62      , stats   = initialStats
  63      , ruleid  = 0
  64      }
  65      where
  66          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
  67          (initialHeap, initialGlobals) = buildInitialHeap scDefs
  68          initialStack = singletonStack addressOfMain
  69          initialStack1 = singletonStack addr
  70          addressOfMain = aLookup initialGlobals "main" (negate 1)
  71          (heap1, addr1)
  72              | addressOfMain < 0 = (initialHeap, aLookup initialGlobals "pmain" (error "no main and no pmain"))
  73              | otherwise         = case aLookup initialGlobals "Cons" (error "Cons is not defined") of
  74                  addressOfCons    -> case aLookup initialGlobals "Nil" (error "Nil is not defined") of
  75                      addressOfNil   -> case hAlloc initialHeap (NAp addressOfCons addressOfMain) of
  76                          (h, a)       -> hAlloc h (NAp a addressOfNil)
  77          addressOfPrint = aLookup initialGlobals "printList" (error "printList is not defined")
  78          (initialHeap1, addr) = hAlloc heap1 (NAp addressOfPrint addr1)
  79  
  80  extraPreludeDefs :: CoreProgram
  81  extraPreludeDefs = 
  82      [ ("False", [], EConstr 0 0)
  83      , ("True" , [], EConstr 1 0)
  84      , ("not", ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  85                                (EVar "False"))
  86                           (EVar "True"))
  87      , ("and", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  88                                     (EVar "y"))
  89                                (EVar "False"))
  90      , ("or",  ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  91                                     (EVar "True"))
  92                                (EVar "y"))
  93      , ("xor", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  94                                     (EAp (EVar "not") (EVar "y")))
  95                                (EVar "y"))
  96      , ("MkPair", [], EConstr 0 2)
  97      , ("fst", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  98                           (EVar "K"))
  99      , ("snd", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
 100                           (EVar "K1"))
 101      , ("Nil", [], EConstr 0 0)
 102      , ("Cons", [], EConstr 1 2)
 103      , ("head", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 104                                  (EVar "abort"))
 105                             (EVar "K"))
 106      , ("tail", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 107                                  (EVar "abort"))
 108                             (EVar "K1"))
 109      , ("printList", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 110                                       (EVar "stop"))
 111                                  (EVar "printCons"))
 112      , ("printCons", ["h", "t"], EAp (EAp (EVar "print") (EVar "h"))
 113                                      (EAp (EVar "printList") (EVar "t")))
 114      ]
 115  
 116  buildInitialHeap :: ( ?sz :: Int, ?th :: Int ) => [CoreScDefn] -> (TiHeap, TiGlobals)
 117  buildInitialHeap scDefs = (heap2, scAddrs ++ primAddrs)
 118      where
 119          (heap1, scAddrs)   = mapAccumL allocateSc hInitial scDefs
 120          (heap2, primAddrs) = mapAccumL allocatePrim heap1 primitives
 121  
 122  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 123  allocateSc heap scDefn = case scDefn of
 124      (name, args, body) -> (heap', (name, addr))
 125          where
 126              (heap', addr) = hAlloc heap (NSupercomb name args body)
 127  
 128  allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
 129  allocatePrim heap (name, prim) = (heap1, (name, addr))
 130      where
 131          (heap1, addr) = hAlloc heap (NPrim name prim)
 132  
 133  {- | Evaluator -}
 134  
 135  eval :: TiState -> [TiState]
 136  eval state = state : rests
 137      where
 138          rests | tiFinal state = []
 139                | otherwise      = eval $ doAdmin $ doAdminTotalSteps $ step state
 140  
 141  doAdmin :: TiState -> TiState
 142  doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
 143  
 144  step :: TiState -> TiState
 145  step state = case map toLower $ head state.control of
 146      ""                -> state' { control = tail state.control }
 147      "c"               -> state' { control = repeat "" }
 148      s | all isDigit s -> state' { control = replicate (pred $ read s) "" ++ tail state.control }
 149        | otherwise     -> state' { control = tail state.control }
 150    where
 151          state' = dispatchNode 
 152                      apStep
 153                      scStep
 154                      numStep
 155                      indStep
 156                      primStep
 157                      dataStep
 158                      (error "step: NForward node")
 159                      (hLookup state.heap (fst (pop state.stack)))
 160                    $ state
 161  
 162  numStep :: Int -> TiState -> TiState
 163  numStep n state 
 164      | isEmptyStack state.dump = error "numStep: Number applied as a function"
 165      | otherwise = case popAndRestore state.stack state.dump of
 166          (stack1, dump1) -> setRuleId 7 $ state { stack = stack1, dump = dump1 }
 167  
 168  apStep :: Addr -> Addr -> TiState -> TiState
 169  apStep a1 a2 state = case hLookup state.heap a2 of
 170      NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
 171      _       -> setRuleId 1 $ state { stack = push a1 state.stack }
 172      where
 173          (a,_) = pop state.stack
 174  
 175  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 176  scStep name args body state
 177      | state.stack.curDepth < succ argsLen
 178          = error "scStep: too few arguments given"
 179      | otherwise
 180          = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
 181      where
 182          argsLen  = length args
 183          stack1   = discard argsLen state.stack
 184          (root,_) = pop stack1
 185          heap1    = instantiateAndUpdate body root state.heap (bindings ++ state.globals)
 186          bindings = zip args (getargs state.heap state.stack)
 187  
 188  indStep :: Addr -> TiState -> TiState
 189  indStep addr state = setRuleId 4 $ state { stack = push addr (discard 1 state.stack) }
 190  
 191  primStep :: Name -> Primitive -> TiState -> TiState
 192  primStep name prim = prim
 193  
 194  dataStep :: Tag -> [Addr] -> TiState -> TiState
 195  dataStep tag contents state = state { stack = stack1, dump = dump1 }
 196      where
 197          (stack1, dump1) = popAndRestore state.stack state.dump
 198  
 199  {- | Instantiation -}
 200  
 201  instantiate :: CoreExpr
 202              -> TiHeap
 203              -> Assoc Name Addr
 204              -> (TiHeap, Addr)
 205  instantiate expr heap env = dispatchCoreExpr
 206      (instantiateVar heap env)
 207      (instantiateNum heap env)
 208      (instantiateConstr heap env)
 209      (instantiateAp heap env)
 210      (instantiateLet heap env)
 211      (instantiateCase heap env)
 212      (instantiateLam heap env)
 213      expr
 214  
 215  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 216  instantiateVar heap env name
 217      = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 218  
 219  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 220  instantiateNum heap env num = hAlloc heap (NNum num)
 221  
 222  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 223  instantiateConstr heap env tag arity = hAlloc heap (NPrim "Constr" (primConstr tag arity))
 224  
 225  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 226  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 227      where
 228          (heap1, a1) = instantiate a heap  env
 229          (heap2, a2) = instantiate b heap1 env
 230  
 231  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 232  instantiateLet heap env isrec defs body = instantiate body heap' env'
 233      where
 234          (heap', extraBindings) = mapAccumL instantiateRhs heap defs
 235          env' = extraBindings ++ env
 236          rhsEnv | isrec     = env'
 237                 | otherwise = env
 238          instantiateRhs heap (name, rhs)
 239              = (heap1, (name, addr))
 240              where
 241                  (heap1, addr) = instantiate rhs heap rhsEnv
 242  
 243  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 244  instantiateCase heap env expr alters = error "Cannot instatiate case"
 245  
 246  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 247  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 248  
 249  instantiateAndUpdate :: CoreExpr
 250                       -> Addr
 251                       -> TiHeap
 252                       -> Assoc Name Addr
 253                       -> TiHeap
 254  instantiateAndUpdate expr updAddr heap env = dispatchCoreExpr
 255      (instUpdEVar updAddr heap env)
 256      (instUpdENum updAddr heap env)
 257      (instUpdEConstr updAddr heap env)
 258      (instUpdEAp updAddr heap env)
 259      (instUpdELet updAddr heap env)
 260      (instUpdECase updAddr heap env)
 261      (instUpdELam updAddr heap env)
 262      expr
 263  
 264  instUpdEVar :: Addr
 265              -> TiHeap
 266              -> Assoc Name Addr
 267              -> Name
 268              -> TiHeap
 269  instUpdEVar updAddr heap env v = hUpdate heap updAddr (NInd varAddr)
 270      where
 271          varAddr = aLookup env v (error ("undefined name " ++ show v))
 272  
 273  instUpdENum :: Addr
 274              -> TiHeap
 275              -> Assoc Name Addr
 276              -> Int
 277              -> TiHeap
 278  instUpdENum updAddr heap env n = hUpdate heap updAddr (NNum n)
 279  
 280  instUpdEConstr :: Addr
 281                 -> TiHeap
 282                 -> Assoc Name Addr
 283                 -> Tag
 284                 -> Arity
 285                 -> TiHeap
 286  instUpdEConstr updAddr heap env tag arity
 287      = hUpdate heap updAddr (NPrim "Constr" (primConstr tag arity))
 288  
 289  instUpdEAp :: Addr
 290             -> TiHeap
 291             -> Assoc Name Addr
 292             -> CoreExpr
 293             -> CoreExpr
 294             -> TiHeap
 295  instUpdEAp updAddr heap env e1 e2 = hUpdate heap2 updAddr (NAp a1 a2)
 296      where
 297          (heap1, a1) = instantiate e1 heap  env
 298          (heap2, a2) = instantiate e2 heap1 env
 299  
 300  instUpdELet :: Addr
 301              -> TiHeap
 302              -> Assoc Name Addr
 303              -> IsRec
 304              -> Assoc Name CoreExpr
 305              -> CoreExpr
 306              -> TiHeap
 307  instUpdELet updAddr heap env isrec defs body = instantiateAndUpdate body updAddr heap1 env1
 308      where
 309          (heap1, extraBindings) = mapAccumL instantiateRhs heap defs
 310          env1 = extraBindings ++ env
 311          rhsEnv | isrec     = env1
 312                 | otherwise = env
 313          instantiateRhs heap (name, rhs) = (heap1, (name, addr))
 314              where
 315                  (heap1, addr) = instantiate rhs heap rhsEnv
 316  
 317  instUpdECase :: Addr
 318               -> TiHeap
 319               -> Assoc Name Addr
 320               -> CoreExpr
 321               -> [CoreAlter]
 322               -> TiHeap
 323  instUpdECase updAddr heap env expr alts = error "not implemented"
 324  
 325  instUpdELam :: Addr
 326              -> TiHeap
 327              -> Assoc Name Addr
 328              -> [Name]
 329              -> CoreExpr
 330              -> TiHeap
 331  instUpdELam updAddr heap env vars body = error "not implemented"
 332  
 333  test :: (?sz :: Int, ?th :: Int) => String -> IO ()
 334  test = interact . drive . run 
 335  
 336  -- Gabage Collector (Mark-scan)
 337  
 338  gc :: TiState -> TiState
 339  gc state = case evacuateStack state.heap hInitial state.stack of
 340      ((from1, to1), stack1) -> case evacuateDump from1 to1 state.dump of
 341          ((from2, to2), dump1)  -> case evacuateGlobals from2 to2 state.globals of
 342              ((from3, to3), globals1) -> state { stack = stack1
 343                                                , heap = scavengeHeap from3 to3
 344                                                , globals = globals1
 345                                                , stats = incGcCount state.stats
 346                                                }
 347  
 348  -- gc state = state { heap = scanHeap $ fst
 349  --                         $ mapAccumL markFrom state.heap
 350  --                         $ findRoots state 
 351  --                  , stats = incGcCount state.stats
 352  --                  }
 353  
 354  
 355  findStackRoots :: TiStack -> [Addr]
 356  findStackRoots stack = stack.stkItems
 357  
 358  findDumpRoots :: TiDump -> [Addr]
 359  findDumpRoots dump = []
 360  
 361  findGlobalRoots :: TiGlobals -> [Addr]
 362  findGlobalRoots globals = aRange globals
 363  
 364  findRoots :: TiState -> [Addr]
 365  findRoots state = concat
 366      [ findStackRoots state.stack
 367      , findDumpRoots state.dump
 368      , findGlobalRoots state.globals
 369      ]
 370  
 371  evacuateStack :: TiHeap -> TiHeap -> TiStack -> ((TiHeap, TiHeap), TiStack)
 372  evacuateStack from to stack = case mapAccumL evacuateFrom (from, to) stack.stkItems of
 373      (heaps', addrs') -> (heaps', stack { stkItems = addrs'})
 374  
 375  evacuateDump :: TiHeap -> TiHeap -> TiDump -> ((TiHeap, TiHeap), TiDump)
 376  evacuateDump from to dump = undefined
 377  
 378  evacuateGlobals :: TiHeap -> TiHeap -> TiGlobals -> ((TiHeap, TiHeap), TiGlobals)
 379  evacuateGlobals from to globals = undefined
 380  
 381  evacuateFrom :: (TiHeap, TiHeap) -> Addr -> ((TiHeap, TiHeap), Addr)
 382  evacuateFrom (from, to) addr = case hLookup from addr of
 383      node -> dispatchNode
 384          (\ addr1 addr2 -> case evacuateFrom (from, to) addr1 of
 385              ((from1, to1), addr11) -> case evacuateFrom (from1, to1) addr2 of
 386                  ((from2, to2), addr22) -> case hAlloc to2 (NAp addr11 addr22) of
 387                      (to3, addr3) -> case hUpdate from2 addr (NForward addr3) of
 388                          from3 -> ((from3, to3), addr3)
 389          )
 390          (\ sc args e -> case hAlloc to node of
 391              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 392                  from1 -> ((from1, to1), addr1)
 393          )
 394          (\ n -> case hAlloc to node of
 395              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 396                  from1 -> ((from1, to1), addr1)
 397          )
 398          (\ addr1 -> evacuateFrom (from, to) addr1
 399          ) 
 400          (\ name prim -> case hAlloc to node of
 401              (to1, addr1) -> case hUpdate from addr1 (NForward addr1) of
 402                  from1 -> ((from1, to1), addr1)
 403          )
 404          (\ tag args -> case mapAccumL evacuateFrom (from, to) args of
 405              ((from1, to1), args1) -> case hAlloc to1 (NData tag args1) of
 406                  (to2, addr2) -> case hUpdate from1 addr (NForward addr2) of
 407                      from2 -> ((from2, to2), addr2)
 408          )
 409          (\ fwaddr -> ((from, to), fwaddr)
 410          )
 411          node
 412  
 413  scavengeHeap :: TiHeap -> TiHeap -> TiHeap
 414  scavengeHeap from to = undefined
 415  
 416  {-
 417  markFromStack :: TiHeap -> TiStack -> (TiHeap, TiStack)
 418  markFromStack hp stk = case mapAccumL markFrom hp stk.stkItems of
 419      (hp', stk') -> (hp', stk { stkItems = stk'})
 420  
 421  markFromDump :: TiHeap -> TiDump -> (TiHeap, TiDump)
 422  markFromDump hp dump = (hp, dump)
 423  
 424  markFromGlobals :: TiHeap -> TiGlobals -> (TiHeap, TiGlobals)
 425  markFromGlobals hp env = mapAccumL markFrom_ hp env
 426      where
 427          markFrom_ heap (name, addr) = case markFrom heap addr of
 428              (heap', addr') -> (heap', (name, addr'))
 429  
 430  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
 431  markFrom heap addr = case hLookup heap addr of
 432      node -> dispatchNode 
 433              (\ addr1 addr2 -> case markFrom heap addr1 of
 434                  (heap1, addr1') -> case markFrom heap1 addr2 of
 435                      (heap2, addr2')  -> (hUpdate heap2 addr (NMarked (NAp addr1' addr2')), addr))
 436              (\ _ _ _       -> (hUpdate heap addr (NMarked node), addr)) -- NSupercomb
 437              (\ _           -> (hUpdate heap addr (NMarked node), addr)) -- NNum
 438              (\ addr1       -> markFrom heap addr1)                      -- NInd
 439              (\ _ _         -> (hUpdate heap addr (NMarked node), addr)) -- NPrim
 440              (\ tag as      -> case mapAccumL markFrom heap as of
 441                  (heap', as')    -> (hUpdate heap' addr (NMarked (NData tag as')), addr))
 442                                                                          -- NData
 443              (\ _           -> (heap, addr))                             -- NForward
 444              node
 445  
 446  scanHeap :: TiHeap -> TiHeap
 447  scanHeap heap =foldl phi heap heap.assocs
 448      where
 449          phi h (a, node) = case node of
 450              NMarked node1 -> hUpdate h a node1
 451              _             -> hFree h a
 452  -}
[34 of 34] Compiling Template.Mark5cp.Machine ( src/Template/Mark5cp/Machine.hs, interpreted )

src/Template/Mark5cp/Machine.hs:339:42: error:
     Unbound implicit parameters (?sz::Int, ?th::Int)
        arising from a use of hInitial
     In the second argument of evacuateStack, namely hInitial
      In the expression: evacuateStack state.heap hInitial state.stack
      In the expression:
        case evacuateStack state.heap hInitial state.stack of
          ((from1, to1), stack1)
            -> case evacuateDump from1 to1 state.dump of
                 ((from2, to2), dump1)
                   -> case evacuateGlobals from2 to2 ... of
                        ((from3, to3), globals1) -> ...
    |
339 | gc state = case evacuateStack state.heap hInitial state.stack of
    |                                          ^^^^^^^^
Failed, 33 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5cp.Machine
   6      where
   7  
   8  import Data.Bool
   9  import Data.Char
  10  import Data.List
  11  import Data.List.Extra
  12  
  13  import Language
  14  import Heap
  15  import Stack
  16  import Iseq
  17  import Utils
  18  
  19  import Template.Mark5cp.State
  20  import Template.Mark5cp.PPrint
  21  
  22  import Debug.Trace qualified as Deb
  23  
  24  debug :: Bool
  25  debug = True
  26  
  27  trace :: String -> a -> a
  28  trace | debug     = Deb.trace
  29        | otherwise = const id 
  30  
  31  traceShow :: Show a => a -> b -> b
  32  traceShow | debug     = Deb.traceShow
  33            | otherwise = const id
  34  
  35  {- * Mark 5 : Structured data -}
  36  {- | Structure of the implementations -}
  37  
  38  drive :: ([String] -> [String]) -> (String -> String)
  39  drive f = unlines . f . ("" :) . lines
  40  
  41  run :: (?sz :: Int, ?th :: Int) => String -> ([String] -> [String])
  42  run prog inputs
  43      = showResults 
  44      $ eval
  45      $ setControl inputs
  46      $ compile 
  47      $ parse prog
  48  
  49  setControl :: [String] -> TiState -> TiState
  50  setControl ctrl state = state { control = ctrl }
  51  
  52  {- | Compiler -}
  53  
  54  compile :: (?sz :: Int, ?th :: Int) => CoreProgram -> TiState
  55  compile prog = TiState
  56      { control = []
  57      , output  = []
  58      , stack   = initialStack1
  59      , dump    = initialDump
  60      , heap    = initialHeap1
  61      , globals = initialGlobals
  62      , stats   = initialStats
  63      , ruleid  = 0
  64      }
  65      where
  66          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
  67          (initialHeap, initialGlobals) = buildInitialHeap scDefs
  68          initialStack = singletonStack addressOfMain
  69          initialStack1 = singletonStack addr
  70          addressOfMain = aLookup initialGlobals "main" (negate 1)
  71          (heap1, addr1)
  72              | addressOfMain < 0 = (initialHeap, aLookup initialGlobals "pmain" (error "no main and no pmain"))
  73              | otherwise         = case aLookup initialGlobals "Cons" (error "Cons is not defined") of
  74                  addressOfCons    -> case aLookup initialGlobals "Nil" (error "Nil is not defined") of
  75                      addressOfNil   -> case hAlloc initialHeap (NAp addressOfCons addressOfMain) of
  76                          (h, a)       -> hAlloc h (NAp a addressOfNil)
  77          addressOfPrint = aLookup initialGlobals "printList" (error "printList is not defined")
  78          (initialHeap1, addr) = hAlloc heap1 (NAp addressOfPrint addr1)
  79  
  80  extraPreludeDefs :: CoreProgram
  81  extraPreludeDefs = 
  82      [ ("False", [], EConstr 0 0)
  83      , ("True" , [], EConstr 1 0)
  84      , ("not", ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  85                                (EVar "False"))
  86                           (EVar "True"))
  87      , ("and", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  88                                     (EVar "y"))
  89                                (EVar "False"))
  90      , ("or",  ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  91                                     (EVar "True"))
  92                                (EVar "y"))
  93      , ("xor", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  94                                     (EAp (EVar "not") (EVar "y")))
  95                                (EVar "y"))
  96      , ("MkPair", [], EConstr 0 2)
  97      , ("fst", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  98                           (EVar "K"))
  99      , ("snd", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
 100                           (EVar "K1"))
 101      , ("Nil", [], EConstr 0 0)
 102      , ("Cons", [], EConstr 1 2)
 103      , ("head", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 104                                  (EVar "abort"))
 105                             (EVar "K"))
 106      , ("tail", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 107                                  (EVar "abort"))
 108                             (EVar "K1"))
 109      , ("printList", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 110                                       (EVar "stop"))
 111                                  (EVar "printCons"))
 112      , ("printCons", ["h", "t"], EAp (EAp (EVar "print") (EVar "h"))
 113                                      (EAp (EVar "printList") (EVar "t")))
 114      ]
 115  
 116  buildInitialHeap :: ( ?sz :: Int, ?th :: Int ) => [CoreScDefn] -> (TiHeap, TiGlobals)
 117  buildInitialHeap scDefs = (heap2, scAddrs ++ primAddrs)
 118      where
 119          (heap1, scAddrs)   = mapAccumL allocateSc hInitial scDefs
 120          (heap2, primAddrs) = mapAccumL allocatePrim heap1 primitives
 121  
 122  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 123  allocateSc heap scDefn = case scDefn of
 124      (name, args, body) -> (heap', (name, addr))
 125          where
 126              (heap', addr) = hAlloc heap (NSupercomb name args body)
 127  
 128  allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
 129  allocatePrim heap (name, prim) = (heap1, (name, addr))
 130      where
 131          (heap1, addr) = hAlloc heap (NPrim name prim)
 132  
 133  {- | Evaluator -}
 134  
 135  eval :: TiState -> [TiState]
 136  eval state = state : rests
 137      where
 138          rests | tiFinal state = []
 139                | otherwise      = eval $ doAdmin $ doAdminTotalSteps $ step state
 140  
 141  doAdmin :: TiState -> TiState
 142  doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
 143  
 144  step :: TiState -> TiState
 145  step state = case map toLower $ head state.control of
 146      ""                -> state' { control = tail state.control }
 147      "c"               -> state' { control = repeat "" }
 148      s | all isDigit s -> state' { control = replicate (pred $ read s) "" ++ tail state.control }
 149        | otherwise     -> state' { control = tail state.control }
 150    where
 151          state' = dispatchNode 
 152                      apStep
 153                      scStep
 154                      numStep
 155                      indStep
 156                      primStep
 157                      dataStep
 158                      (error "step: NForward node")
 159                      (hLookup state.heap (fst (pop state.stack)))
 160                    $ state
 161  
 162  numStep :: Int -> TiState -> TiState
 163  numStep n state 
 164      | isEmptyStack state.dump = error "numStep: Number applied as a function"
 165      | otherwise = case popAndRestore state.stack state.dump of
 166          (stack1, dump1) -> setRuleId 7 $ state { stack = stack1, dump = dump1 }
 167  
 168  apStep :: Addr -> Addr -> TiState -> TiState
 169  apStep a1 a2 state = case hLookup state.heap a2 of
 170      NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
 171      _       -> setRuleId 1 $ state { stack = push a1 state.stack }
 172      where
 173          (a,_) = pop state.stack
 174  
 175  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 176  scStep name args body state
 177      | state.stack.curDepth < succ argsLen
 178          = error "scStep: too few arguments given"
 179      | otherwise
 180          = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
 181      where
 182          argsLen  = length args
 183          stack1   = discard argsLen state.stack
 184          (root,_) = pop stack1
 185          heap1    = instantiateAndUpdate body root state.heap (bindings ++ state.globals)
 186          bindings = zip args (getargs state.heap state.stack)
 187  
 188  indStep :: Addr -> TiState -> TiState
 189  indStep addr state = setRuleId 4 $ state { stack = push addr (discard 1 state.stack) }
 190  
 191  primStep :: Name -> Primitive -> TiState -> TiState
 192  primStep name prim = prim
 193  
 194  dataStep :: Tag -> [Addr] -> TiState -> TiState
 195  dataStep tag contents state = state { stack = stack1, dump = dump1 }
 196      where
 197          (stack1, dump1) = popAndRestore state.stack state.dump
 198  
 199  {- | Instantiation -}
 200  
 201  instantiate :: CoreExpr
 202              -> TiHeap
 203              -> Assoc Name Addr
 204              -> (TiHeap, Addr)
 205  instantiate expr heap env = dispatchCoreExpr
 206      (instantiateVar heap env)
 207      (instantiateNum heap env)
 208      (instantiateConstr heap env)
 209      (instantiateAp heap env)
 210      (instantiateLet heap env)
 211      (instantiateCase heap env)
 212      (instantiateLam heap env)
 213      expr
 214  
 215  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 216  instantiateVar heap env name
 217      = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 218  
 219  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 220  instantiateNum heap env num = hAlloc heap (NNum num)
 221  
 222  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 223  instantiateConstr heap env tag arity = hAlloc heap (NPrim "Constr" (primConstr tag arity))
 224  
 225  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 226  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 227      where
 228          (heap1, a1) = instantiate a heap  env
 229          (heap2, a2) = instantiate b heap1 env
 230  
 231  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 232  instantiateLet heap env isrec defs body = instantiate body heap' env'
 233      where
 234          (heap', extraBindings) = mapAccumL instantiateRhs heap defs
 235          env' = extraBindings ++ env
 236          rhsEnv | isrec     = env'
 237                 | otherwise = env
 238          instantiateRhs heap (name, rhs)
 239              = (heap1, (name, addr))
 240              where
 241                  (heap1, addr) = instantiate rhs heap rhsEnv
 242  
 243  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 244  instantiateCase heap env expr alters = error "Cannot instatiate case"
 245  
 246  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 247  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 248  
 249  instantiateAndUpdate :: CoreExpr
 250                       -> Addr
 251                       -> TiHeap
 252                       -> Assoc Name Addr
 253                       -> TiHeap
 254  instantiateAndUpdate expr updAddr heap env = dispatchCoreExpr
 255      (instUpdEVar updAddr heap env)
 256      (instUpdENum updAddr heap env)
 257      (instUpdEConstr updAddr heap env)
 258      (instUpdEAp updAddr heap env)
 259      (instUpdELet updAddr heap env)
 260      (instUpdECase updAddr heap env)
 261      (instUpdELam updAddr heap env)
 262      expr
 263  
 264  instUpdEVar :: Addr
 265              -> TiHeap
 266              -> Assoc Name Addr
 267              -> Name
 268              -> TiHeap
 269  instUpdEVar updAddr heap env v = hUpdate heap updAddr (NInd varAddr)
 270      where
 271          varAddr = aLookup env v (error ("undefined name " ++ show v))
 272  
 273  instUpdENum :: Addr
 274              -> TiHeap
 275              -> Assoc Name Addr
 276              -> Int
 277              -> TiHeap
 278  instUpdENum updAddr heap env n = hUpdate heap updAddr (NNum n)
 279  
 280  instUpdEConstr :: Addr
 281                 -> TiHeap
 282                 -> Assoc Name Addr
 283                 -> Tag
 284                 -> Arity
 285                 -> TiHeap
 286  instUpdEConstr updAddr heap env tag arity
 287      = hUpdate heap updAddr (NPrim "Constr" (primConstr tag arity))
 288  
 289  instUpdEAp :: Addr
 290             -> TiHeap
 291             -> Assoc Name Addr
 292             -> CoreExpr
 293             -> CoreExpr
 294             -> TiHeap
 295  instUpdEAp updAddr heap env e1 e2 = hUpdate heap2 updAddr (NAp a1 a2)
 296      where
 297          (heap1, a1) = instantiate e1 heap  env
 298          (heap2, a2) = instantiate e2 heap1 env
 299  
 300  instUpdELet :: Addr
 301              -> TiHeap
 302              -> Assoc Name Addr
 303              -> IsRec
 304              -> Assoc Name CoreExpr
 305              -> CoreExpr
 306              -> TiHeap
 307  instUpdELet updAddr heap env isrec defs body = instantiateAndUpdate body updAddr heap1 env1
 308      where
 309          (heap1, extraBindings) = mapAccumL instantiateRhs heap defs
 310          env1 = extraBindings ++ env
 311          rhsEnv | isrec     = env1
 312                 | otherwise = env
 313          instantiateRhs heap (name, rhs) = (heap1, (name, addr))
 314              where
 315                  (heap1, addr) = instantiate rhs heap rhsEnv
 316  
 317  instUpdECase :: Addr
 318               -> TiHeap
 319               -> Assoc Name Addr
 320               -> CoreExpr
 321               -> [CoreAlter]
 322               -> TiHeap
 323  instUpdECase updAddr heap env expr alts = error "not implemented"
 324  
 325  instUpdELam :: Addr
 326              -> TiHeap
 327              -> Assoc Name Addr
 328              -> [Name]
 329              -> CoreExpr
 330              -> TiHeap
 331  instUpdELam updAddr heap env vars body = error "not implemented"
 332  
 333  test :: (?sz :: Int, ?th :: Int) => String -> IO ()
 334  test = interact . drive . run 
 335  
 336  -- Gabage Collector (Mark-scan)
 337  
 338  gc :: (?sz :: Int, ?th :: Int) => TiState -> TiState
 339  gc state = case evacuateStack state.heap hInitial state.stack of
 340      ((from1, to1), stack1) -> case evacuateDump from1 to1 state.dump of
 341          ((from2, to2), dump1)  -> case evacuateGlobals from2 to2 state.globals of
 342              ((from3, to3), globals1) -> state { stack = stack1
 343                                                , heap = scavengeHeap from3 to3
 344                                                , globals = globals1
 345                                                , stats = incGcCount state.stats
 346                                                }
 347  
 348  -- gc state = state { heap = scanHeap $ fst
 349  --                         $ mapAccumL markFrom state.heap
 350  --                         $ findRoots state 
 351  --                  , stats = incGcCount state.stats
 352  --                  }
 353  
 354  
 355  findStackRoots :: TiStack -> [Addr]
 356  findStackRoots stack = stack.stkItems
 357  
 358  findDumpRoots :: TiDump -> [Addr]
 359  findDumpRoots dump = []
 360  
 361  findGlobalRoots :: TiGlobals -> [Addr]
 362  findGlobalRoots globals = aRange globals
 363  
 364  findRoots :: TiState -> [Addr]
 365  findRoots state = concat
 366      [ findStackRoots state.stack
 367      , findDumpRoots state.dump
 368      , findGlobalRoots state.globals
 369      ]
 370  
 371  evacuateStack :: TiHeap -> TiHeap -> TiStack -> ((TiHeap, TiHeap), TiStack)
 372  evacuateStack from to stack = case mapAccumL evacuateFrom (from, to) stack.stkItems of
 373      (heaps', addrs') -> (heaps', stack { stkItems = addrs'})
 374  
 375  evacuateDump :: TiHeap -> TiHeap -> TiDump -> ((TiHeap, TiHeap), TiDump)
 376  evacuateDump from to dump = undefined
 377  
 378  evacuateGlobals :: TiHeap -> TiHeap -> TiGlobals -> ((TiHeap, TiHeap), TiGlobals)
 379  evacuateGlobals from to globals = undefined
 380  
 381  evacuateFrom :: (TiHeap, TiHeap) -> Addr -> ((TiHeap, TiHeap), Addr)
 382  evacuateFrom (from, to) addr = case hLookup from addr of
 383      node -> dispatchNode
 384          (\ addr1 addr2 -> case evacuateFrom (from, to) addr1 of
 385              ((from1, to1), addr11) -> case evacuateFrom (from1, to1) addr2 of
 386                  ((from2, to2), addr22) -> case hAlloc to2 (NAp addr11 addr22) of
 387                      (to3, addr3) -> case hUpdate from2 addr (NForward addr3) of
 388                          from3 -> ((from3, to3), addr3)
 389          )
 390          (\ sc args e -> case hAlloc to node of
 391              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 392                  from1 -> ((from1, to1), addr1)
 393          )
 394          (\ n -> case hAlloc to node of
 395              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 396                  from1 -> ((from1, to1), addr1)
 397          )
 398          (\ addr1 -> evacuateFrom (from, to) addr1
 399          ) 
 400          (\ name prim -> case hAlloc to node of
 401              (to1, addr1) -> case hUpdate from addr1 (NForward addr1) of
 402                  from1 -> ((from1, to1), addr1)
 403          )
 404          (\ tag args -> case mapAccumL evacuateFrom (from, to) args of
 405              ((from1, to1), args1) -> case hAlloc to1 (NData tag args1) of
 406                  (to2, addr2) -> case hUpdate from1 addr (NForward addr2) of
 407                      from2 -> ((from2, to2), addr2)
 408          )
 409          (\ fwaddr -> ((from, to), fwaddr)
 410          )
 411          node
 412  
 413  scavengeHeap :: TiHeap -> TiHeap -> TiHeap
 414  scavengeHeap from to = undefined
 415  
 416  {-
 417  markFromStack :: TiHeap -> TiStack -> (TiHeap, TiStack)
 418  markFromStack hp stk = case mapAccumL markFrom hp stk.stkItems of
 419      (hp', stk') -> (hp', stk { stkItems = stk'})
 420  
 421  markFromDump :: TiHeap -> TiDump -> (TiHeap, TiDump)
 422  markFromDump hp dump = (hp, dump)
 423  
 424  markFromGlobals :: TiHeap -> TiGlobals -> (TiHeap, TiGlobals)
 425  markFromGlobals hp env = mapAccumL markFrom_ hp env
 426      where
 427          markFrom_ heap (name, addr) = case markFrom heap addr of
 428              (heap', addr') -> (heap', (name, addr'))
 429  
 430  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
 431  markFrom heap addr = case hLookup heap addr of
 432      node -> dispatchNode 
 433              (\ addr1 addr2 -> case markFrom heap addr1 of
 434                  (heap1, addr1') -> case markFrom heap1 addr2 of
 435                      (heap2, addr2')  -> (hUpdate heap2 addr (NMarked (NAp addr1' addr2')), addr))
 436              (\ _ _ _       -> (hUpdate heap addr (NMarked node), addr)) -- NSupercomb
 437              (\ _           -> (hUpdate heap addr (NMarked node), addr)) -- NNum
 438              (\ addr1       -> markFrom heap addr1)                      -- NInd
 439              (\ _ _         -> (hUpdate heap addr (NMarked node), addr)) -- NPrim
 440              (\ tag as      -> case mapAccumL markFrom heap as of
 441                  (heap', as')    -> (hUpdate heap' addr (NMarked (NData tag as')), addr))
 442                                                                          -- NData
 443              (\ _           -> (heap, addr))                             -- NForward
 444              node
 445  
 446  scanHeap :: TiHeap -> TiHeap
 447  scanHeap heap =foldl phi heap heap.assocs
 448      where
 449          phi h (a, node) = case node of
 450              NMarked node1 -> hUpdate h a node1
 451              _             -> hFree h a
 452  -}
[34 of 34] Compiling Template.Mark5cp.Machine ( src/Template/Mark5cp/Machine.hs, interpreted )

src/Template/Mark5cp/Machine.hs:142:25: error:
     Unbound implicit parameters (?sz::Int, ?th::Int)
        arising from a use of gc
     In the second argument of bool, namely gc
      In the expression:
        bool id gc (state.heap.curAllocs > state.heap.threshold) state
      In an equation for doAdmin:
          doAdmin state
            = bool id gc (state.heap.curAllocs > state.heap.threshold) state
    |
142 | doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
    |                         ^^
Failed, 33 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5cp.Machine
   6      where
   7  
   8  import Data.Bool
   9  import Data.Char
  10  import Data.List
  11  import Data.List.Extra
  12  
  13  import Language
  14  import Heap
  15  import Stack
  16  import Iseq
  17  import Utils
  18  
  19  import Template.Mark5cp.State
  20  import Template.Mark5cp.PPrint
  21  
  22  import Debug.Trace qualified as Deb
  23  
  24  debug :: Bool
  25  debug = True
  26  
  27  trace :: String -> a -> a
  28  trace | debug     = Deb.trace
  29        | otherwise = const id 
  30  
  31  traceShow :: Show a => a -> b -> b
  32  traceShow | debug     = Deb.traceShow
  33            | otherwise = const id
  34  
  35  {- * Mark 5 : Structured data -}
  36  {- | Structure of the implementations -}
  37  
  38  drive :: ([String] -> [String]) -> (String -> String)
  39  drive f = unlines . f . ("" :) . lines
  40  
  41  run :: (?sz :: Int, ?th :: Int) => String -> ([String] -> [String])
  42  run prog inputs
  43      = showResults 
  44      $ eval
  45      $ setControl inputs
  46      $ compile 
  47      $ parse prog
  48  
  49  setControl :: [String] -> TiState -> TiState
  50  setControl ctrl state = state { control = ctrl }
  51  
  52  {- | Compiler -}
  53  
  54  compile :: (?sz :: Int, ?th :: Int) => CoreProgram -> TiState
  55  compile prog = TiState
  56      { control = []
  57      , output  = []
  58      , stack   = initialStack1
  59      , dump    = initialDump
  60      , heap    = initialHeap1
  61      , globals = initialGlobals
  62      , stats   = initialStats
  63      , ruleid  = 0
  64      }
  65      where
  66          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
  67          (initialHeap, initialGlobals) = buildInitialHeap scDefs
  68          initialStack = singletonStack addressOfMain
  69          initialStack1 = singletonStack addr
  70          addressOfMain = aLookup initialGlobals "main" (negate 1)
  71          (heap1, addr1)
  72              | addressOfMain < 0 = (initialHeap, aLookup initialGlobals "pmain" (error "no main and no pmain"))
  73              | otherwise         = case aLookup initialGlobals "Cons" (error "Cons is not defined") of
  74                  addressOfCons    -> case aLookup initialGlobals "Nil" (error "Nil is not defined") of
  75                      addressOfNil   -> case hAlloc initialHeap (NAp addressOfCons addressOfMain) of
  76                          (h, a)       -> hAlloc h (NAp a addressOfNil)
  77          addressOfPrint = aLookup initialGlobals "printList" (error "printList is not defined")
  78          (initialHeap1, addr) = hAlloc heap1 (NAp addressOfPrint addr1)
  79  
  80  extraPreludeDefs :: CoreProgram
  81  extraPreludeDefs = 
  82      [ ("False", [], EConstr 0 0)
  83      , ("True" , [], EConstr 1 0)
  84      , ("not", ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  85                                (EVar "False"))
  86                           (EVar "True"))
  87      , ("and", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  88                                     (EVar "y"))
  89                                (EVar "False"))
  90      , ("or",  ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  91                                     (EVar "True"))
  92                                (EVar "y"))
  93      , ("xor", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  94                                     (EAp (EVar "not") (EVar "y")))
  95                                (EVar "y"))
  96      , ("MkPair", [], EConstr 0 2)
  97      , ("fst", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  98                           (EVar "K"))
  99      , ("snd", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
 100                           (EVar "K1"))
 101      , ("Nil", [], EConstr 0 0)
 102      , ("Cons", [], EConstr 1 2)
 103      , ("head", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 104                                  (EVar "abort"))
 105                             (EVar "K"))
 106      , ("tail", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 107                                  (EVar "abort"))
 108                             (EVar "K1"))
 109      , ("printList", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 110                                       (EVar "stop"))
 111                                  (EVar "printCons"))
 112      , ("printCons", ["h", "t"], EAp (EAp (EVar "print") (EVar "h"))
 113                                      (EAp (EVar "printList") (EVar "t")))
 114      ]
 115  
 116  buildInitialHeap :: ( ?sz :: Int, ?th :: Int ) => [CoreScDefn] -> (TiHeap, TiGlobals)
 117  buildInitialHeap scDefs = (heap2, scAddrs ++ primAddrs)
 118      where
 119          (heap1, scAddrs)   = mapAccumL allocateSc hInitial scDefs
 120          (heap2, primAddrs) = mapAccumL allocatePrim heap1 primitives
 121  
 122  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 123  allocateSc heap scDefn = case scDefn of
 124      (name, args, body) -> (heap', (name, addr))
 125          where
 126              (heap', addr) = hAlloc heap (NSupercomb name args body)
 127  
 128  allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
 129  allocatePrim heap (name, prim) = (heap1, (name, addr))
 130      where
 131          (heap1, addr) = hAlloc heap (NPrim name prim)
 132  
 133  {- | Evaluator -}
 134  
 135  eval :: (?sz :: Int, ?th :: Int) => TiState -> [TiState]
 136  eval state = state : rests
 137      where
 138          rests | tiFinal state = []
 139                | otherwise      = eval $ doAdmin $ doAdminTotalSteps $ step state
 140  
 141  doAdmin :: (?sz :: Int, ?th :: Int) => TiState -> TiState
 142  doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
 143  
 144  step :: TiState -> TiState
 145  step state = case map toLower $ head state.control of
 146      ""                -> state' { control = tail state.control }
 147      "c"               -> state' { control = repeat "" }
 148      s | all isDigit s -> state' { control = replicate (pred $ read s) "" ++ tail state.control }
 149        | otherwise     -> state' { control = tail state.control }
 150    where
 151          state' = dispatchNode 
 152                      apStep
 153                      scStep
 154                      numStep
 155                      indStep
 156                      primStep
 157                      dataStep
 158                      (error "step: NForward node")
 159                      (hLookup state.heap (fst (pop state.stack)))
 160                    $ state
 161  
 162  numStep :: Int -> TiState -> TiState
 163  numStep n state 
 164      | isEmptyStack state.dump = error "numStep: Number applied as a function"
 165      | otherwise = case popAndRestore state.stack state.dump of
 166          (stack1, dump1) -> setRuleId 7 $ state { stack = stack1, dump = dump1 }
 167  
 168  apStep :: Addr -> Addr -> TiState -> TiState
 169  apStep a1 a2 state = case hLookup state.heap a2 of
 170      NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
 171      _       -> setRuleId 1 $ state { stack = push a1 state.stack }
 172      where
 173          (a,_) = pop state.stack
 174  
 175  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 176  scStep name args body state
 177      | state.stack.curDepth < succ argsLen
 178          = error "scStep: too few arguments given"
 179      | otherwise
 180          = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
 181      where
 182          argsLen  = length args
 183          stack1   = discard argsLen state.stack
 184          (root,_) = pop stack1
 185          heap1    = instantiateAndUpdate body root state.heap (bindings ++ state.globals)
 186          bindings = zip args (getargs state.heap state.stack)
 187  
 188  indStep :: Addr -> TiState -> TiState
 189  indStep addr state = setRuleId 4 $ state { stack = push addr (discard 1 state.stack) }
 190  
 191  primStep :: Name -> Primitive -> TiState -> TiState
 192  primStep name prim = prim
 193  
 194  dataStep :: Tag -> [Addr] -> TiState -> TiState
 195  dataStep tag contents state = state { stack = stack1, dump = dump1 }
 196      where
 197          (stack1, dump1) = popAndRestore state.stack state.dump
 198  
 199  {- | Instantiation -}
 200  
 201  instantiate :: CoreExpr
 202              -> TiHeap
 203              -> Assoc Name Addr
 204              -> (TiHeap, Addr)
 205  instantiate expr heap env = dispatchCoreExpr
 206      (instantiateVar heap env)
 207      (instantiateNum heap env)
 208      (instantiateConstr heap env)
 209      (instantiateAp heap env)
 210      (instantiateLet heap env)
 211      (instantiateCase heap env)
 212      (instantiateLam heap env)
 213      expr
 214  
 215  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 216  instantiateVar heap env name
 217      = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 218  
 219  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 220  instantiateNum heap env num = hAlloc heap (NNum num)
 221  
 222  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 223  instantiateConstr heap env tag arity = hAlloc heap (NPrim "Constr" (primConstr tag arity))
 224  
 225  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 226  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 227      where
 228          (heap1, a1) = instantiate a heap  env
 229          (heap2, a2) = instantiate b heap1 env
 230  
 231  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 232  instantiateLet heap env isrec defs body = instantiate body heap' env'
 233      where
 234          (heap', extraBindings) = mapAccumL instantiateRhs heap defs
 235          env' = extraBindings ++ env
 236          rhsEnv | isrec     = env'
 237                 | otherwise = env
 238          instantiateRhs heap (name, rhs)
 239              = (heap1, (name, addr))
 240              where
 241                  (heap1, addr) = instantiate rhs heap rhsEnv
 242  
 243  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 244  instantiateCase heap env expr alters = error "Cannot instatiate case"
 245  
 246  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 247  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 248  
 249  instantiateAndUpdate :: CoreExpr
 250                       -> Addr
 251                       -> TiHeap
 252                       -> Assoc Name Addr
 253                       -> TiHeap
 254  instantiateAndUpdate expr updAddr heap env = dispatchCoreExpr
 255      (instUpdEVar updAddr heap env)
 256      (instUpdENum updAddr heap env)
 257      (instUpdEConstr updAddr heap env)
 258      (instUpdEAp updAddr heap env)
 259      (instUpdELet updAddr heap env)
 260      (instUpdECase updAddr heap env)
 261      (instUpdELam updAddr heap env)
 262      expr
 263  
 264  instUpdEVar :: Addr
 265              -> TiHeap
 266              -> Assoc Name Addr
 267              -> Name
 268              -> TiHeap
 269  instUpdEVar updAddr heap env v = hUpdate heap updAddr (NInd varAddr)
 270      where
 271          varAddr = aLookup env v (error ("undefined name " ++ show v))
 272  
 273  instUpdENum :: Addr
 274              -> TiHeap
 275              -> Assoc Name Addr
 276              -> Int
 277              -> TiHeap
 278  instUpdENum updAddr heap env n = hUpdate heap updAddr (NNum n)
 279  
 280  instUpdEConstr :: Addr
 281                 -> TiHeap
 282                 -> Assoc Name Addr
 283                 -> Tag
 284                 -> Arity
 285                 -> TiHeap
 286  instUpdEConstr updAddr heap env tag arity
 287      = hUpdate heap updAddr (NPrim "Constr" (primConstr tag arity))
 288  
 289  instUpdEAp :: Addr
 290             -> TiHeap
 291             -> Assoc Name Addr
 292             -> CoreExpr
 293             -> CoreExpr
 294             -> TiHeap
 295  instUpdEAp updAddr heap env e1 e2 = hUpdate heap2 updAddr (NAp a1 a2)
 296      where
 297          (heap1, a1) = instantiate e1 heap  env
 298          (heap2, a2) = instantiate e2 heap1 env
 299  
 300  instUpdELet :: Addr
 301              -> TiHeap
 302              -> Assoc Name Addr
 303              -> IsRec
 304              -> Assoc Name CoreExpr
 305              -> CoreExpr
 306              -> TiHeap
 307  instUpdELet updAddr heap env isrec defs body = instantiateAndUpdate body updAddr heap1 env1
 308      where
 309          (heap1, extraBindings) = mapAccumL instantiateRhs heap defs
 310          env1 = extraBindings ++ env
 311          rhsEnv | isrec     = env1
 312                 | otherwise = env
 313          instantiateRhs heap (name, rhs) = (heap1, (name, addr))
 314              where
 315                  (heap1, addr) = instantiate rhs heap rhsEnv
 316  
 317  instUpdECase :: Addr
 318               -> TiHeap
 319               -> Assoc Name Addr
 320               -> CoreExpr
 321               -> [CoreAlter]
 322               -> TiHeap
 323  instUpdECase updAddr heap env expr alts = error "not implemented"
 324  
 325  instUpdELam :: Addr
 326              -> TiHeap
 327              -> Assoc Name Addr
 328              -> [Name]
 329              -> CoreExpr
 330              -> TiHeap
 331  instUpdELam updAddr heap env vars body = error "not implemented"
 332  
 333  test :: (?sz :: Int, ?th :: Int) => String -> IO ()
 334  test = interact . drive . run 
 335  
 336  -- Gabage Collector (Mark-scan)
 337  
 338  gc :: (?sz :: Int, ?th :: Int) => TiState -> TiState
 339  gc state = case evacuateStack state.heap hInitial state.stack of
 340      ((from1, to1), stack1) -> case evacuateDump from1 to1 state.dump of
 341          ((from2, to2), dump1)  -> case evacuateGlobals from2 to2 state.globals of
 342              ((from3, to3), globals1) -> state { stack = stack1
 343                                                , heap = scavengeHeap from3 to3
 344                                                , globals = globals1
 345                                                , stats = incGcCount state.stats
 346                                                }
 347  
 348  -- gc state = state { heap = scanHeap $ fst
 349  --                         $ mapAccumL markFrom state.heap
 350  --                         $ findRoots state 
 351  --                  , stats = incGcCount state.stats
 352  --                  }
 353  
 354  
 355  findStackRoots :: TiStack -> [Addr]
 356  findStackRoots stack = stack.stkItems
 357  
 358  findDumpRoots :: TiDump -> [Addr]
 359  findDumpRoots dump = []
 360  
 361  findGlobalRoots :: TiGlobals -> [Addr]
 362  findGlobalRoots globals = aRange globals
 363  
 364  findRoots :: TiState -> [Addr]
 365  findRoots state = concat
 366      [ findStackRoots state.stack
 367      , findDumpRoots state.dump
 368      , findGlobalRoots state.globals
 369      ]
 370  
 371  evacuateStack :: TiHeap -> TiHeap -> TiStack -> ((TiHeap, TiHeap), TiStack)
 372  evacuateStack from to stack = case mapAccumL evacuateFrom (from, to) stack.stkItems of
 373      (heaps', addrs') -> (heaps', stack { stkItems = addrs'})
 374  
 375  evacuateDump :: TiHeap -> TiHeap -> TiDump -> ((TiHeap, TiHeap), TiDump)
 376  evacuateDump from to dump = undefined
 377  
 378  evacuateGlobals :: TiHeap -> TiHeap -> TiGlobals -> ((TiHeap, TiHeap), TiGlobals)
 379  evacuateGlobals from to globals = undefined
 380  
 381  evacuateFrom :: (TiHeap, TiHeap) -> Addr -> ((TiHeap, TiHeap), Addr)
 382  evacuateFrom (from, to) addr = case hLookup from addr of
 383      node -> dispatchNode
 384          (\ addr1 addr2 -> case evacuateFrom (from, to) addr1 of
 385              ((from1, to1), addr11) -> case evacuateFrom (from1, to1) addr2 of
 386                  ((from2, to2), addr22) -> case hAlloc to2 (NAp addr11 addr22) of
 387                      (to3, addr3) -> case hUpdate from2 addr (NForward addr3) of
 388                          from3 -> ((from3, to3), addr3)
 389          )
 390          (\ sc args e -> case hAlloc to node of
 391              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 392                  from1 -> ((from1, to1), addr1)
 393          )
 394          (\ n -> case hAlloc to node of
 395              (to1, addr1) -> case hUpdate from addr (NForward addr1) of
 396                  from1 -> ((from1, to1), addr1)
 397          )
 398          (\ addr1 -> evacuateFrom (from, to) addr1
 399          ) 
 400          (\ name prim -> case hAlloc to node of
 401              (to1, addr1) -> case hUpdate from addr1 (NForward addr1) of
 402                  from1 -> ((from1, to1), addr1)
 403          )
 404          (\ tag args -> case mapAccumL evacuateFrom (from, to) args of
 405              ((from1, to1), args1) -> case hAlloc to1 (NData tag args1) of
 406                  (to2, addr2) -> case hUpdate from1 addr (NForward addr2) of
 407                      from2 -> ((from2, to2), addr2)
 408          )
 409          (\ fwaddr -> ((from, to), fwaddr)
 410          )
 411          node
 412  
 413  scavengeHeap :: TiHeap -> TiHeap -> TiHeap
 414  scavengeHeap from to = undefined
 415  
 416  {-
 417  markFromStack :: TiHeap -> TiStack -> (TiHeap, TiStack)
 418  markFromStack hp stk = case mapAccumL markFrom hp stk.stkItems of
 419      (hp', stk') -> (hp', stk { stkItems = stk'})
 420  
 421  markFromDump :: TiHeap -> TiDump -> (TiHeap, TiDump)
 422  markFromDump hp dump = (hp, dump)
 423  
 424  markFromGlobals :: TiHeap -> TiGlobals -> (TiHeap, TiGlobals)
 425  markFromGlobals hp env = mapAccumL markFrom_ hp env
 426      where
 427          markFrom_ heap (name, addr) = case markFrom heap addr of
 428              (heap', addr') -> (heap', (name, addr'))
 429  
 430  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
 431  markFrom heap addr = case hLookup heap addr of
 432      node -> dispatchNode 
 433              (\ addr1 addr2 -> case markFrom heap addr1 of
 434                  (heap1, addr1') -> case markFrom heap1 addr2 of
 435                      (heap2, addr2')  -> (hUpdate heap2 addr (NMarked (NAp addr1' addr2')), addr))
 436              (\ _ _ _       -> (hUpdate heap addr (NMarked node), addr)) -- NSupercomb
 437              (\ _           -> (hUpdate heap addr (NMarked node), addr)) -- NNum
 438              (\ addr1       -> markFrom heap addr1)                      -- NInd
 439              (\ _ _         -> (hUpdate heap addr (NMarked node), addr)) -- NPrim
 440              (\ tag as      -> case mapAccumL markFrom heap as of
 441                  (heap', as')    -> (hUpdate heap' addr (NMarked (NData tag as')), addr))
 442                                                                          -- NData
 443              (\ _           -> (heap, addr))                             -- NForward
 444              node
 445  
 446  scanHeap :: TiHeap -> TiHeap
 447  scanHeap heap =foldl phi heap heap.assocs
 448      where
 449          phi h (a, node) = case node of
 450              NMarked node1 -> hUpdate h a node1
 451              _             -> hFree h a
 452  -}
[34 of 34] Compiling Template.Mark5cp.Machine ( src/Template/Mark5cp/Machine.hs, interpreted )
Ok, 34 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (file src/Template/Mark5cp/PPrint.hs changed)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 34] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 34] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 34] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 34] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 34] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 34] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 34] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 34] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 34] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 34] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 34] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 34] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 34] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 34] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 34] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 34] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 34] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 34] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 34] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 34] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 34] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 34] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 34] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 34] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 34] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 34] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 34] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 34] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 34] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 34] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 34] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[32 of 34] Compiling Template.Mark5cp.State ( src/Template/Mark5cp/State.hs, interpreted )
[33 of 34] Compiling Template.Mark5cp.PPrint ( src/Template/Mark5cp/PPrint.hs, interpreted )
[34 of 34] Compiling Template.Mark5cp.Machine ( src/Template/Mark5cp/Machine.hs, interpreted )
Ok, 34 modules loaded.
>>> :q
Leaving GHCi.
